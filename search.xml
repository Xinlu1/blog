<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[读书简记：《非暴力沟通》]]></title>
    <url>%2F2019%2F01%2F01%2Freading-notes-nonviolent-communication%2F</url>
    <content type="text"><![CDATA[2018 年末尾终于读完了《非暴力沟通》，之所以说“终于”是因为这本书是 15 年在台湾时一位师姐送的，当时出于某些原因一直没拆封看，但又一直没舍得送人或卖掉，就这么随我一路回到了大陆，从杭州到了苏州。18 年的下半年我开始重拾阅读的乐趣，小时候没有手机、电脑和互联网，最大乐趣之一就是读书，管它三教还是九流，只要好看我都照单全收。因此在那个时代，我从《傲慢与偏见》《简爱》《三国演义》等经典名著看到了《小兵传奇》《何以笙箫默》《诛仙》等网络小说，甚至还认识了侯龙涛、少年阿宾等人物…咳咳。 回到本书，我一开始的期望值其实非常低，有点担心它是一本“洗脑”的书（书一直是塑封状态，我没法大致翻阅）。不过开始阅读后却出乎我的意料，迅速意识到这是一本非常优秀的教材，可以帮助我们在生活中更加有效地沟通，从而推动以致达成我们的目标。书中提出了非暴力沟通的四个要素，即观察、感受、需要和请求，将它们串联起来的流程非常具备逻辑性，是一套思路清晰的沟通方法论。更具体一点说，因为我们不善于表达或带有某些情绪，经常会出现毫无意义甚至引发矛盾的沟通，这套方法论通过引导我们把话说清楚、表达更确切来达到沟通原有的积极目的。 书中列举了很多真实案例帮助我们理解和运用非暴力沟通技巧，还提供了一些实用的辅助练习。例如在评价一个人的时候，很显然说“欧文是个差劲的前锋”不如“欧文在过去的5场比赛中没有进一个球”更加理性客观，在谈论周遭的人或事时这种态度尤为重要。又比如父母常常会对子女说“你学习不好让我很失望”，那么真的是子女导致父母的伤心难过吗？为什么天下父母经常这么说而效果不明显？这样的表达方式给子女带来的感受是什么？ 此外，随着我加入微软，了解了更多微软的新闻，惊奇地发现现任 CEO Satya 也会要求高管们阅读本书，这无疑加大了我对本书的认可度以及对微软的信心。 本书共十三章，每一章节都有一个简洁明了的小结，在此摘抄这些小结，以便未来温习与实践非暴力沟通方法时查阅。当然，也推荐给正在阅读这篇简记的读者们，希望你们掌握更加高效的沟通方式。 第一章：让爱融入生活导读也许我们并不认为自己的谈话方式是“暴力”的，但我们的语言确实常常引发自己和他人的痛苦。后来，我发现了一种沟通方式，依照它来谈话和聆听，能使我们情意相通，乐于互助。我称之为“非暴力沟通”。 小结非暴力沟通提醒我们专注于彼此的观察、感受、需要和请求。它鼓励倾听，培育尊重与爱，使我们情意相通，乐于互助。有些人用非暴力沟通理解自己，有些人用它改善人际关系，还有人借助它改进工作。在世界各地，非暴力沟通被用来协调各个层面的争论和冲突。 第二章：是什么蒙蔽了爱？导读我从小就学着以貌似客观的语言表达自己。如果老师布置的作业我不想做，那他就“太过分了”。如果有人开车横冲到我面前，那他就是“混蛋”。如果女友想多一些体贴，那她就“太粘人了”。可是，如果我想多一些体贴，那她“冷漠得像个木头”。如果同事更关心细节，他就是“有强迫症”。反之，如果我更在乎细节，他就是“粗心大意”。 小结人天生热爱生命，乐于互助。可是，异化的沟通方式使我们难以体会到心中的爱。道德评判就是其中的一种，它将不符合我们价值观的人看作是不道德的或邪恶的。进行比较也是一种评判，它会蒙蔽对人对己的爱意。异化的沟通方式还淡化了我们对自己的思想、情感和行为的责任意识。此外，强人所难也会造成心灵的隔阂。 第三章：区分观察和评论导读我从未见过愚蠢的孩子/我见过有个孩子有时做的事/我不理解/或不按我的吩咐做事情/但他不是愚蠢的孩子/请在你说他愚蠢之前/想一想，他是个愚蠢的孩子，还是/他懂的事情与你不一样？ 小结非暴力沟通的第一个要素是观察。将观察和评论混为一谈，别人就会倾向于听到批评，并反驳我们。非暴力沟通是动态的语言，不主张绝对化的结论。它提倡在特定的时间和情境中进行观察，并清楚地描述观察结果。例如，它会说“欧文在过去的5场比赛中没有进一个球”，而不是说“欧文是个差劲的前锋”。 第四章：体会和表达感受导读我在美国学校学了21年，却想不起有什么人问过我的感受。人们认为感受是无关紧要的，重要的是各种权威主张的“正确思想”。于是，我们被鼓励服从权威而非倾听自己。 小结非暴力沟通的第二个要素是感受。通过建立表达感受的词汇表，我们可以更清楚地表达感受，从而使沟通更为顺畅。在表达感受时，示弱有助于解决冲突。此外，非暴力沟通还对表达具体感受的词语与陈述想法、评论以及观点的词语作了区分。 第五章：感受的根源导读如果我们想利用他人的内疚，我们通常采取的办法是，把自己不愉快的感受归咎于对方。家长也许会和孩子说：“你成绩不好让爸爸妈妈伤透了心！”言下之意是，他们快乐或不快乐是孩子的行为造成的。看到父母的痛苦，孩子可能会感到内疚，并因此调整行为来迎合他们。遗憾的是，这种调整只是为了避免内疚，而非出自对学习的热爱。 小结他人的言行也许和我们的感受有关，但并不是我们感受的起因。感受根源于我们自身的需要——非暴力沟通的第三个要素。听到不中听的话时，我们可以有四种选择：1）责备自己；2）指责他人；3）体会自己的感受和需要；4）体会他人的感受和需要。 对他人的职责、批评、评论以及分析反映了我们的需要和价值观。如果我们通过批评来提出主张，人们的反应常常是申辩或反击。反之，如果直接说出我们的需要，其他人就较有可能做出积极的响应。 社会文化并不鼓励我们揭示个人需要。对妇女来说，尤其如此。因为她们的形象常常和无私奉献联系在一起——这是社会对女性的期待。 对于大多数人来说，个人成长一般会经历三个阶段：（1）“情感的奴隶”——我们认为自己有义务使他人快乐；（2）“面目可憎”时期——此时，我们拒绝考虑他人的感受和需要；（3）“生活的主人”——我们意识到，虽然我们对自己的意愿、感受和行动负有完全的责任，但无法为他人负责。与此同时，我们还认识到，我们无法牺牲他人来满足自己的需要。 第六章：请求帮助导读我们越是将他人的不顺从看作是对我们的排斥，我们所表达的愿望就越有可能被看作是命令。 一旦人们认为我们是在强迫他们，他们就会不太想满足我们的愿望。 小结非暴力沟通的第四个要素是请求。我们告诉人们，为了改善生活，我们希望他们做什么。我们避免使用抽象的语言，而借助具体的描述，来提出请求。 在发言时，我们将自己想要的回应讲得越清楚，就越有可能得到理想的回应。由于我们所要表达的意思与别人的理解有可能不一致，有时，我们需要请求他人的反馈。特别是在集体讨论中发言时，我们需要清楚地表明自己的期待。否则，讨论可能只是在浪费大家的时间。 一旦人们认为不答应我们就会受到责罚，他们就会把我们的请求看作是命令。如果我们清楚地表达我们无意强人所难，人们一般会相信，我们提出的是请求而非命令。非暴力沟通的目的不是为了改变他人来迎合我们。相反，非暴力沟通重视每个人的需要，它的目的是帮助我们在诚实和倾听的基础上与人联系。 第七章：用全身心倾听导读遭遇他人的痛苦时，我们常常急于提建议，安慰或表达我们的态度和感受。可是，倾听意味着全心全意地体会他人的信息——这为他人充分表达痛苦创造了条件。 小结当他人遭遇不幸时，我们常常急于提建议，安慰，或表达我们的态度和感受。为了倾听他人，我们需要先放下已有的想法和判断，全心全意地体会对方。倾听他人有助于对他人的理解和接纳。 与此同时，不论别人用怎样的词语表达自己，我们都可以用心体会他们的观察、感受、需要和请求。有时，我们可以主动表达我们的理解，来帮助对方了解我们在何种程度上明白了他的意思。在交流的过程中，我们保持持续的关注，为对方的充分表达创造条件。 当我们痛苦得无法倾听他人时，我们需要（1）体会自己的感受和需要；（2）大声地提出请求；（3）换一个环境。 第八章：倾听的力量导读通过倾听，我们将意识到他人的人性以及彼此的共通之处，这会使自我表达变得容易些。 我们越是倾听他人语言背后的感受和需要，就越不怕与他们坦诚地沟通。 我们最不愿意示弱的时候往往是因为担心失去控制想显得强硬的时候。 小结倾听使我们勇于面对自己的弱点。它还可以帮助我们预防潜在的暴力，使谈话生动有趣，并了解“不！”和沉默所反映的感受和需要。一次又一次，我见证了，倾听帮助人民治愈心灵的创伤。 第九章：爱自己导读我深信，出于对生命纯洁的爱，而不是出于恐惧、内疚、羞愧、职责或义务来选择生活，是爱惜自己的重要体现。 小结非暴力沟通最重要的应用也许在于培育对自己的爱。当我们的表现不完美时，我们可以通过体会忧伤和自我宽恕，来看清个人成长的方向，以及避免自我惩罚。评价自己的行为时，我们专注于尚未满足的需要；这样，我们就不再依赖于羞愧、内疚、愤怒或沮丧的心理来寻求改变，而让爱主导我们的学习和成长。 同时，在日常生活中，我们主动根据需要和价值观来选择生活。我们的行为不再是为了履行职责、获得回报、逃避惩罚或避免感到内疚和羞愧。通过深入理解我们行为的动机，并用“选择做”来取代“不得不”，我们的生活将变得和谐并充满欢乐。 第十章：充分表达愤怒导读在我看来，愤怒是我们的思维方式造成的。它的核心是尚未满足的需要。 如果我们能够借助它来提醒自己——我们有需要没有得到满足，而我们的思维方式正使它难以得到满足，那愤怒就是有价值的。 小结在生气时，批评和指责他人都无法真正传达我们的心声。如果想充分表达愤怒，我们就不能归咎于他人，而把注意力放在自己的感受和需要上。与批评和指责他人相比，直接说出我们的需要更有可能使我们的愿望得到满足。 表达愤怒的四个步骤是：（1）停下来，除了呼吸，什么都别做；（2）想一想是什么想法使我们生气了；（3）体会自己的需要；（4）表达感受和尚未满足的需要。有时，在第3步和第4步之间，我们需要先倾听他人。在得到倾听和理解之后，他们也就可以静下心来体会我们的感受和需要。 我们需要给自己充分的时间来学习和运用非暴力沟通。 第十一章：运用强制力避免伤害导读我们都知道，惩罚将导致关系的疏远。一旦我们被看作是施暴的人，我们就很难得到友善的回应。 小结在有些情形中，我们没有机会和他人交流，这时，我们也许需要使用强制力来保护自己和他人。我们这样做，是为了避免伤害，而不是为了惩罚他人。如果我们威胁他人或实施惩罚，人们常常会产生敌意和抵触心理。这样，彼此的关系将会疏远。同时，惩罚还可能使人忽视事情本身的意义，而把注意力放在不服从的后果上。如果我们试图通过惩罚来使人们认识自己的需要，那么，我们很可能适得其反。 第十二章：重获生活的热情导读通过运用非暴力沟通，我们不再试图分析自己或他人有什么毛病，而是用心去了解我们的需要，这样，我们的内心将逐渐变得平和。 小结在情绪低落的时候，我们也许会怨天尤人。然而，如果我们以苛刻的态度对人对己，我们的心情也好不到哪里去。通过运用非暴力沟通，我们不再试图分析自己或他人有什么毛病，而是用心去了解我们的需要，这样，我们的内心将逐渐变得平和。一旦我们发现自己心底深处的愿望，并采取积极的行动，我们将会重获生活的热情。心理咨询和心理治疗行业的从业人员可以考虑借助非暴力沟通来与来访者进行坦诚的交流。 第十三章：表达感激导读有一天晚上，当我向我的儿子布莱特指出他没做好家务活时，他反驳说：“爸，你想想，你是不是倾向于指出问题，而很少肯定我？”他的话在我脑海中盘绕了许久。 小结在赞扬他人时，我们很少揭示内心活动，而把自己放在了裁判的位置。赞扬也常常被人用来实现个人目的。非暴力沟通鼓励我们充分表达感激。在表达感激时，我们说出：（1）对我们有益的行为；（2）我们的哪些需要得到了满足；（3）我们的需要得到满足后，我们是什么样的心情。 当别人以这样的方式表达对我们的感激时，我们可以与对方一起庆祝生命的美——既不自大，也不假谦虚。]]></content>
      <tags>
        <tag>communication</tag>
        <tag>nonviolent communication</tag>
        <tag>efficiency</tag>
        <tag>empathy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里，江湖再见]]></title>
    <url>%2F2018%2F11%2F13%2Fgoodbye-alibaba%2F</url>
    <content type="text"><![CDATA[还记得刚来阿里听到“一年香，三年陈，五年醇”的说法时，内心想着一定要至少待满五年再走；也还记得在争取转岗时，感到前途一片迷茫，每天都不想来上班，但也没想过要离开阿里。然而此时，精神上非常享受现在工作的我，身体扛不住了，不得不先离开这片江湖。 于是，感恩在阿里的这八百余天，如同老人们一样，写下这篇离职帖作为告别吧。 我于 16 年作为应届生加入阿里，那会在台湾读硕士，为毕业论文挣扎，错过了国内的秋招。16 年春的时候，经若远师兄内推加入了阿里。过程其实很曲折，技术面面了 7 轮，全是电话和视频面，差点就挂了，感谢最后峰哥和珈夜给我机会，把我带进了阿里的大门，也让我进入了互联网行业。 我此前一直从事嵌入式相关的开发，来阿里前以为做 ARM Trustzone 相关的东西，结果没想到入职第一天便“拥抱变化”转行做了 Web 前端开发（还不是特别互联网的那种），所在小组的主要产品是基于 Atom (Electron) 二次开发的 YunOS IDE。那段日子过得比较苦，没有产品、设计资源，除了技术开发，需求梳理、外观设计包括后面的客服答疑都得自己来，同时我之前一直是 Terminal + VIM 党，IDE 相关的业务背景为 0，加上前端储备几乎为 0…这里必须要感谢第一任主管晓璐给了我很长一段时间适应和学习，至少在着陆时没有脑袋直接着地，连滚带爬还能往前苟活。 那会我个人的状态不好，YunOS 部门状态更差：看不清方向，看不到未来，项目说做就做、说停就停，CEO 发给全员的邮件里自己打 3.25，接着整个 BU 3.25。更可怕的是，YunOS 给人一种强烈的国企氛围，都烂成这样了，各个群里都还是随缘点赞的祥和氛围，除了开始有人陆续离开。作为一名 Web 前端开发，我当时危机感特别强，也在犹豫要不要继续干前端。大家都说你很聪明，技术功底不错，但你没法拿出事实证明自己！开发吃的是技术饭，而小组那会情况很不理想：UI 框架在 2017 年上半年才玩了半年 Vue，之前是 Backbone，React 在后来才被少数模块使用；Node 服务莫名采用了针对淘系业务产出的 Midway.js 框架，diamond 是啥不知道，就看日志里打了一堆东西；没人搞明白 SSR 和 VM，乱用模板引擎；没有文件版本号维度管理；没人关注性能优化；缺少自动化代码打包、构建、发布 CDN 等一整套完整的流程；没有自适应和无线端开发的业务和经验；等等。 这里并非指责任何人和事，毕竟时间过去那么久，已然成为一段经历。只想说明当时的我意识到太多问题，慌了！想了很久，决定在入职不满一年的情况下尝试转岗，去业务第一线，继续做前端。 转岗给了我很大的信心，聊过的几个团队都愿意接受我，这让我很感动。但卡住我的最大问题是入职未满两年，以及 YunOS 那会“号称”冻结转岗（因为大家没见到集团的通知，都是口口相传）。最终在珈夜的沟通与帮助下，“抗争”了几个月，我在 17 年底终于加入 Lazada 卖家团队。 Lazada 的工作量非常大在加入前就早有耳闻，那会打听的时候就有好几个人劝不要来，但我就想好好体验一把“地狱模式”，弥补过去一年成长的缓慢。而给我这个机会的是现任主管 Tank 和大老板 Gary。Gary 作为男神级人物，老阿里人，82 年的 P9，业务思考、团队管理、沟通能力都让人十分佩服。而 Tank 则是让我义无反顾愿意加入的理由。试想今天有一位候选人与你联系想主动转岗，但受限于集团政策，你会怎么办？大多数 TL 都是友好而简洁地表示以后有机会再联系，这合情合理。但 Tank 和我说了不少关于工作上的建议，即便我不能过去，但依然非常诚恳、希望能帮助我。当然除了有情有义，他也年轻有为，28 岁加入阿里时就是 P7，带过团队。事实证明这个选择没有错，卖家团队配置齐全、高手如云、比较团结。在与产品、设计、后端以及客户端同学的配合切磋中，在各种业务场景和技术方案的高压下，我被虐得很爽，感受到了成长的滋味。此外对内与多个部门合作、对外响应多国的业务同学甚至用户，着实打开了我的眼界。可以这么说，在 Lazada 的这段时光，才让我有种真正进入阿里的感觉。 然而在精神非常享受的时候，我的身体却有点跟不上节奏了。颈椎问题以往晚上才会开始冰凉刺痛，现在刚到下午就开始提醒我要活动一下。此外由于免疫力下降，最近几个月皮肤出了一些问题，目前还好，但看了网上一些病情严重的案例，有点被吓到。再加上之前赤铁去世的事，让我很震惊，他是我进阿里的面试官之一，一位正值壮年的前辈就这么走了，这件事又令我想了很久。 我决定离开，去外企，多一点个人时间休养身心。 离开的第一个原因上面已经说了，第二个原因是我不喜欢余杭。虽说很多同事在周边买了房，但我始终认为余杭配不上阿里。环境，素质，基建，房价，哪一个拿得出手？但这种地域黑的观点说出来难免被喷，就到此为止。 得益于在 Lazada 扎实的工作经历和技术打磨，我在裸面的情况下把想拿的 Offer 基本上都拿到了，最终选择去微软亚洲工程院做机器学习相关的事。选微软其实很简单，一是即使现在中国互联网盛行、外企的人才竞争力下降，但王坚博士等一票优秀的前辈都是从那里出来（不过不少是从 MSRA 来的）滋润了阿里，我想去看看；二是刚好有个机会可以从工程角度再次接触人工智能方面的东西，我也想往这个方向看看，同时不会和互联网行业太脱节。 两年的时光过得太快，经历了许多。现在回头想想，纵使是出了非常多幺蛾子、见识了不少奇葩，也都是满满的人生收获。除了专业和心智上的成长外，最珍贵的就是认识了一帮优秀的同学，有前面提过的一些前辈，也有许多同龄人。珈夜、瀚雷、卖家团队的前端小伙伴们、YunOS 相互取暖的基友们、畅谈技术的三哥、给我抛过橄榄枝的剑翘、羽括等等等等，是你们让我感受到了“一群有情有义的人，在一起做有价值的事情”。 阿里这个大平台使我们相识相聚，就让我们江湖再见吧。]]></content>
      <tags>
        <tag>leave</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018 年 JavaScript 测试概观]]></title>
    <url>%2F2018%2F10%2F29%2Fan-overview-of-javascript-testing-in-2018%2F</url>
    <content type="text"><![CDATA[源文链接：An Overview of JavaScript Testing in 2018原文链接：2018 年 JavaScript 测试概观 摘要：使用 Jest 进行单元和集成测试，使用 TestCafe 进行 UI 测试。 引子看看 Facebook 推出的测试框架 Jest 的 logo： 你可以看到他们的口号承诺“无痛”地进行 JavaScript 测试，然而“评论中的某些人”指出： 不过 Facebook 确实有一个很棒的理由使用这个口号。通常 JS 开发者都不太喜欢网站测试，JS 测试意味着受限制、很难实现、进度缓慢且时而代价昂贵。尽管如此，只要使用正确的策略和正确的工具组合，一次接近全覆盖的测试也可以完成得有组织、简单并相对快速。 测试的类型你可以通过这里、这里以及这里更深入地了解不同的测试类型。大体上，对于一个网站来说，最重要的几类测试有： 单元测试 (Unit Tests)：通过输入和预期的输出结果测试独立的函数或者类； 集成测试 (Integration Tests)：测试流程或组件的表现是否符合预期，包括副作用； UI 测试 (UI Test)（又名功能测试 (Functional Tests)）：在浏览器中对产品进行一些使用场景测试，无视其内部结构，只保证行为符合预期。 测试工具的类型测试工具可以划分为以下功能类型，其中一些提供单一功能，而另一些则提供功能组合。为了功能性更加灵活，使用组合工具也很常见，即使存在一款工具可以实现类似的功能。 提供一个测试结构 (testing structure) (Mocha, Jasmine, Jest, Cucumber) 提供断言函数 (assertions functions) (Chai, Jasmine, Jest, Unexpected) 生成、展示 (display) 并观察 (watch)测试结果 (Mocha, Jasmine, Jest, Karma) 生成并对比组件和数据结构的快照 (snapshots)确保早先运行中的变化符合预期 (Jest, Ava) 提供 mocks、spies 和 stubs (Sinon, Jasmine, enzyme, Jest, testdouble) 生成代码覆盖 (code coverage) 报告 (Istanbul, Jest, Blanket) 提供浏览器或近似浏览器环境 (browser or browser-like environment) 并可以在场景执行时进行控制 (Protractor, Nightwatch, Phantom, Casper) 让我们解释上述提到的一些术语： 测试结构指的是测试的组织方式。如今测试经常被组织成支持行为驱动开发 (behavior-driven development) 的 BDD 结构 (BDD structure) 。通常看起来像这样： 12345678910describe('calculator', function() &#123; // 使用嵌套 "describe" 函数描述一个模组 describe('add', function() &#123; // 详述预期行为 it('should add 2 numbers', function() &#123; // 使用断言函数测试预期行为 ... &#125;) &#125;)&#125;) 断言函数确保被测试的变量包含预期值。它们通常看起来像这样，其中最流行的写法莫过于前两种方式： 123456789101112131415// Chai expect (流行)expect(foo).to.be.a('string')expect(foo).to.equal('bar')// Jasmine expect (流行)expect(foo).toBeString()expect(foo).toEqual('bar')// Chai assertassert.typeOf(foo, 'string')assert.equal(foo, 'bar')// Unexpected expectexpect(foo, 'to be a', 'string')expect(foo, 'to be', 'bar') TIP: 这里有一篇关于进阶的 Jasmine 断言好文。 Spies 提供了函数相关的信息：函数被调用了多少次，在什么情况下被调用，被谁调用？在集成测试中我们会使用它确保一个流程中的副作用符合预期，例如在下列场景中观察该方法是否只执行了一次？ 123456789101112it('should call method once with the argument 3', () =&gt; &#123; // 创建一个 sinon spy 来监视 object.method const spy = sinon.spy(object, 'method') // 调用方法，入参为 "3" object.method(3) // 确保在入参正确的情况下 object.method 只被调用了一次 assert(spy.withArgs(3).calledOnce) &#125;) Stubbing 或 dubbing （好比电影中的替身演员）通过替换选中的函数来测试模块的正确性。如果我们在测试另外的组件时希望 user.isValid() 总是返回 true，可以这么做： 12345// Sinonsinon.stub(user, 'isValid').returns(true)// Jasmine stubs 实际是有 stubbing 功能的 spiesspyOn(user, 'isValid').andReturns(true) 也可以使用 promise 的方式： 12345678910111213it('resolves with the right name', done =&gt; &#123; // 确保 User.fetch "回复"的是我们配置的值"David" const stub = sinon .stub(User.prototype, 'fetch') .resolves(&#123; name: 'David' &#125;) User.fetch() .then(user =&gt; &#123; expect(user.name).toBe('David') done() &#125;)&#125;) Mocks 或 Fakes 通过伪装成某些模块或行为测试一系列过程中的不同情况。举例来说，Sinon 能仿冒一个服务器离线和网络状况良好的情况来测试期望的应答。 123456789101112131415161718192021222324252627it('returns an object containing all users', done =&gt; &#123; // 创建并配置一个假的服务器取代原生的网络请求 const server = sinon.createFakeServer() server.respondWith('GET', '/users', [ 200, &#123; 'Content-Type': 'application/json' &#125;, '[&#123; "id": 1, "name": "Gwen" &#125;, &#123; "id": 2, "name": "John" &#125;]' ]) // 调用一个包含我们模拟网络请求的流程 Users.all() .done(collection =&gt; &#123; const expectedCollection = [ &#123; id: 1, name: 'Gwen' &#125;, &#123; id: 2, name: 'John' &#125; ] expect(collection.toJSON()).to.eql(expectedCollection) done() &#125;) // 响应请求 server.respond() // 移除假服务器 server.restore()&#125;) 快照测试 (Snapshot Testing) 会对某一数据结构与期望值进行比较。下面的例子来自 Jest 官方文档，展示了某一 Link 组件的快照测试。 12345678910111213it('renders correctly', () =&gt; &#123; // 创建一个包含页面链接和内部文字的 Link 组件实例 const linkInstance = ( &lt;Link page="http://www.facebook.com"&gt;Facebook&lt;/Link&gt; ) // 创建一个组件的数据快照 const tree = renderer.create(linkInstance).toJSON() // 比较数据和上一次快照 expect(tree).toMatchSnapshot()&#125;) 在此过程中不会真正渲染该组件并截图，而是在一个独立的文件中保存其内部数据结构，大概长这样： 12345678910exports[`renders correctly 1`] = `&lt;a className="normal" href="http://www.facebook.com" onMouseEnter=&#123;[Function]&#125; onMouseLeave=&#123;[Function]&#125;&gt; Facebook&lt;/a&gt;`; 当新产生的快照与上一次不同时，将提示开发者是否同意此次改动是有意为之。 注意：快照通常用来比对体现数据的组件，其实它们也可以比较其他的数据类型，如 redux stores 或应用中不同单元的内部结构。 浏览器或近似浏览器环境可以是以下三种之一： jsdom —— 一个模拟真实浏览器的纯 JavaScript 环境。它没有 UI 也不做渲染，只提供浏览器 JS 运行时所需的 window, document, body, location, cookies, selectors 等接口。 无头浏览器环境 (Headless Browser Environment) —— 一个为了响应速度更快而缺省 UI 的浏览器。 真实浏览器环境 (Real Browser Environment) —— 一个运行你测试用例的真实浏览器。 把所有东西放在一起…如果可以，我们建议面对所有测试类型都使用同一套工具：相同的测试结构和语法 (1)、断言函数 (2)、结果报告以及监控机制 (4)。 我们还建议创建两类不同的流程，一类运行单元和集成测试，另一类则运行 UI 测试。这是因为 UI 测试需要耗费更长的时间，尤其在跨浏览器测试时通常会使用外部提供的多设备、多浏览器付费服务（这个后续还会讨论），因此相比第一类流程你不会想跑更多的 UI 测试，譬如只在合并一条特征分支前才运行一次。 单元测试应当覆盖应用中所有小而纯粹的单元：工具 (utils)、服务 (services) 以及助手 (helpers)。给这些单元简单和边界情况的输入并使用断言函数 (3) 确保输出正确。另外也需要使用覆盖率报告工具 (6) 了解哪些单元被测试到了。 单元测试是尽可能使用函数式编程以及纯函数的理由之一——你的应用越纯粹就越容易被测试。 集成测试 老派的测试往往注重单元测试，这导致了应用的各个微观部分功能正常，但是所有流程合在一起时就会出错。 当你修复了某个问题，但是又破坏了其他部分时，集成测试（包含快照）可以从另一个角度捕捉许多未知的错误。 同样需要记住的是，在这个真实的世界存在因各种理由而出现的不完美的设计和广泛应用的黑盒子，并不是所有单元模块都是纯函数，也不是所有单元都可以被测试——有一些单元仅作为某个更大流程中的一部分而能被测试到。 集成测试需要覆盖重要的跨模组流程。相较于单元测试，你可能会使用 spies (5) 确保一些预期的副作用而非只对输出做断言，同时使用 stubs (5) 模拟、修改在特定测试中不存在的部分流程。 并且与单元测试相反，一个浏览器或近似浏览器环境 (7) 可以支持依赖 window 、渲染某一组件或与组件交互的各种流程。 组件快照测试 (4) 也属于此类测试。它们提供了一种无需真实渲染或使用浏览器就可以测试流程对选中组件影响的方式。 UI 测试有时候快速高效的单元和集成测试还不够。 UI 测试总是运行在一个浏览器或近似浏览器环境 (7) 中，模拟用户行为（点击，输入，滚动等等…），确保这些场景在终端用户眼中确实工作。 请记住这类测试是最难准备的。设想你自己创建一个环境在不同的机器、设备、浏览器类型和版本上运行一个测试… 这就是为什么有很多服务商为你提供这项服务。你还可以在这里发现更多。 常见的知名测试工具Jsdomjsdom 是 WHATWG DOM 和 HTML 标准的一个 JavaScript 实现。换言之 jsdom 仅用纯 JS 模拟了一个浏览器环境。之前提过，在这样的模拟浏览器环境中，测试运行的速度十分快。缺点则是在一个真实浏览器之外 jsdom 无法模拟所有功能，因此这会限制你的测试范围。 值得一提的是 JS 社区很快改进了它，目前的版本已经非常接近真实浏览器。 IstanbulIstanbul 会告诉你有多少代码被单元测试所覆盖。它通过报告状态、行数、函数和分支覆盖维度的百分比情况以便你更好地理解哪些部分代码没有被覆盖到。 KarmaKarma 允许你在浏览器和近似浏览器环境甚至 jsdom 中进行测试。它运行的测试服务器有一个特殊网页可以让你的测试运行在页面环境中，而这个页面还可以跨浏览器运行。这也意味着测试可以通过 BrowserStack 之类的服务远程执行。 ChaiChai 是最流行的断言库。（译者注：此处人狠话不多） UnexpectedUnexpected 是一个与 Chai 的语法稍有不同的断言库。其可扩展性衍生出了一些使断言功能更高级的库例如 unexpected-react ，你可以从这里了解更多。 Sinon.jsSinon 是一个强大的 spies, stubs 和 mocks 独立库，可与任何单元测试框架配合工作。 testdouble.jstestdouble 是一个声称比 Sinon 更加优秀但名气稍逊的库。其设计、哲学和特性与 Sinon 略有不同使其在许多情况下更实用，你可以从这里、这里和这里读到更多。 WallabyWallaby 是另一款值得一提的工具。尽管需要付费，但很多用户推荐购买。它运行在你的 IDE （支持所有主流 IDE）之上，执行代码变更相关的测试，并在失败后实时定位错误代码。 CucumberCucumber 通过按验收准则文件 (accpetance criteria files，使用 Gherkin 语法) 划分并按与之对应的方式协助编写 BDD 结构的测试用例。框架支持的多种语言都可以编写测试用例，包含我们关注的 JS： 123456789# Filename: "like-article.feature"Feature: A reader can share an article to social networks As a reader I want to share articles So that I can notify my friends about an article I likedScenario: An article was opened Given I'm inside an article When I share the article Then the article should change to a "shared" state 1234567891011121314// Filename: "like-article.step.js"module.exports = function() &#123; this.Given(/^I'm inside an article$/, function(callback) &#123; // 函数式测试工具代码 &#125;) this.When(/^I share the article$/, function(callback) &#123; // 函数式测试工具代码 &#125;) this.Then(/^the article should change to a "shared" state$/, function(callback) &#123; // 函数式测试工具代码 &#125;)&#125; 许多团队会发现这种语法比 TDD 更方便。 选择你的单元和集成测试框架第一个选择你应该做得也许是框架与其相关函数库。建议使用框架内提供的工具直到依赖某些绝无仅有工具的需求出现。 简而言之，如果你只想入门或针对大型功能寻找一款够快的框架，选择 Jest。 如果你想要灵活和可扩展的配置，选择 Mocha。 如果你喜欢简单选择 Ava。 如果你想要非常底层的框架，选择 tape。 这里有一份介绍主流工具及其特性的列表： mochaMocha 是目前最常用的库。不像 Jasmine，它使用第三方的断言、mocking 和 spying 工具（通常是 Enzyme 和 Chai ）。这意味着 Mocha 在初始配置时有一定难度并需要了解更多库，但这也会变的更加灵活、更开放去扩展。 举例来说，如果你想要特殊的断言逻辑，可以 fork Chai（译者注：此处怀疑是笔误，fork Mocha 看起来更合理）并使用自己的断言库仅替换 Chai。虽说这在 Jasmine 中也可以实现，但这种修改在 Mocha 中更显而易见。 社区 (Community)：有许多插件和扩展来测试独特的场景。 扩展性：插件、扩展和例如 Sinon 之类的库包含了许多 Jasmine 没有的特性。 全局变量 (Globals)：默认会创建测试结构的变量，但是显然不像 Jasmine 那样包含了断言、spies 和 mocks ——有些人对这种看似不一致的变量感到吃惊。 JestJest 是 Facebook 推荐的测试框架，基于我们将会讨论的 Jasmine 开发。不过现如今 Facebook 已经替换了大多数 Jasmine 的功能并在顶层新增了许多特性。 在阅读了大量文章和博客之后，人们对 Jest 速度与便利的印象深刻令人难以置信。 性能 (Performance)：Jest 首要考虑的是通过实现一个灵活的并行测试机制使得处理包含大量测试文件的大型工程速度更快（以我们的经验和一些博客为例：这里，这里，这里，这里）。 用户界面：清楚方便。 直接上手 (Ready-To-Go)：自带和 Sinon 功能相同的断言、spies 和 mocks 库。如果你需要一些额外的特性，使用函数库也很容易。 全局变量：与 Jasmine 类似，Jest 默认创建了测试相关的全局变量因此不用导入它们。虽然这可能导致测试不够灵活和可控而被诟病，但在绝大多数情况下都让测试更加容易： 1234567// "describe" 已经在全局范围中，因此不需要这些导入代码：// import &#123; describe &#125; from 'jest'// import &#123; describe &#125; from 'jasmine'describe('calculator', function() &#123; ...&#125;) 快照测试：Facebook 开发并维护了 jest-snapshot，不过它也可以作为工具集成的一部分被绝大多数框架使用，或通过正确的插件来使用。 改进后的模组仿真 (Improved modules mocking)：Jest 提供了一种简单的方法模拟任务繁重的模组以提升测试速度。例如一项服务可以通过 resolve 一个 promise 模拟一次网络请求。 代码覆盖：包含一个基于 Istanbul 的功能强大、高效的内置代码覆盖工具。 可靠性 (Reliability)：尽管这是一个相对年轻的函数库，但从 2017 年 Jest 逐步稳定直到现在被认为可靠，且被所有主流 IDEs 和相关工具所支持。 开发 (Development)：Jest 会对测试文件进行增量更新，因此在观察模式下的测试速度非常快。 Jasmine既然有了基于 Jasmine 构建的 Jest，为什么还要使用 Jasmine 呢？答案是后者存在得时间更久，有大量来自社区的文章和工具可以参考。同时，Angular 依然推荐使用它而非 Jest，尽管 Jest 目前也已完美适配 Angular 测试，且有很多人在使用。 直接上手：包含所有测试所需的东西。 全局变量：在全局范围内提供所有重要的测试特性。 社区：自从 2009 年问世以来积攒了海量文章、建议及工具。 Angular：Angular 的所有版本都支持 Jasmine，并在其官方文档中推荐使用。 AVAAva 是一个并行执行测试的极简 (minimalistic) 测试库。 直接上手：包含所有测试所需的东西（除了可以秒加 spying 和 dubbing）。在测试结构使用以下语法、断言函数，并在 Node.js 中运行： 12345import test from 'ava'test('arrays are equal', t =&gt; &#123; t.deepEqual([1, 2], [1, 2])&#125;) 全局变量：上文可见，Ava 没有创建任何测试相关的全局变量，因此你对你的测试有更多控制。 简单 (Simplicity)：支持许多高级特性时有着简单的结构和断言函数，摒弃了复杂的 API。 开发：Ava 会对测试文件进行增量更新，因此在观察模式下的测试速度很快。 速度 (Speed)：以独立 Node.js 进程的方式并行执行测试。 快照测试：作为框架的一部分被支持。 tapeTape 是这些框架中最简单的。它仅有一个 Node.js 文件和一个非常简短的 API。 简单：简约的结构和断言函数，没有一个复杂的 API，甚至超越了 Ava。 全局变量：不创建任何测试相关的全局变量因此你可以更多地掌控你的测试。 测试间无共享状态 (No Shared State between tests)：Tape 不鼓励使用 “beforeEach” 之类的函数以确保测试模块化以及对于测试周期的用户最大化控制。 无命令行界面 (No CLI)：Tape 在任何 JS 可以运行的地方都能跑。 UI 测试工具首先就像之前提过的，你可以在这里和这里找到有关服务提供商的好文，这些服务提供商提供主机帮助你在不同的设备和浏览器上执行你的测试。 长期以 UI 测试为目标的工具从实现、哲学到 API 都多种多样，因此强烈建议花时间理解不同的解决方案并在你的产品中检验它们。 简短说，如果你只想通过一个可靠、设置简单的多浏览器合一的工具入门，使用 TestCafe。 如果你想要随波逐流并获得最多的社区支持，WebdriverIO 是正道。 如果你不在乎跨浏览器支持，使用 Puppeteer。 如果你的应用没有复杂的交互和图像，例如一个充满表格和导航的系统，可以使用跨浏览器无头工具如 Casper。 seleniumSelenium 使用浏览器自动化模拟用户行为。它并不是专为测试创造，通过暴露一个在浏览器上模拟用户行为的服务器来达到多种用途。 Selenium 可以被多种方式控制，支持许多编程语言，甚至搭配一些工具后无需任何实际编程。 对我们的需求而言，通过一个 Selenium WebDriver 提供通信层供我们的 NodeJS 代码与操作浏览器的 Selenium 服务器通信从而实现控制。 ​ Node.js &lt;=&gt; WebDriver &lt;=&gt; Selenium Server &lt;=&gt; FF/Chrome/IE/Safari WebDriver 被引入测试框架后，测试代码可参考如下的部分代码： 12345678910111213141516171819202122232425262728describe('login form', () =&gt; &#123; before(() =&gt; &#123; return driver.navigate().to('http://path.to.test.app/') &#125;) it('autocompletes the name field', () =&gt; &#123; driver .findElement(By.css('.autocomplete')) .sendKeys('John') driver.wait(until.elementLocated(By.css('.suggestion'))) driver.findElement(By.css('.suggestion')).click() return driver .findElement(By.css('.autocomplete')) .getAttribute('value') .then(inputValue =&gt; &#123; expect(inputValue).to.equal('John Doe') &#125;) &#125;) after(() =&gt; &#123; return driver.quit() &#125;) &#125;) WebDriver 本身对你来说可能已经足够，实际上一些人也建议使用它本体，不过还是有许多库通过分支或包装的形式扩展了它。包装后的 WebDriver 可能添加了多余的代码导致调试更加困难，而分支方式则可能偏离 2018 年正在活跃开发中的 WebDriver 。 就算这样，一些人仍偏向不直接使用它，所以让我们看看有关 Selenium 操作的库吧。 AppiumAppium 提供类似 Selenium 的 API 测试移动设备上的站点，同时使用了以下工具： iOS 9.3+： Apple 的 XCUITest Before iOS 9.3： Apple 的 UIAutomation Android 4.2+： Google 的 UiAutomator/UiAutomator2 Android 2.3+： Google 的 Instrumentation. （通过打包一个独立的工程提供指令支持, Selendroid） Windows Phone： Microsoft 的 WinAppDriver 因此如果你使用 Selenium 或基于 Selenium 开发的工具，你同样可以使用 Appium 在移动设备上测试。 ProtractorProtractor 是一个包装 Selenium 并支持 Angular 增强语法以及特殊内置钩子的库。 Angular：尽管可以成功接入其他 JS 框架，但针对 Angular 提供了特殊的钩子。Angular 官方文档也推荐使用该工具。 错误报告 (Error reporting)：很好的机制。 支持 (Support)：目前已支持 Typescript，库本身由庞大的 Angular 团队更新维护。 WebdriverIOWebdriverIO 实现了另一个版本的 Selenium WebDriver： 语法：非常容易和可读。 灵活：一个简单、灵活和可扩展的库。 社区：拥有良好支持和热心开发者社区提供的丰富插件及扩展。 NightwatchNightwatch 也实现了又一个 Selenium WebDriver，并提供了自己的测试框架包含一个测试服务器、断言和一些工具。 框架：也可以与其他框架搭配使用，不过在你想要运行功能性测试而非作为其他框架的一部分时特别有用。 语法：看起来是最简单和最可读的。 支持：不支持 Typescript，大体上看这个库似乎比其他库的支持要少一丢丢。 TestCafeTestCafe 是基于 Selenium 的不错替代品，在 2016 年底重写并开源。 它仍有一款付费版本提供一些免编程的测试工具例如测试录制和用户支持，这很重要，因为有许多过时的文章错误地陈述其代码已停止开发并将这视为库的缺点。 与 Selenium 不同的是它通过 JavaScript 脚本的形式注入到网站中来控制浏览器。这使得 TestCafe 可以运行在任意浏览器中，包含移动设备，并完全控制 JavaScript 的执行循环。 TestCafe 是 JavaScript 和测试导向的。尽管已经被认为稳定和功能丰富，但目前仍然处于大规模开发状态。 快速构建 (Fast to set up)：随意打开一个浏览器就可以跑你的测试。 跨浏览器和设备 (Cross Browser and Devices)：支持许多浏览器和设备，可与提供设备和浏览器测试的 SauceLabs 或 BrowserStack 配合使用。这包含了在无头 Chrome 和无头 Firefox 中运行测试，将会在后续讨论到。 并行测试 (Parallel Testing)：TestCafe 可以一次在多个浏览器实例中运行你的测试。这个实践可以显著地缩短你的测试时间。 方便的错误报告 (Convenient Error Reporting) 自有生态系统 (Own Ecosystem)：TestCafe 使用自己的测试结构。这可能很方便，尤其因为 UI 测试经常与其他测试分开执行，不过有些人并不喜欢。 12345678910111213import &#123; Selector &#125; from 'testcafe';fixture `Getting Started` .page `https://devexpress.github.io/testcafe/example`// 自己的测试结构test('My first test', async t =&gt; &#123; await t .typeText('#developer-name', 'John Smith') .click('#submit-button') .expect(Selector('#article-header').innerText) .eql('Thank you, John Smith!')&#125;) CypressCypress 是 TestCafe 的直接竞争对手之一。他们做的事情类似，如注入测试到网站中，但 Cypress 尝试将其做得更加现代化、灵活和方便。 Cypress 非常年轻，刚从封闭 beta 版推进到公开 beta 版（在 2017 年十月），却已经有很多发烧友。 不支持跨浏览器：目前仅支持 Chrome （也不支持无头版）。不过这个问题已经被创建，开发者也正在为之努力。 缺乏高级功能：相较 TestCafe 而言缺少并行测试和专有测试工具，不过这些都已经在产品的路线图中了。 文档：详实且清楚。 调试工具：在测试过程中容易调试和打日志。 Mocha：使用 Mocha 作为其测试结构的提供者，确保使用起来非常标准，UI 测试可与其他测试构建在同一结构中。 123456789101112131415describe('My First Cypress Test', function() &#123; it("Gets, types and asserts", function() &#123; cy.visit('https://example.cypress.io') cy.contains('type').click() // 应在一个包含 '/commands/actions' 的新 URL 上 cy.url().should('include', '/commands/actions') // 取一个输入，打字填入其中，并验证其值已经更新 cy.get('.action-email') .type('fake@email.com') .should('have.value', 'fake@email.com') &#125;)&#125;) PuppeteerPuppeteer 是一个 Google 开发的 Node.js 库，提供了方便的 Node.js API 操控无头 Chrome。 无头 Chrome 就是一个运行了 --headless 标志位的常规 Chrome v59+。当 Chrome 运行在无头模式时，会暴露出 API 供外界管理，而 Puppeteer 就是 Google 提供控制它的 JavaScript 工具。 值得一提的是 Firefox 在 2017 年底也推出了无头模式。 注意其他不同的测试工具如 TestCafe、Krama 也可以使用无头 Chrome 和 Firefox。 Puppeteer 相对较新，但它有一个很大的社区使用、开发工具和二次封装。 原生 (Native) 的所以快，并且使用了最新的 Chrome 引擎，不像 PhantomJS 构建在旧 WebKit 的分支上。（下一小节会讨论） 无头 Chrome 的（因此也是 Puppeteer 的）一个主要缺点是它不支持一些扩展，比如 Flash 扩展（并且近期也可能不会支持）。 PhantomJSPhantom 通过实现 Chromium 引擎创建了一个可控的类 Chrome 无头浏览器。不过自从谷歌宣布自家的 Puppeteer 后，Phantom 的创始人和维护者 Vitaliy Slobodin 便不再对其投入精力，因此从 2017 年中开始维护和开发速度就大幅下降，尽管还是有人在维护。 那么，为什么还要使用 Phantom 而非 Puppeteer？ 首先它有更多的特性和许多教程、工具。 它也被许多实用工具如后面会讨论的 CasperJS 使用。 它使用更早的 WebKit 因此可以模拟旧版 Chrome。 此外之前提过，Phantom 支持如 Flash 扩展，与无头 Chrome 相反。 NightmareNightmare 是一款测试语法特别简单的优秀 UI 测试库，使用与 Phantom 类似的 Electron 开发。Electron 基于更新版本的 Chromium，处在活跃维护与开发阶段，主要目标是使用 JavaScript、HTML 和 CSS 构建跨平台的桌面应用。 同样 Nightmare 也在讨论和实验使用无头 Chrome。以下是 Nightmare 和 Phantom 代码的比较： 123456// 译者注：Nightmare 代码yield Nightmare() .goto('http://yahoo.com') .type('input[title="Search"]', 'github nightmare') .click('.searchsubmit') 123456789101112131415161718192021222324252627// 译者注：Phantom 代码phantom.create(function (ph) &#123; ph.createPage(function (page) &#123; page.open('http://yahoo.com', function (status) &#123; page.evaluate( function () &#123; var el = document.querySelector('input[title="Search"]') el.value = 'github nightmare' &#125;, function (result) &#123; page.evaluate( function () &#123; var el = document.querySelector('.searchsubmit') var event = document.createEvent('MouseEvent') event.initEvent('click', true, false) el.dispatchEvent(event) &#125;, function (result) &#123; ph.exit() &#125; ) // page.evaluate &#125; ) // page.evaluate &#125;) // page.open &#125;) // ph.createPage&#125;) // phantom.create CasperCasper 基于 PhantomJS 和 SlimerJS （与 Phantom 相同只不过使用了 Firefox 的 Gecko）编写，抽象了在创建 Phantom 和 Slimer 时复杂的异步脚本，从而提供导航、脚本执行和测试工具。 Slimer 尽管被认为是试验性的产品但已被长期广泛使用，并在 2017 年底释出了 beta 版本——使用新版无头 Firefox 的 1.0.0-beta.1，目前正在为稳定后发布 1.0.0 版本而努力。 Casper 近期可能会从 PhantomJS 移植到 Puppeteer，预期 2.0 版本成为通吃无头 Chrome 和无头 Firefox 的工具，敬请期待吧。 CodeceptJS类似上面讨论过的 CucumberJS，CodeceptJS 通过不同的函数库 API 提供另一层抽象，哲学上期待你的测试更多关注用户行为。 它大概长这这样： 12345678910Scenario('login with generated password', async (I) =&gt; &#123; I.fillField('email', 'miles@davis.com'); I.click('Generate Password'); const password = await I.grabTextFrom('#password'); I.click('Login'); I.fillField('email', 'miles@davis.com'); I.fillField('password', password); I.click('Log in!'); I.see('Hello, Miles');&#125;); 以下是可以使用这段代码执行的函数库，在前文都讨论过： WebDriverIO, Protractor, Nightmare, Appium, Puppeteer. 如果你相信这种语法更适合你的需求，那就试试看吧。 总结我们看完了web 开发社区中最流行的测试策略和工具，希望你能更加轻松地测试你的站点。 最后，如今关于应用架构的最佳决策是在理解活跃开发社区提出的通用解决模式、与自身经验做结合且考虑应用的特性和特殊需求下做出的。 噢，然后编码，再重新编码，再重新编码，再重新编码后，测试不同的解决方案 :) 测试快乐 :) 谢谢 :) 推荐阅读最佳 Javascript tools for end-to-end testing web applications (July 2017) Top 5 Most Rated Node.js Frameworks for End-to-End Web Testing(March 2017) Top UI Test Automation Best Practices You Should Follow (November 2017) How to set up E2E browser testing for your GitHub project (With TestCafe) (February 2017) Introduction to Headless Browser Testing (September 2017) Web Scraping in 2017: Advanced Headless Chrome Tips &amp; Tricks (august 2017) How GitLab switched to Headless Chrome for testing (From Phantom)(December 2017) 概览 The Top 8 Essential JavaScript Automation Frameworks (June 2016) JavaScript Testing: Unit vs Functional vs Integration Tests (April 2016) What are Unit Testing, Integration Testing and Functional Testing? (April 2015) Top 12 Browser Compatibility Testing Tools (June 2017) Top 10 Cross Browser Compatibility Testing Tools In 2018 (2018) spies 和 stubs Bye-Bye, Sinon — Hello, testdouble (March 2016) JavaScript Testing Tool Showdown: Sinon.js vs testdouble.js (April 2017) testdouble.js vs. sinon.js (March 2016) enzyme vs unexpected-react (April 2017) 测试框架对比 React Testing — Jest or Mocha? (May 2017) Testing React Applications with Karma, Jest or Mocha (August 2016) Let’s Compare Javascript Testing Framework (August 2016) Jasmine vs. Mocha, Chai, and Sinon (Updated February 2016) Jasmine vs. Mocha- JavaScript Testing Framework Comparison(January 2017) Jest How to Snapshot Test Everything in Your Redux App With Jest(December 2016) Migrating to Jest on the P2P team at PayPal (November 2016) Jest- From 0 to 100% Coverage Real Quick (January 2017) The Hidden Power of Jest Matchers (January 2017) Testing React components with Jest and Enzyme (December 2016) Testing a React-Redux app using Jest and Enzyme (January 2017) Snapshot Testing React Components with Jest (January 2017) Testing an AngularJS app with Jest (October 2016) Ava Effortless unit testing with AVA (April 2016) Javascript Testing with AVA (February 2017) Unit testing front-end JavaScript with AVA and jsdom (November 2016) Testing the Bejeezus out of React Native Apps with AVA (June 2016) Tape Why I use Tape Instead of Mocha &amp; So Should You (July 2015) Learn Tape UI 测试 Hybrid Application Testing with Protractor and Appium (March 2017) Headless Chrome vs PhantomJS Benchmark (September 2017) Protractor vs WebdriverIO vs NightWatch (November 2016) End to End (e2e) Testing React Apps With Selenium WebDriver And Node.js is Easier Than You Think (April 2016) WebdriverIO- Using JavaScript to Drive Selenium Tests (August 2016) JavaScript Functional Testing with Nightwatch.js (August 2016) Node.js End-to-End Testing with Nightwatch.js (March 2017) Nightmare of End-to-End Testing (September 2016) Protractor vs WebdriverIO vs NightWatch (November 2016) Stack Overflow- What is the difference between nightwatch.js And webdriver.io? (March 2016) Comparison of JavaScript browser automation and test specification libraries (December 2015) What is PhantomJS and How is it Used? (June 2016) Setting up End-to-End Testing in Angular Project with CodeceptJS(December 2017) TestCafe Which automated testing tool to pick — Testcafe or Selenium WebDriver? (January 2016) Introducing TestCafe — Open Source Testing Framework (Octobeer 2016) Why not use Selenium? (October 2016) Functional Testing With TestCafe (March 2017) UI Test Automation Frameworks Showdown: TestCafé versus Nightwatch.js (Fabruary 2018) Cypress Cypress: The future of end-to-end testing for web applications (Fabruary 2018)]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>test</tag>
        <tag>unit test</tag>
        <tag>integration test</tag>
        <tag>ui test</tag>
        <tag>mocha</tag>
        <tag>jasmine</tag>
        <tag>jest</tag>
        <tag>cucumber</tag>
        <tag>chai</tag>
        <tag>unexpected</tag>
        <tag>karma</tag>
        <tag>ava</tag>
        <tag>sinon</tag>
        <tag>enzyme</tag>
        <tag>testdouble</tag>
        <tag>istanbul</tag>
        <tag>blanket</tag>
        <tag>protractor</tag>
        <tag>nightwatch</tag>
        <tag>phantom</tag>
        <tag>casper</tag>
        <tag>selenium</tag>
        <tag>appium</tag>
        <tag>webdriverio</tag>
        <tag>testcafe</tag>
        <tag>cypress</tag>
        <tag>puppeteer</tag>
        <tag>nightmare</tag>
        <tag>codeceptjs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书简记：《万历十五年》]]></title>
    <url>%2F2018%2F10%2F06%2Freading-notes-1587%2F</url>
    <content type="text"><![CDATA[很早之前就慕名买了《万历十五年》这本书，直到这个国庆假期才花了四天的时间一鼓作气读完。读得过程中便不自觉感慨一些片段写得非常精彩，全文读毕只能说这是我在 2018 年读过最精彩的一本书。 这本书的内容用一句话概述即讲述了中国从古至今的政治学问。虽然书中分析得是明朝万历皇帝执政时期的政治、经济、军事等情况，但身为读者，你丝毫不会觉得内容过时，反而有种今日不也是如此的既视感。可以说中华五千年的历史，有些本质并没有发生巨大的改变，有些文化也是周而复始。因此通过这本书，可以体会到什么是 “以铜为镜，可以正衣冠；以古为镜，可以知兴替”。 作为一本历史书籍，作者黄仁宇以纪录片旁白的口吻讲述明朝历史，非常生动，好比在听评书一般。剧情上由人及事，又因事提人，大量穿插，显得内容非常连贯紧凑而节奏适中。虽说书名是万历十五年这一具体年份，但实际全书覆盖了万历皇帝执政的整个时期，从登基直至作古，在此之中还介绍、分析了一些从明朝创始以来就有而到万历年间的情况。这是黄仁宇闻名于世的“大世界观”的分析手法，强调不要单纯去分析一时的问题，而是向前推演，从长久的时间维度解读社会症结。 书中一针见血地阐述了偌大一个帝国国家机构的运作机制，更为巧妙的是，能站在不同角色如皇帝万历、类似丞相的首辅张居正、将领黄继光、文学家李贽等人的立场来分析他们是如何在这样一个帝国中做出自己的人生选择，同时通过他们介绍明代的政治、经济、军事、哲学等方面文化。 在这几位中，如果说臣子们的人生选择多少都有些迫不得已，那么万历皇帝真的是令人佩服。既然有的事情反抗不了，作为活着的祖宗，就佛系僵持着一切吧，保守自己内心的一份坚持，而不是一直妥协。 造成明代灭亡最根本的问题，一言以蔽之就是太多事情用道德代替法律来处理。明代的管理者们号称为人民服务，追求精神上的奉献与仁德，却与物质需求发生极大的冲突。似乎有点眼熟不是吗？ 最后，虽然书中批判了封建时期中国的许多问题，不过黄仁宇也在附录中通过他人之言表达了对新中国的期盼之情。他特意提及《万历十五年》英文本《富序》中有下面一段： Historians may re-examine the mistakes of the past in the hope of providing warnings for the future, but at the same time caution their readers to preserve what is of value. Presumably, for China the experiences of both East and West must be drawn upon. It is essential that the historian lay everything on the table. 不要因为目前的堰塞，忽视中国伟大的地方。 这实在是史学家们难能可贵的精神。]]></content>
      <tags>
        <tag>history</tag>
        <tag>politics</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript 简洁之道：如何使用类重构]]></title>
    <url>%2F2018%2F08%2F06%2Fhow-you-can-refactor-to-use-classes%2F</url>
    <content type="text"><![CDATA[源文链接：JavaScript code cleanup: how you can refactor to use Classes原文链接：Javascript 简洁之道：如何使用类重构 在一些小规模的 React 工程中，将组件里所用的所有方法维护在组件内部没什么问题。不过到了中等规模的项目时，你可能会将那些方法从组件抽取到一个 “helper” 里。本文将展示如何使用类（而非导出独立的函数和变量）来组织代码。 注：我使用 React，因此这里讨论的例子也均是 React 所写。 典型的重构一次典型的重构中，我们通常会把组件中的函数维护在一个帮助文件里。 从： 12345678const MyComponent = () =&gt; &#123; const someFunction = () =&gt; 'Hey, I am text' return ( &lt;div&gt; &#123;someFunction()&#125; &lt;/div&gt; )&#125; 到： 12345678import &#123; someFunction &#125; from 'functionHelper.js'const MyComponent = () =&gt; &#123; return ( &lt;div&gt; &#123;someFunction()&#125; &lt;/div&gt; )&#125; 和 1export const someFunction = () =&gt; 'Hey, I am text' 这个例子很二，不过你可以从中看到重构的思路： 将你的函数复制粘贴到一个独立的文件； 导入它们并像之前一样调用。 当逻辑复杂起来，你将不得不传一些如控制状态的对象、函数到这些函数里。如今我就遇到一个问题：我有三个入参相同（一个 资源 和一个更新 资源 的函数）的函数希望从组件中提取出来。于是乎就酝酿出了更好的方法… 使用类重构我为本文做了一个隆重的演示，你可以在 GitHub 上查阅源码。初始的提交显示所有功能都写在主组件中（App.js），而随后的提交逐渐使用了类重构代码。 你可以尝试运行该工程，不过请记得 yarn install 安装依赖。 我们从一个”获取”对象（通常是请求一个 API 接口）的组件开始，它有一些确切的属性：repeat（盒子的个数），side（高和宽），text，color。接着我们有一系列操作视图的方法——改变色彩，更新文字，等等。每次视图更改后，我们展示一条信息。 举个例子，这是我们改变宽高的方法： 12345changeSide = side =&gt; &#123; const obj = &#123;...this.state.obj, side&#125;; this.fetchObject(obj); this.setState(&#123; message: `You changed the sides to $&#123;side&#125; pixels!` &#125;);&#125; 可能有些方法中也需要类似的操作，或许这些方法大不相同。这时候我们可能开始考虑将这段代码放到一个帮助文件里，然后创建另一个方法调用 setState ，同时需要将状态对象、side 参数以及 this.fetchObject 传入其中。如果类似的方法多了起来，那么就会存在大量的参数传递，从而导致代码重构起不到作用（或缺乏可读性）。 取而代之，我们可以使用类的构造函数方法来实现： 12345678910111213141516export default class ObjectManipulator &#123; constructor( &#123; object, fetchObject, markResettable, updateMessage, updateStateValue &#125; ) &#123; this.fetchObject = fetchObject; this.markResettable = markResettable; this.updateMessage = updateMessage; this.updateStateValue = updateStateValue; &#125; changeSide = ( object, side ) =&gt; &#123; const newObject = &#123; ...object, side &#125;; this.fetchObject(newObject); this.updateMessage(`You changed the sides to $&#123;side&#125; pixels!`); this.markResettable(); this.updateStateValue('side', side); &#125;;&#125;; 这允许我们创建一个能在主组件中调用其函数的对象： 1234567const manipulator = new ObjectManipulator(&#123; object, fetchObject: this.fetchObject, markResettable: this.markResettable, updateMessage: this.updateMessage, updateStateValue: this.updateStateValue,&#125;); 上述代码创建了一个对象 manipulator —— ObjectManipulator 类的实例。当我们调用 manipulator.changeSide(object, &#39;800&#39;) 时，将执行之前定义好的 changeSide 方法。这里无需传递 updateMessage 或任何其他方法——当实例创建时已经在构造函数中对这些方法赋好了值。 可以想象如果我们有许多类似的方法需要处理时这招将变得非常管用。就我而言，我需要在一个异步事件后调用 .then(res =&gt; myFunction(res)) 。相比于将 myFunction 传入每个函数的做法，在类实例中提前定义它节省了不少代码。 保持所有事情井井有条这种组织方法还可以促进代码互不越界。例如在前文的范例里，按钮的颜色维护在一个对应的数组之中，将此常量放到 ObjectManipulator 可以确保其不会与应用中的其他 colors 冲突： 12345export default class ObjectManipulator &#123; [...] colors = ['blue', 'red', 'orange', 'aquamarine', 'green', 'gray', 'magenta'];&#125;; 鉴于其他地方存在全局 colors 常量的可能性，我可以使用 manipulator.colors 正确地获取我想要的颜色。 引用Good old Mozilla Class docs Epilog❤️ Lazada 深圳团队招人，欢迎推荐 ❤️ 联系方式请用 Base64 解码：bHVja3lqb291QGdtYWlsLmNvbQ==]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>refactor</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简易计数器——年轻人的第一个Flutter应用]]></title>
    <url>%2F2018%2F07%2F25%2Ffirst-flutter-app-review%2F</url>
    <content type="text"><![CDATA[TL;DR站在负责 UI 层的 Web 前端视角看无线端框架，评判的第一个标准无非是文档够不够全、Demo 能不能很容易在手机上跑起来。近来的热门框架 Flutter 就上手而言给出了漂亮的答案。 Prolog 我是谁：曾是 Embedded C 开发的 Web 前端攻城狮，完全没有 dart 或是 flutter 开发经验 开发环境：MacBook Pro，XCode with iOS simulator 学习初心：2018 年的 Weex 开发体验依然不好，不如拥抱下一个技术红利（假笑.jpg 种草文：什么你还没听过 Flutter，简单介绍一下吧《Release Flutter的最后一公里》 最后一句话：以下”学习笔记”中，若有错误/模糊概念请友好指正，么么哒 IntroductionFlutter 最近真的是大热，可能笔者身处阿里的缘故，自从咸鱼在他们的商品详情页成功使用后，集团内无论是 ATA 技术论坛还是周报都能看到有人学习研究这门技术。 笔者一直都想尝试原生的无线端开发，在错过 React Native、受够 Weex 之后，身处这个时间点刚好趁热学习一下 Flutter，说不定这次真的跟过往的轮子不一样。 Setup照着官方文档来，一切还算顺利：装好 Flutter SDK，flutter doctor 把相关依赖都装好，插上 iPhone 手机，VS Code 新建一个 Flutter Demo 工程，调试… 在真机调试时，出现了第一个与苹果应用验证相关的问题： 12Failed to create provisioning profile.The app ID &quot;com.example.flutterFlutterDemo&quot; cannot be registered to your development team. Change your bundle identifier to a unique string to try again. 解决方法有两种： 使用自己的 Apple ID，详见这里；（好吧我也没试过） 使用模拟器。 命令行输入 open ios/Runner.xcworkspace 打开 Runner 工程，选择模拟器即可跑起来默认的 Demo 工程。 Code Review for Official CounterIntro官方默认的 Demo 工程是一个简易计数器。先看眼效果，真的非常简单，右下角点击加号，中间的数字对应增长，就酱~ 外行看热闹，内行看门道。应用层代码总共就六十多行，反正也不会 Dart，就边看边学习一下。 Import1import 'package:flutter/material.dart'; 首先是 Dart 依赖的导入。Dart 使用 pubspec.yaml 文件定义工程和依赖，类似 Node 世界里的 package.json；pub 则是对应 npm 的存在，pub get 一下即可安装相关的依赖包；安装完成后，会在项目根目录生成一个 .packages 文件，记录了所有依赖包在系统中对应的缓存地址，大概长这样： 12# Generated by pub on 2018-07-18 20:28:35.360131.analyzer:file:///Users/joou/workspace/flutter/.pub-cache/hosted/pub.dartlang.org/analyzer-0.31.2-alpha.2/lib/ 再来说说最上方的引用语句。除了引用相对路径的 dart 文件外，引用包需加上 package: 前缀，Dart 运行时会自动去查询包文件。那这里引用的 flutter/material.dart 在哪呢？笔者的第一反应是在 Flutter SDK 工程中，果不其然在此： 12345joou 2018-07-19 Thu 11:36:~/workspace/flutter/packages/flutter/lib(beta 50d8h)$ lsanalysis_options_user.yaml foundation.dart painting.dart scheduler.dart srcanimation.dart gestures.dart physics.dart semantics.dart widgets.dartcupertino.dart material.dart rendering.dart services.dart SDK 中已经内置了不少包，让我们看看 material.dart 这个物料包里有些啥： 1234567export 'src/material/about.dart';export 'src/material/animated_icons.dart';export 'src/material/app.dart';export 'src/material/app_bar.dart';export 'src/material/arc.dart';export 'src/material/back_button.dart';// ... 所以说 flutter/lib 下的包文件类似一个入口，类似 C 语言里的 header file，暴露给外界 flutter/lib/src 中的各种组件，想要深入了解某个包的具体实现去对应目录下即可找到真相。 当然，除了自己 xjb 探索外，也别忘了阅读官方文档，因为接下来的代码基本都要靠文档救命。 App Entry1void main() =&gt; runApp(new MyApp()); Dart 的每一个程序应用最顶层都要有一个 main() 函数作为入口，这和 C 语言是一致的。此外还有 void 类型，代表返回值可以是任意类型。Dart 是 OO 范式的语言，函数、方法都是对象，存在一个对应的类型，因此在定义函数时最好申明其返回值类型。=&gt; 语法是 { return expr; } 的简写，注意里面不允许出现 statement (Eg. if )。上述代码一样可改写为： 123void main() &#123; return runApp(new MyApp());&#125; runApp() 是 Flutter 提供的函数，其作用是将一个 Widget 类的实例（作为其入参）挂载（attach）到屏幕上，逻辑大概如下： 检查 WidgetsFlutterBinding 是否初始化； 将控件（widget）实例挂载到 renderViewElement 上，这个元素是渲染层级的根节点实例； 调用 scheduleWarmUpFrame() 方法，开始渲染。 Stateless Widget接下来让我们看看 MyApp 类。 123456789101112class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return new MaterialApp( title: 'Flutter Counter', theme: new ThemeData( primarySwatch: Colors.orange, ), home: new MyHomePage(title: 'Flutter Trivial Counter 🙃'), ); &#125;&#125; 此控件是应用的根节点。首先它作为子类继承了 StatelessWidget ，无状态是指它不需要可变状态，而是通过构建其他的控件来更具体地描述 UI，构建过程以递归方式执行，直到 UI 被完全具象化。可能这么说比较抽象，不过先别急，后面的代码会解释什么叫具象化。在 MyApp 中，重载了 build 方法，实例化了一个 MaterialApp 对象。 如果你写过 React 框架，那么我想换个方法解释可能更好理解。StatelessWidget 好比 React 中的 PureComponent ，而 Widget 类的 build 方法好比 React 中的 render。build 方法负责描述控件代表的 UI ，入参是构造的上下文，内容则是使用 MaterialApp 对象的实例描述 UI。实例化的过程中进行了一些配置，例如命名为 “Flutter Counter”，使用橙色主题，主页标题栏的文字设为 “Flutter Trivial Counter 🙃”。即便完全不知道 MaterialApp 类的内部实现，也很容易猜到它更具体地定义了一些 UI 内容。 React 是具备生命周期的，当 componentWillUpdate 钩子触发后将执行 render 方法，重新渲染组件。而 PureComponent 则是通过在渲染前（例如在 shouldComponentUpdate 钩子中）浅对比新旧 props 和 state 判断是否需要重新渲染，从而实现性能优化。同理，控件的 build 方法将会在其 lifetime 的以下时刻被调用： 调用 iniState 之后。 调用 didUpdateWidget 之后。 收到 setState 的请求后。 在 State 对象的依赖之一改变（例如被之前的 build 方法引用的某个 InheritedWidget 发生了改变）后。 调用 deactivate 后重新在挂件树的另一个位置注入 State 类。 而 StatelessWidget 中的 build 方法仅在三种情况中被调用： 控件第一次被插入挂件树中，也就是初始化时。 控件的父亲改变了自身配置。 控件依赖的继承控件类改变。 这和 React 是何等的相似（此处感慨 3 秒…）！因此减少无状态控件的重新构建也是一门优化技巧，在此不延伸了，有兴趣请看文档。至于 MaterialApp 类的内部配置在此也不深入，有机会再研究、分享一下这些官方组件。让我们看看配置中描述主页的 MyHomePage 挂件吧，这是在应用代码中实现的。 Stateful Widget123456class MyHomePage extends StatefulWidget &#123; MyHomePage(&#123;Key key, this.title&#125;) : super(key: key); final String title; @override _MyHomePageState createState() =&gt; new _MyHomePageState();&#125; MyHomePage 是一个有状态的挂件，最底部重载了 createState 方法定义其状态，用来描述 UI，这个稍后再细看。通常如果父类（superclass）没有默认的构造函数，dart 则要求子类在代码块的初始位置使用 : 指定父类的构造函数。而 Key key 用来申明可选参数（optional parameter），此处申明了 title 变量（field）。title 变量的值由父类赋予，被其 State 类的 build 方法使用渲染，像这种子类挂件的变量通常定义为 final 类型，意味着变量只能被赋值一次。与 const 不同的是 final 变量在程序运行时才赋值，而非编译时期就定义好的常量。 State让我们最后瞅瞅首页挂件的状态类。 12345678910111213141516171819202122232425262728293031323334353637class _MyHomePageState extends State&lt;MyHomePage&gt; &#123; int _counter = 0; void _incrementCounter() &#123; setState(() &#123; _counter++; &#125;); &#125; @override Widget build(BuildContext context) &#123; return new Scaffold( appBar: new AppBar( title: new Text(widget.title), ), body: new Center( child: new Column( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ new Text( '老铁没毛病，双击:', ), new Text( '$_counter', style: Theme.of(context).textTheme.display1, ), ], ), ), floatingActionButton: new FloatingActionButton( onPressed: _incrementCounter, tooltip: 'Increment', child: new Icon(Icons.add), ), ); &#125;&#125; 好吧这也是笔者第一次接触泛型，看过官方文档的例子后觉得还是比较好理解。MyHomePage 继承了拥有可变状态的 StatefulWidget 类，当其第一次被插入控件树中时，Flutter 框架会调用 createState 函数创建一个全新的 _MyHomePageState 实例与树中的位置相关联。当挂件的父组件重新构建（rebuild）时，父组件会重新创建一个 MyHomePage 实例，但是将复用已有的 _MyHomePageState 对象。 _MyHomePageState 定义了一个数字类型的 _counter ，另外自定义了一个 _incrementCounter 方法每次对 _counter 值加一。加一语句写在 setState 方法中，当被执行完后，会触发 Flutter 框架重新运行下方的 build 方法，以达到最终更新界面的目的。虽然推荐将状态变更的代码写在 setState 的回调函数中，但这么改写也是可以正常工作的… 1234void _incrementCounter() &#123; _counter++; setState(() &#123;&#125;);&#125; 最后的最后，在 _MyHomePageState 的 build 方法里，初始化并返回了一个 Scaffold 实例，源自 Material 组件。每当 setState 被触发后，就将执行一次 build 方法。不过 Flutter 框架号称优化过重跑 build 方法的性能，无需担心重新构建的成本。 Scaffold 类配置了三处地方： 新建一个 appBar 实例。这里通过 widget 属性获取到了 MyHomePage 挂件中的属性，此外还可以通过 didUpdateWidget 钩子在 widget 发生改变时进行操作。 body 属性被赋予了 Center 实例，无论是 Center 还是 Column 都是布局（layout）挂件。前者可以定位到父组件的中心位置，而后者将会水平排列其子组件。Column 挂件有多种属性控制样式，这里使用了 mainAxisAlignment 将其子组件垂直居中（别糊涂，列的主轴是垂直方向）。 屏幕右下角的按钮由 FloatingActionButton 描述，使用了加号图标，绑定之前定义好的 _incrementCounter 函数作为 onPressed 事件的处理者。 好了说了这么多组件，让我们使用 Flutter tool 的 Toggle Debug Paint 指令直观感受一把。 End笔者去年写了篇 Weex 从入门到放弃的上手文，说实话这次 Flutter 上手体验要比 Weex 好非常多——详实的文档，齐全的基础脚手架，轻松在手机/模拟器上运行应用。 对于没有客户端开发经验的笔者来说，能看着文档打通流程（实际编译出一个安装包并在对应平台上安装、执行）是一件非常关键的事情，它意味着小白也能使用这项技术栈独立开发简单的应用，能给学习者十足的信心。过去接触 Weex，只能使用 Playground App 扫码跑 demo，非常的“半成品”，而 Flutter 轻松几个指令，就在你的设备上跑起了你的工程，赞！ 至于 Flutter 相关的信息，如学习 Dart 语言、Flutter 入门教程、代码范例、官方库接口等资料已经颇为丰富，Stack Overflow 上也有一些讨论的话题，对于一个处于 Beta 阶段的框架来很成熟了。 接下来就期待国内外有更多关于 Flutter 的线上生产实践经验，笔者有空也会接着研究并分享 Flutter 的知识。 如果你看了这篇文章感到意犹未尽，那么再提供一点延伸阅读： Flutter’s Rendering Pipeline A Tour of the Flutter Widget Framework 相信你能从上述两个方向发现更多一手、可靠、丰富的信息！]]></content>
      <tags>
        <tag>flutter</tag>
        <tag>app</tag>
        <tag>dart</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 性能优化概观]]></title>
    <url>%2F2018%2F07%2F17%2Fjavascript-performance-optimization-tips-an-overview%2F</url>
    <content type="text"><![CDATA[作者：Ivan Čurić 原文链接：JavaScript Performance Optimization Tips: An Overview 我们将坚持“工具不代表规则（Tools, not rules）”的老话，尽量少提 JS 相关的流行术语。很显然我们不可能在一篇 2000 来字的文章里覆盖 JS 性能的方方面面，因此请在后续阅读本文的参考书目并自行研究。 不过在深入细节之前，先让我们通过回答以下问题来更广义地理解性能优化：高性能的 JS 要考虑哪些指标？这些指标如何与更高维度的 web 性能指标融为一体？ 准备工作首先，让我们避开如下事情：如果你只在台式机上测试，你已将 超过 50% 的用户排除在外了。 由于新兴市场偏爱使用低于 100 美金的安卓设备上网，该趋势只会持续增长。台式机作为主力上网设备的时代已经结束，未来十亿网民将会首选移动设备访问你的网站。 Chrome DevTool 工具的设备模拟器并不能有效替代真实设备进行测试。即便限制 CPU 和网络性能有所帮助，但它相比性能较弱的真实设备来说完全是另一个等级。所以请在真实设备上测试！ 即使是使用真实设备测试，你也很可能用的是自己新买的高端旗舰机。然而，这并非你的用户使用的设备。让我们看看配置处在中等水平的移动设备，例如摩托罗拉的 G1，只有不足 1GB 的运行内存、孱弱的 CPU 和 GPU。 当 解析一个文件体积为平均数的 JS 包（JS bundle）时，让我们看看它的解析速度排名。 Addy Osmani: Time spent in JS Parse &amp; eval for average JS. 虽然这张图只涵盖了 JS 解析和编译的时间（后续时间将会消耗更多）而非常规的性能数据，但有着强关联的它可以被视作 JS 性能的指标之一。 Bruce Lawson 曾说 “it’s the World-Wide Web, not the Wealthy Western Web”。因此你需要在比你的 MacBook 或 iPhone 慢 25 倍左右的设备上探讨 web 性能。让我们看看我们的实际目标是什么。 高性能的 JS 代码是怎样的？现在我们了解了我们的目标平台，就可以解答下一个问题：高性能的 JS 代码是什么？ 虽说没有绝对的分类来定义高性能代码，但我们有一个以用户为中心的性能模型可以参考：RAIL 模型。 Sam Saccone: Planning for Performance: PRPL 响应如果你的应用在 100 毫秒内响应用户的操作，给用户的感知就是立即响应。这适用于网页中可敲击的元素，但是滑动或拖拽时则不行。 动画在 60Hz 帧率的显示器上，我们期望在动画和滑动时画面恒定在 60 帧每秒，这意味着约 16 毫秒显示一帧。由于 16 毫秒的预算，你实际上只有 8 到 10 毫秒去完成所有工作，剩余时间将被浏览器内部以及其它一些差异消耗掉。（深度阅读：《从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理》） 闲置如果你正在运行一个昂贵且持久的任务，请确保将它切分为更小的部分以便主线程有空响应用户的输入。不应该有阻塞用户输入超过 50 毫秒的任务存在。 负载一个页面的加载应低于 1000 毫秒，超过这个时间你的用户将会变得烦躁。而在移动设备上要求页面变得可交互而不仅完成渲染和可滑动时，是一个非常难的目标。实际上，可用于加载的时间往往更少： Fast By Default: Modern Loading Best Practices (Chrome Dev Summit 2017) 在实践中，可交互时间以 5 秒为目标，这也是 Chrome 在其 Lighthouse audit 中使用的标志。 现在我们知道了度量指标，让我们来看一些数据统计： 如果一个移动站点的加载时间超过 3 秒，53% 的访客将会离开 每两个人中就有一个人期待页面加载时间不超过 2 秒 大约 77% 的移动站点在 3G 网络下的加载时间超过 10 秒 移动站点在 3G 网络下的平均加载时间为 19 秒 此外，Addy Osmani 还提供了一些信息： Apps 变得可交互在 PC 上需要 8 秒（使用网线），而在手机上需要 16 秒（3G 网络的 Moto G4） 从中位数看，页面依赖的 JS 文件（gzipped 压缩过）大小为 410KB 你是否感到十分泄气？很好，让我们一起行动，修复网页面临的这些问题。 上下文即一切你可能已经注意到，加载网页的时间是主要瓶颈。确切的说，瓶颈来源于 JavaScript 下载、解析、编译和执行的时间。这个问题没有捷径可走，唯有加载更少的 JS 脚本以及更加聪明地加载它们。 但是除了启动网站外，你的代码实际上做了哪些工作？这里肯定有些性能可以优化，对吧？ 在你开始优化你的代码前，先想想你要构建的是什么。你在构建一个框架或 VDOM 库吗？你的代码需要每秒执行上千次运算吗？你为了处理用户输入或动画而使用一个时间临界型（time-critical）的库吗？如果没有，你也许应该将时间和精力投入到一些更有用的地方。 不是说编写高性能的代码不重要，但是从事物的宏观角度来看其影响通常较小，尤其在讨论微优化时。因此，在你踏入 Stack Overflow 通过对比 JSperf.com 上的结果来争论 .map .forEach 和 for 循环方法前，先确保看到了整片森林而非细枝末节。50K 次每秒的操作听起来比 1k 次每秒的操作要好上 50 倍，然而在绝大多数场景下这两者不会有什么区别。 解析、编译以及执行基本上大多数性能不高的 JS 代码问题并未出现在运行时期，而是在代码开始执行前所需的所有步骤。 我们在这会讨论抽象的层次。电脑中的 CPU 执行的是机器码，而电脑中运行的绝大多数代码是编译过的二进制格式（这里使用“代码”而非“程序”考虑到了近来的 Electron 应用）。也就是说，二进制代码抛开了所有系统层面的抽象，可以在硬件上原生执行，不需要一些预先处理。 JavaScript 没有被预先编译过。它在浏览器中通过相对较慢的网络被下载为可读的代码，总而言之，浏览器就是 JS 程序的“操作系统”。 代码首先需要被解析——更确切地说读取并将其变成计算机可寻址的结构以便编译。在设备/浏览器可以执行前，代码还需被编译成字节码，最终是机器码。 另一件非常重要的事情是 JavaScript 是单线程的，运行在浏览器的主线程上。这意味着一次只有一颗处理器可以运行 JS 代码。如果 Chrome DevTools 的性能时间轴被黄色峰值填充，即 CPU 使用率达到 100%，画面将会出现长帧、掉帧、难用的滑动以及其他所有扎心的体验。 Paul Lewis: When everything’s important, nothing is!. 所以在你的 JS 代码开始运行前，上述所有工作需要完成。在 Chrome V8 引擎执行 JS 代码的总时间中，解析和编译占据了约 50% 的时间。 Addy Osmani: JavaScript Start-up Performance. 从这一部分我们学会两件事： 尽管未必是线性关系，但 JS 的解析时间与包的体积呈正比。加载的 JS 代码体积越小，速度越快。 每一个你使用的 JS 框架（React, Vue, Angular, Preact …）是另一个层次的抽象（除非是像 Svelte 这样的预编译库）。这些库不仅会增加 JS 包的体积，也会因为代码没有直接面对浏览器而降低效率。 有一些方法可以缓解这些问题，例如使用 service workers 另起线程在后台完成工作，或使用 asm.js 编写更容易被编译成机器指令的代码，但这完全是另一个话题了。 你可以做到，是无论如何在一切情况下避免使用 JS 动画库，并熟悉绘画和布局的触发事件。只有当完全没办法使用常见的 CSS 过渡和动画实现时再使用库吧。 即使这些库可能使用了 CSS 过渡、复合属性以及 requestAnimationFrame() 方法，它们依然作为 JS 代码在主线程中运行。为了保证动画的顺滑，你需要确保你的所有 JS 代码在每帧 8 毫秒的时间内完成执行。 另一方面，CSS 动画和过渡占用 GPU 而非主线程，如果高效实现，可以避免产生重新布局。 考虑到大多数动画是在等待或用户交互时执行，这可以给予应用一定的喘息时间。 Web Animations API 作为即将到来的特性集合允许用户脱离主线程开发高效 JS 动画，但现在还是坚持 CSS 过渡和 FLIP 之类的技术吧。 包的大小就是一切如今一切都是 JS 包。Bower 和 &lt;/body&gt; 标签前写一堆 &lt;script&gt; 的时代已经远去。 现在都是使用 npm install 来安装你在 NPM 上发现的新玩意，使用 Webpack 将它们打包为一个 1MB 体积的超大 JS 文件，当浏览器结束依赖包的数据请求后，这么大的文件会让浏览器缓慢运行。 试着少加载一些 JS 代码吧。你的项目也许不需要完整的 Lodash 库；你有必要非得使用一个 JS 框架吗？如果是，你考虑过使用体积是 React 1/20 的 Preact 或是 HyperHTML 吗？为了实现滑到顶部的动画你有必要使用 TweenMax 吗？伴随着 npm 的便捷与各框架组件的独立，缺点应运而生：开发者面对一个问题时的第一反应变成了用更多 JS 代码来解决。当你拥有一把锤子时，一切看起来都像钉子。 当你在删繁就简、加载更少的 JS 代码之后，试着更聪明地加载它：需要时再加载。 Webpack 3 有一组了不起的功能名为 code splitting 和 dynamic imports。相较将所有 JS 模块打包成一个庞大的 app.js 包，这组功能可以自动切分代码并使用 import() 语法异步加载它们。 你不一定需要使用框架、组件和客户端路由以获得其优点。假设你有一段复杂的代码处理 .mega-widget 类的节点，这段代码可能存在于任意页面上，你可以简单得在你的主 JS 文件中编写如下代码： 123if (document.querySelector('.mega-widget')) &#123; import('./mega-widget');&#125; 如果你的应用在当前页找到了部件，它将会动态加载所需的依赖代码。否则一切正常。 除此之外，Webpack 工作需要其自身的运行时，它将在其生成的所有 JS 文件中注入运行时代码。如果你使用了 commonChunks 插件，你可以使用如下方法将运行时抽取到一个独立的代码块中： 123new webpack.optimize.CommonsChunkPlugin(&#123; name: 'runtime',&#125;), 在这个例子中，会将所有代码块中的运行时剔除出来，写入 runtime.js 中。只需确保在主 JS 包之前先加载它，例如这样： 12&lt;script src="runtime.js"&gt;&lt;/script&gt;&lt;script src="main-bundle.js"&gt;&lt;/script&gt; 接下来谈谈 transpiled code 和 polyfills。如果你编写的是现代（ES6+） JS 代码，你很可能正在使用 Babel 将它们转译为 ES5 兼容的代码。转译（Transpiling）不仅因为各种冗余增加文件体积，也因其相比原生 ES6+ 代码更加复杂带来了性能退化问题。 你可能还顺道使用了 babel-polyfill 和 whatwg-fetch 库来补充旧版本浏览器中缺失的一些特性。然后，如果你在代码中使用了 async/await ，你还需要引用 regenerator-runtime 库来转译… 重点是，为了支持老版本的浏览器，你的 JS 包因此平添了近 100K，不仅体积较大，也会耗费更多的解析和执行成本。 没理由因为上述问题而降低使用现代浏览器的人的用户体验，这里介绍一个我正在使用、同时 Philip Walton 也在这篇文章中介绍的方法：创建两个独立的包并依情况加载。使用 babel-preset-env 可以很容易实现，例如你有一个支持 IE 11 的包和另一个为最新版现代浏览器准备的没有任何 polyfills 的包，一种不优雅但是高效的方式是将以下代码写入内联脚本中： 123456789(function() &#123; try &#123; new Function('async () =&gt; &#123;&#125;')(); &#125; catch (error) &#123; // create script tag pointing to legacy-bundle.js; return; &#125; // create script tag pointing to modern-bundle.js;;&#125;)(); 如果浏览器无法识别 async 函数，我们则判定它是一个旧版浏览器并加载已经 polyilled 的包，反之将加载一个简洁且现代化的变体。 总结我们想要你从本文得到的观点是 JS 是一门运行昂贵、应该被小心使用的语言。 请确保在真实网络环境下使用低端设备测试你的网站性能。你的网站应该尽可能快被加载且变得可交互。这意味着通过任何有必要的方法减少 JS 的代码体积、加快加载速度。只要有可能时，你的代码应该都是 minified 过的，被切成更小、可控的包，并被异步加载的。在服务器端，确保启用了 HTTP/2 协议以获得更快的并行传输速度，同时使用 gzip/Brotli 压缩更加彻底地减少 JS 包体积。]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>optimization</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书简记：《极限控制》]]></title>
    <url>%2F2018%2F06%2F11%2Freading-notes-extreme-ownership%2F</url>
    <content type="text"><![CDATA[《极限控制》这本书是从同事手里收来的，买得时候以为是讲战争故事，读得过程中才发现是本讲解领导力的书。中文翻译得一般，尤其是书名（原书名为 Extreme Ownership）起得让人摸不着头脑，有点烂名字毁了一本书的既视感。 虽然是误打误撞买得书，我却很乐意将它读完，因为工程师太需要学习一些管理技巧，但平时又不怎么有机会接触到这些东西。从正向看一是帮助管理自己，二是即使一直做技术也会逐渐开始带团队、成为 TL，如何带好一个团队、最大化其战斗力是一门学问；反向说来，从实习到工作发现有不少技术过人的工程师是非常厉害的 IC （Individual Contributor），但可能并非优秀的老板，是管理和沟通成为了他们的绊脚石。 书中通过每一个战争案例总结出一点或多点道理，在此摘抄几条我比较有感触的结论。 关于制定规划 123456789101112131415161718191. 任务分析 - 理解高层下达的任务、意图，以及分析任务的目标 - 自行考虑你所希望达成的目标2. 确认参与任务的人力、可利用的资源，确定合适的时间3. 分散规划权 - 允许主要相关之人制定相应的行动步骤4. 确定行动步骤 - 主要关注最重要的步骤5. 允许主要负责人为所选的步骤制订计划6. 为行动的每一步可能出现的意外情况做出计划7. 尽可能控制可控的风险8. 将主要的任务分派给主要的相关负责者 - 退后一步，成为指挥天才9. 就已经出现的情况对计划进行检验，提出质疑，确保这一计划仍然适用于当前的局面10. 简单明了地将这一计划通告所有参与行动的人及支援行动的人 - 强调“指挥官的意图” - 参与集团讨论，并提问11. 结束任务之后做“战后汇报” - 总结经验教训，并将它们用于以后的行动规划中 关于沟通 123- 无论向上级报备情况，还是向下级传达命令，你都应该采取负责任的态度- 若某人没有做你期望的事，首先检讨自己，看看怎样做才能达成所愿- 不要向上级询问应该怎么做，而是要告诉他们你准备做什么 关于“优秀的人”的对立统一 123456789- 自信而不自大- 勇敢而不莽撞- 关心细节却不会为之左右- 坚强且有耐力- 善于指挥也要乐于服从- 果敢而不专横- 平静而不沉默- 冷静而不呆板，有逻辑而不乏情趣- 跟伙伴打成一片，但不能太过亲近，让其他人取代了你，更不能让坏人取代了你]]></content>
      <tags>
        <tag>management</tag>
        <tag>leadership</tag>
        <tag>ownership</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[论一个倒计时器的性能优化之路]]></title>
    <url>%2F2018%2F05%2F25%2Foptimization-road-of-count-down-timer%2F</url>
    <content type="text"><![CDATA[引子回顾这半年，扛需求能力越来越强，业务代码也是越写越多。但稍一认真看看这些当时为了满足快速上线所码的东西，问题其实还是不少。这次就从一个简单的计时器说起。 现状问题很明显倒计时器组件在一个活动列表页面里被使用，列表中每一项都是一个促销活动入口。倒计时器位于每个活动区块的左上方，提醒用户该活动还有多久结束，如下动图所示（测试设备 SONY E5663，后同）。 当页面滑动时，可以明显看到计时器停止，这意味着页面并没有刷新。直到松手后一两秒才恢复计时，且不稳定，又卡顿了一到两秒。 如此明显的问题吓得笔者赶紧去后台查阅了该页面 PV 和 UV 数据，虽说不多，但还是有一批忠实用户每天访问，这可怎么对得起我们的衣食父母…！即便测试用的设备性能羸弱，更换 Chrome 模拟器以及 17 年的安卓旗舰机再次测试并未出现如此卡顿现象，但我们无法挑选客户使用的设备，只能从技术角度解决问题，尽量提升用户体验。BTW，这台 SONY 测试机就是由东南亚的业务方同学提供，应该是当地用户的常用机型之一。 打脸与自我打脸倒计时器组件的更新逻辑抽象如下，简单概括就是使用 setInterval 定时更新 React 组件的状态以实现倒数时间的更新： 1234567891011121314/* Original version */componentWillMount() &#123; if (!this.timer) &#123; this.timer = setInterval(() =&gt; &#123; const toUpdate = this.state.list.slice(); if (toUpdate.length) &#123; update.forEach(i =&gt; &#123; i.leftTime = Tools.getLastTime(i.endTime); &#125;); this.setState(&#123; list: toUpdate &#125;); &#125; &#125;, 1000); &#125;&#125; 不得不说，贴出这么一段槽点满满的代码是极其需要勇气的，这…居然是我写的？ 那么开始分（tu）析（cao）吧，让我们自上而下依次盘点： 这段逻辑代码放在 componentWillMount 生命周期钩子里执行并不合适，其因有二：在 componentWillMount 阶段还未加载真实的 DOM 节点，此时就开始更新数据没有什么意义；React 的 Reconciliation 算法以及目前最新的 Fiber 调度器算法会对渲染的开始或停止过程进行优化，例如合并几次渲染过程为一次，这可能会导致 componentWillMount 被频繁调用。 每次更新数据后都将触发一次渲染 SOP，这无疑加大了性能开销。当动画刷新遇上大量运算，一首《凉凉》送给低端手机。 这样计时方式真的准吗？例如 setInterval 的精准性，又例如 setState 方法的使用。 顺着这个思路，赶紧来改代码吧！ 提升更新效率更新速度有多慢？首先花几秒钟把这段代码挪到 componentDidMount() 钩子里。 接下来，既然页面在 MBP 的 Chrome 模拟器上访问没有问题，那么可以做个简单的对比实验，看看手机与笔记本模拟器的性能差距。使用 performance.now 测量更新一次所花费的时间，示例代码如下： 12345678910111213141516171819202122/* First version, profile the performance */componentDidMount() &#123; if (!this.timer) &#123; this.timer = setInterval(() =&gt; &#123; const startT = performance.now(); const toUpdate = this.state.list.slice(); if (toUpdate.length) &#123; toUpdate.forEach(i =&gt; &#123; i.leftTime = Tools.getLastTime(i.endTime); &#125;); this.setState(&#123; list: toUpdate &#125;, ()=&gt;&#123; const endT = performance.now(); console.log('Actually end:') console.log(endT - startT); &#125;); const seemsEndT = performance.now(); console.log('Seems end:'); console.log(seemsEndT - startT); &#125; &#125;, 1000); &#125;&#125; 从下方两张截图可以看到测试机与模拟器的性能相差十倍左右，且测试机的运算时间波动较大（下方上图为模拟器数据，下图为测试机数据）： 其实上面的埋点代码添加在 setState 的回调函数里，就明显能说明一个问题：setState 方法并不保证同步渲染更新，尽管截图中的时序看上去是同步的。 重点是，整个更新渲染的周期非常长，即使降低至 30Hz 的流畅画面要求，一帧可用的渲染时间也只有不到 34 毫秒，还不是业务代码独享！ 之所以渲染速度慢，是因为调用一次 setState 方法会依次执行 React 生命周期中的 4 个函数：shouldComponentUpdate、componentWillUpdate、render 和 componentDidUpdate （如下图所示）。 图片来源 直接撸 DOM，要啥 jQuery为了性能，这里采用最为简单粗暴的方法，直接更新 DOM 节点的 HTML 值： 123456789101112131415161718/* Second version, operate DOM directly instead of setState() */componentDidMount() &#123; if (!this.timer) &#123; this.timer = setInterval(() =&gt; &#123; const startT = performance.now(); const toUpdate = this.state.list.slice(); if (toUpdate.length) &#123; const nodes = document.querySelectorAll('.count-down-timer'); toUpdate.forEach(i =&gt; &#123; i.leftTime = Tools.getLastTime(i.endTime); nodes[index].innerHTML = item.registerLeftTime; &#125;); const endT = performance.now(); console.log(seemsEndT - startT); &#125; &#125;, 1000); &#125;&#125; 让我们来看看效果如何：模拟器上的更新时间缩短至 0.3 毫秒，比之前快了十几到二十几倍；测试机的数据也漂亮多了（如下图），再滑几下试试… 美滋滋！ 更好的更新策略定时器最重要的功能就是确保时间准确，如果时间都不准了，那也就该洗洗睡了。除去与服务端同步校时之类的方案，还是继续讨论如何在 Web 前端领域力求计时准确。 并不精准的 setInterval在修复前文提到的 setState 缺陷之后，最明显的问题莫过于 setInterval 的使用。写一个定时任务，不少小伙伴第一反应想到的也是 setTimeout 和 setInterval 函数，但是它们真的足够精确吗？这就要从 JS 的任务队列及微任务队列（也有称 macrotask queue 和 microtask queue）说起了… 咳咳，我们言简意赅总结下：JS 主线程执行时有一个栈存储运行时的函数相关变量，遇到函数时会先入栈执行完后再出栈（废话）。当遇到 setTimeout setInterval requestAnimationFrame 以及 I/O 操作时，这些函数会立刻返回一个值（如 setInterval 返回一个 intervalID ）保证主线程继续执行，而异步操作则由浏览器的其它线程维护。当异步操作完成时，浏览器会将其回调函数插入主线程的任务队列中，当主线程执行完当前栈的逻辑后，才会依次执行任务队列中的任务。 但是在每个任务之间，还有一个微任务队列的存在。在当前任务执行完后，将先执行微任务队列中的所有任务，例如 Promise process.nextTick 等操作。也就是说当 setInterval(fn, 1000) 等待 1 秒钟后，fn 函数会被插入任务队列中，但并不一定会立刻执行，还需要等待当前任务以及微任务队列中的所有任务执行完。长此以往，使用 setInterval 的计时器超时将越来越严重。 如果有毅力的朋友推荐看看权威的 HTML 标准文档，没耐心的就看看这个动图简单感受一下原理吧。 所以回归正题，不用 setInterval 那用啥？ 天王盖地虎，我有 rAF解铃还须系铃人，既然我们的代码执行时间在主线程中无法得到保证，那么还是要从更高抽象层级的浏览器中寻求办法。好在目前主流浏览器都已提供一个在重绘前执行动画相关函数的接口 requestAnimationFrame，用来更新计时器再合适不过。改造如下： 1234567891011121314151617181920212223/* Third version, use rAF instead of setInterval */componentDidMount() &#123; let lastTime = null; function __updateCountDownTimer(timestamp) &#123; lastTime = lastTime || timestamp; const tickInterval = timestamp - lastTime; if (tickInterval &gt;= 1000) &#123; const toUpdate = this.state.list.slice(); if (toUpdate.length) &#123; const nodes = document.querySelectorAll('.count-down-timer'); toUpdate.forEach((item, index) =&gt; &#123; item.leftTime = Tools.getLastTime(item.endTime); nodes[index].innerHTML = item.leftTime; &#125; &#125; lastTime = timestamp; &#125; requestAnimationFrame(_updateCountDownTimer.bind(this)); &#125; if (!this.timer) &#123; this.timer = requestAnimationFrame(__updateCountDownTimer.bind(this)); &#125;&#125; 那么这样实现足够精准了吗？打印出每次更新的时间戳瞅瞅（下方上图为模拟器数据，下图为测试机数据）。 可以看到模拟器上已经相当精准，每秒的误差在 +0.15 毫秒左右，也就是运行将近 2 小时会有 1 秒的误差，笔者觉得完全可以接受。不过测试机上的误差就有点大了，每秒的误差在 +10 毫秒左右，虽然笔者觉得也可以接受（很少有人会在活动页停留很久），但本着工（tai）匠（gang）精神，想想是否还能优化呢？ 正向反馈拯救采样频率好奇心使笔者打印出了测试机调用 rAF 的时间间隔，绝大多数间隔在 16.6 毫秒左右，意味着手机 webview 也是 60Hz 的刷新频率；不过也存在少数间隔时间远超正常刷新时间，达到了 30 ~ 70 毫秒，如果触发滑动操作可能会超过 100 毫秒。不得不说，测试机就要挑这么烂的 Orz… 仔细想想，测试机上的计时误差本质是采样频率并未一直满足 60Hz，当某一次采样时间超过 16.6 毫秒且刚好需要刷新动画时，就会产生误差。同时每次误差都是超时而非提前，这样就在延时的道路上越走越远了。 那么反向思考，每当触发更新事件时，超时时段（超过 1 秒的时间）是已知的。如果将其补偿到下一次计时中，应该能减缓误差的扩大速度。代码如下： 123456789101112131415161718192021222324/* Fourth version, use rAF instead of setInterval */componentDidMount() &#123; let lastTime = null; const DELAY_INTERVAL = 1000; function __updateCountDownTimer(timestamp) &#123; lastTime = lastTime || timestamp; const tickInterval = timestamp - lastTime; if (tickInterval &gt;= DELAY_INTERVAL) &#123; const toUpdate = this.state.list.slice(); if (toUpdate.length) &#123; const nodes = document.querySelectorAll('.count-down-timer'); toUpdate.forEach((item, index) =&gt; &#123; item.leftTime = Tools.getLastTime(item.endTime); nodes[index].innerHTML = item.leftTime; &#125; &#125; lastTime = timestamp + (tickInterval - DELAY_INTERVAL); &#125; requestAnimationFrame(_updateCountDownTimer.bind(this)); &#125; if (!this.timer) &#123; this.timer = requestAnimationFrame(__updateCountDownTimer.bind(this)); &#125;&#125; 观察测试手机打印的时间，发现此法完全是可行的。每当超时间隔超过正常的刷新频率 16.6 毫秒时，相当于赶上了下一次采样窗口的伊始，因此会被校正。相比手机上每隔两三秒校正一次，PC 模拟器的采样时间变化显得尤为明显，在最后与大家分享。 11685.99, 2686.13, 3686.27, 4686.410000000001, 5719.888, 6686.69, 7686.83, 8686.970000000001, 9687.11, 10687.443, 11687.583, 12687.723, 13687.863, 14688.003, 15688.143, 16688.283, 17688.423, 18688.563, 19688.703, 20688.842999999997, 21689.214, 22689.354000000003, 23689.494, 24689.634000000002, 25689.774, 26689.914, 27690.054, 28690.194000000003, 29690.334, 30690.474, 31690.863, 32691.003, 33691.143, 34691.282999999996, 35691.423, 36691.563, 37691.702999999994, 38691.843, 39691.983, 40692.123, 41692.473, 42692.613000000005, 43692.753000000004, 44692.893, 45693.033, 46693.173, 47693.313, 48693.453, 49693.593, 50693.733, 51694.159, 52694.299, 53694.439000000006, 54694.579, 55694.719, 56694.859000000004, 57694.999, 58695.138999999996, 59695.279, 60695.419, 61712.443, 62695.914000000004, 63696.054, 64696.194, 65696.33399999999, 66696.474, 67696.614, 68696.754, 69696.894, 70697.034, 71697.423, 72697.56300000001, 73697.70300000001, 74697.84300000001, 75697.983, 76698.12299999999, 77698.26299999999, 78698.403, 79698.543, 80698.683, 81699.02399999999, 82699.16399999999, 83699.304, 84699.444, 85699.584, 86699.724, 87699.864, 88700.004, 89700.144, 90700.284, 91700.424, 92700.781, 93700.92099999999, 94701.061, 95701.201, 96701.341, 97701.481, 98701.621, 99701.761, 100701.90100000001, 101702.041, 102702.426, 103685.897, 104686.037, ... Reference Tasks, microtasks, queues and schedules How does a single thread handle asynchronous code in JavaScript? HTML Living Standard — Last Updated 25 May 2018 window.requestAnimationFrame()]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>react</tag>
        <tag>optimization</tag>
        <tag>counter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[那些年我拿到阿里巴巴Offer所参加的面试]]></title>
    <url>%2F2018%2F01%2F13%2Finterviews-for-the-offer-of-alibaba%2F</url>
    <content type="text"><![CDATA[2017 年尾第一次经历了转岗，离开了 YunOS/AliOS 事业部，虽然新部门还是在阿里，但这种感觉其实就是换了份工作。想当初加入阿里踌躇满志，期待在 OS 领域大干一场，然而时隔一年多，我已转型为风马牛不相及的 Web 前端开发，曾经的 OS 梦随着前事业部的战略失败也逐渐凋零。2018 年的第一篇博客，就来纪念一下这段狗血历程的开端吧。 回想研究生时期的我还在嵌入式领域里游荡，尽管会写一点网页和脚本，也懂点机器学习的皮毛，但我一直认为我会去一家电子公司，比如传统的半导体厂商 Intel, NXP，最不济也是 MTK （笑）。老牌名校的明星院系，实习、神人导师的各种摔打，以及自身对嵌入式的热爱，想不出有什么理由会使我去互联网公司。 然而，命运有时候就是这么神奇。 2015 年初夏，机缘巧合认识的学弟妹在团队缺人的情况下，拖我去台北参加了阿里百川举办的黑客松比赛，随后结识了若远师兄。在 16 年春天开始找工作时，我咨询了若远：1. 阿里有没有搞系统底层的职位？2. BAT 的官网都只招实习生了，阿里还有校招吗？在得到肯定答复后，自然而然获得了他的内推帮助。 简历通过评估后，无需笔试，即将开始漫长的面试之旅。我总共经历了 7 场面试，之所以会有这么多场的原因，总结有三： 16 年互联网寒冬已经到来，BAT 在三月春招时只招实习生，而我在前三轮面的不错的情况下想“强行上位”，需要多多考察（某位面试官原话）； 其中一场面试面砸了，听到有正式 offer 机会的当下心态失衡； 当时人在台南，边写论文边面试，时间紧任务重，拒绝了回杭州终面，所以还是需要多多考察，毕竟学校名字听起来太野鸡？ 讲完八卦，是时候上干货了 = =+。以下是 7 次面试的重点记录： 一面 电话 根据线上简历（主要是简历上的开放式问题）进行提问 二面 电话 + 笔试 strcpy() 越界 链表节点的插入 size of array pointer 三面 电话，内容广度爆炸… Orz ld.so，VIVT / VIPT / PIPT，cache flush / clean 加解密算法 TLB 作用 宏内核 vs 微内核 IRQ vs FIQ ARMv7-M vs ARMv7-A ARMv8-M，Trustzone MPU 用途，和 MMU 区别 动态链接函数库，那些数据共享，哪些数据独有 Run-time 时期 Bss Section 数据的行为 四面 电话 + 笔试，搞砸的那次 指针的数组，数组的指针，sizeof() ？ 同二面第一题，刨根问底是什么情况 写出 linux kernel 双向链表的删除操作，但问的时候未说明是双向链表… 五面 电话 首先，解释四面表现为何如此之差（心塞…） 一个智能灯系统，有 WiFi，如何做到低功耗 Hypervisor 原理，若上面同时跑两个 RTOS，整个架构是怎么样的 六面 电话 详细自我介绍，项目经验 mutex vs spin lock 有序数列查找元素效率最高的算法？时间复杂度？ RB Tree VS AVL Tree 过往的笔试题 TCP 四次挥手过程，端口号什么时候结束使用的 七面 电话，HR 终面 来实习的话可能面临的挑战？ 来实习的工作内容？ 自己最大的优势是什么？ 整个面试的过程还是不错的，面试官都很专业，上来直接询问技术相关的问题，并且会有意识的引导，态度也都比较和善，是我个人认可的面试方式。面试完后，阿里校招系统上的信息更新也非常及时，不得不夸一下这个招聘系统很专业，大大提升了面试者对这家公司的信心与好感度。当时唯一觉得不爽的就是不知道面试电话什么时候会来，除了一位面试官提前电邮与我预约时间外，其他面试都是时间未知，我只好抱着海外漫游的电信手机一直等，度过了难熬的一个多月时光。 现在站在上帝视角，再看看当初的想法，也是有许多感慨。我以为四面后就彻底结束了，没想到还有第五面；我以为这么多次面试是一个连续的过程，其实在第四面之后我已经被淘汰回了简历池；我以为我拿的是校招 offer，其实最终花费了团队一个社招 offer；我以为我来了做的是面试里聊得 ARM trustzone 等安全领域的活，没想到入职后就拥抱变化做了 Web 前端开发。 面对难以预知的未来，唯一能做的就是把握现在，不断地努力。如果没有在研究生时期疯狂饿补计算机体系知识，面试时期常常刷面经、leetcode 到三四点，我一定过不了面试。如果没有放平心态学习 Web 以及前端相关的新技术、思考技术需求与方向，我不会在想转岗时，谈一个 offer 拿一个 offer，不愁没下家。如果没有危机感和对技术的执着，我不会从一个石油专业院校走到一家知名的互联网公司，想想从光电跨越到电子再到计算机领域的“艰辛”，其实也没什么，毕竟整个过程是非常充实且富有成就感的。 最后，面试这一路走来也真的是非常幸运，结识了一些师长和同事并得到他们的帮助。例如带我进入计算机领域的前联发科技技术顾问、后来做我硕论导师的开源大神 Jserv；实习时只要有空便与我分享技术心得、劝我对自身技术发展不要设限的 Richard 大哥；给了我加入阿里机会并让我仰望的峰哥和超级 nice 的 HR 姐姐珈夜；以及内推我进阿里、在转岗时给我许多建议、现在成为一个部门同事的高富帅若远。感恩！ Learn from yesterday, live for today, hope for tomorrow. Let’s cheer up!]]></content>
      <tags>
        <tag>interview</tag>
        <tag>alibaba</tag>
        <tag>os</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[十分钟带你了解国产自制开源插件 structure-view]]></title>
    <url>%2F2017%2F11%2F21%2Fintroduction-of-structure-view%2F</url>
    <content type="text"><![CDATA[structure-view （以下简称 SV）是在开发 YunOS Studio（AliOS Studio 前身）时开源出来的一款代码结构提示插件。代码结构提示是一项由来已久的影响开发效率的功能，早在 VIM 时期就有经典的 ctags + Taglist 插件组合来实现这一功能，在桌面时代各大流行的 IDE 也都支持此功能，如 Eclipse 中的 Outline View 或 Webstorm 中的 Structure View。 YunOS Studio 基于扩展能力优异的 Atom 编辑器开发，由于 Atom 的生态市场缺乏一款好用的代码结构提示插件，因此 SV 应运而生（注：目前主流相关插件的比较可参考附件 PPT 中的 “开发由来与现状” 章节）。 自从今年九月初将其开源并发布到 Atom 市场中，2个多月的时间达到了 800 余次的下载量，总计 20+ 的 star 数量，以及数十个 issues 和 PR。在没（精）啥（力）宣（有）传（限）的情况下，有人下载使用、提问题、提需求，甚至主动贡献 PR，都给了笔者极大的鼓舞，因此在此分享一下这个插件的设计，也欢迎 Atom 党服用此插件。 链接： Atom 市场 Github 平（臭）心（不）而（要）论（脸），eating my own dog food 这么久，我觉得挺好用的 =。= 需求与难点结合业务背景与现状谈需求SV 最初是为 YunOS Studio 设计，其用户——YunOS 开发者主要使用 Web 相关语言开发，因此对 HTML, CSS, Javascript 的支持是第一要务 。 其次，SV 应该具备目前主流类似插件的功能，总不能被“活化石” ctags + Taglist 给 K.O. 了。因此有些基本功能一定要满足： 解析出代码的基本类型，如 HTML 的 Element，CSS 的 Selector，JS 的 Function, Class 等 将上述类型展现在界面上，通常是树状图的形式 点击树状图上的节点，编辑区域可快速定位到其对应的代码位置 然后，扩展性是非常重要的一点。资源有限，不可能一口气支持所有语言，先把第一要务干完了，才能展望别的语言。秉着不能挖坑让自己跳的指导思想，一定要在初始阶段设计好扩展性。 最后，能开源当然是最好的，一个人支持那么多语言是会累死的，能忽悠热心网友来干点活多好呀。这也从侧门对扩展性提出了要求。 最后的最后，快速落地。在项目调研阶段笔者就发现，Atom 上不仅缺少好用的代码结构提示插件，即使是使用量最多的一个，作者也疑似不维护、消失很久了，项目相关的 issues 中已有一些对此类插件的明确需求。如果能快速落地，也就有机会获得一些外部开发者用户。 难吗？难 你永远不知道下一份读取的代码是用什么语言写的 Orz 从以下几个维度分析下难在哪： 广度：用户使用的语言无法预测，至少要覆盖主流语言吧，不然怎么好意思拿得出手 深度：对我们业务所用的语言，一定要能全面地解析；对于主流语言，至少也得解析出个轮廓 轻量：Atom 性能本来就不算好（当然人家也不主打性能…），所以插件一定要轻，切莫“喧宾夺主” 广度和深度本来就很难同时满足，还要保证轻量，tradeoff 的哲学该如何落实 设计与实现目前主流的解决方案当初调研时发现， Atom 市场中的竞品多是封装经典的 ctags 插件，其工作原理如下： 提前内置 Windows/macOS /Linux 三个平台的二进制执行文件，以及其需要的配置文件 .ctags 当插件工作时，命令行调用 ctags 解析，获取 stdout 输出的数据 将 ctags 输出的数据进行加工，以 web 页面的形式呈现在 Atom 的视图中 由于 .ctags 是正则匹配脚本，也就是说 ctags 其实是利用正则匹配方法处理代码。这种方法的好处是添加规则方便，规则越全面解析效果理论上越好。但是问题也显而易见，光靠正则匹配很难对 OOP 语言中的继承关系进行解析，更别提 JavaScript 这种靠原型链吃饭的语言了。 另外还有一种解决方案源自 Facebook 出品的 Nuclide IDE，SV 在设计之初并未参考到，不过后来发现是类似的思路 。Nuclide 中的 Outline 视图提供了代码结构提示和快速导航的功能，针对不同的语言使用不同的解析器，例如使用了自家的 Flow 类型检查工具处理 JavaScript 代码，而使用了 Python 官方的解析器处理 Python 代码。 这种方法的好处自然是有深度，能把支持的语言解析到位，但坏处也十分明显。首先是依赖性太强，之所以没有很深入地调研 Nuclide，是因为笔者在解析 JavaScript 时提醒安装 Flow，但是 Nuclide 并没有提供自动化安装功能，需要用户到 Flow 的官网学习、完成这件事情，这显然很蠢，也不知道现在改进没…其次就是支持的语言类型有所限制，需要大量的资源支持新的语言开发，明显不适合笔者这种“单兵作战”模式。 流程设计SV 的代码结构解析流程与现有插件大体一致，如下图所示。 一次完整的解析显示流程可分解为以下几步： 获取当前代码文件的绝对路径 调用文件系统接口读取代码内容 选择合适的语法分析器解析代码，获取 tags 数据 Tag parser 将 tags 处理为前端可用的格式，例如给每个 tag 添加 Point 字段用于 Atom 编辑器的定位 渲染树状图 第三步中提到“选择合适的语法分析器”意味着 SV 中不止一个语法分析器，这是 SV 的一大特色，下一小节中会详细说明。 架构设计与实现SV 的设计思想其实与 Nuclide 相似，也集成了多个语法解析器，但主要有两点不同： 基于给用户更好的使用体验以及满足轻量需求的出发点，SV 的解析引擎以 JavaScript 三方库为主，在安装插件时一并安装，无需用户后续手动操作 SV 中设计了一个通用的语法解析器，定位为“万金油”角色，以满足支持语言的广度 具体的架构图如下所示。 Tag Generator在 Tag Generator 层封装了各种语言对应的专业语法解析器，SV 判断出代码文件的语言类型，便会选择对应的语法解析器。如果没有某一个语言对应的解析器，则代表目前 SV 还未深度支持，此时就会使用一个名为 Universal 的解析器进行处理。 Universal 顾名思义就是通用的解决方案，虽不像专业的语法解析器那样能解析得很全面，但是它可以尽可能多地覆盖各种语言，以确保遇到未深度支持的语言时也能得到代码的初略结构信息。秉持着 DRY (Don’t repeat yourself) 原则，SV 借鉴了现有插件，通过配置、使用 ctags 插件来实现这个“万金油”角色。 由于语法解析器使用了不同的第三方库，获取的原始 tag 数据形式也是各有不同。因此在封装第三方库的过程中，这些语法解析器会遵循统一的数据格式，整理出 name kind position parent id child 等字段。 此外，Tag Generator 也统一了语法解析器的 API（目前仅有一个），为扩展性提供了保证。未来支持新的语言时，只需在相应目录添加解析器文件，SV 会自动搜索并调用统一的接口。 Tag ParserTag Parser 的作用很简单，就是为 View Controller 提供整理好的树结构资料，方便后者直接渲染。 由于 Tag Generator 封装了不同的三方库进行 tags 解析，返回的数据结构主要有两种，一是哈希列表，另一种是 AST。这两种格式各有优点，前者在定位 tag 时方便找到对应的节点，无需遍历整颗树；后者作为一颗树，在渲染树状图时水到渠成。 因此 SV 同时维护了这两种结构的数据，如果语法解析器提供的是哈希列表，Tag Parser 就通过该列表生成相应的 AST，反之亦然。 View Controller这一层使用了开源的 MVVM UI 框架 Vue 实现渲染逻辑和交互逻辑，在此就不赘述。 展望语言类型的支持是一项任重而道远的工作，限于人力资源，只能从业务需求和笔者常用的语言出发进行支持。但是个人力量终归是有限的，因此在设计 SV 之初，笔者就考虑到了开源社区，为 SV 编写了详细的英文文档。SV 的用户多是软件开发者，如果能获得他们的认可，提供简单的扩展方法，想必他们中也是有热心人士愿意贡献 PR 的。事实证明，SV 得到了一些 Atom 用户的关注和认同，也有开发者为了自己习惯的语言补充了 .ctags 配置文件，甚至编写语法解析器。 目前语法解析器主要使用 JavaScript 编写的第三方解析库，这将会受到一定的限制。例如 C/C++ 语言的 AST 解析器有 C/Python/Ruby 语言版本，但未必有 JavaScript 版本，即使有也可能存在健壮性方面的担忧，提供一个通用的办法解决这个问题也极具意义。 从产品角度看，SV 目前非常粗糙，需要好好打磨。功能上仅支持基本的解析、展示、定位，与主流 IDE 的类似插件相比有一定的差距，需要多向如 WebStorm 之类的优质 IDE 学习。 最后，SV 的架构设计考虑到了移植性。近年来 VS Code 的横空出世，以其高性能以及对 TypeScript 的优异支持，吸引了一部分 Atom 用户转投阵营。VS Code 同样允许第三方开发者发布插件，目前其市场中的竞品插件功能性较弱、使用人数较低，有机会做得更好。SV 独立出了 View Controller 层，未来如果被移植到其他热门编辑器如 VS Code 时，重写这一层即可。当然，这需要 VS Code 提供更多关于 UI 方面的接口。 总结 为 ATOM 设计、（目前）专注 Web 前端开发的代码结构提示工具 灵活的代码标签生成器架构保证了工具的可扩展性 吸取市面上主流IDE工具的功能特性，力求好用易用 独立设计、开发，无 IP 依赖，利于推广和开源 附件：structure-view-intro-cn-v1.0.pdf]]></content>
      <tags>
        <tag>structure-view</tag>
        <tag>outline</tag>
        <tag>ctags</tag>
        <tag>open source</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务器端渲染姿势探索]]></title>
    <url>%2F2017%2F11%2F13%2Fserver-side-rendering-review%2F</url>
    <content type="text"><![CDATA[服务器端渲染（Server-Side Rendering，以下简称 SSR）并非是一门新技术，早期就有 Java, PHP 等后端语言进行页面渲染，后来 JavaScript 兴起、 Jquery, Backbone, React, Vue 等视图框架流行，前端逐渐夺回了渲染的地盘。随着如 Express, Koa 等 Node Web 应用程序框架的出现，SSR 以同构渲染（isomorphic rendering）的方式再次强势归来。 由于 SSR 在初次请求页面时已经包含了页面所需的数据内容（甚至是 CSS 和 JS 脚本），因此带来了两点好处： 首屏性能：省去异步请求数据的时间 SEO 优势：防止 SEO 爬虫因缺少异步请求而错失的关键内容 当然在同构渲染模式下，前后端都由前端工程师进行开发，这无形中也是一个很大的优势。 下面笔者将结合自己参与过的几个应用，分享在 SSR 方面的一点探索心得。 从0到1：不求甚解，先摆个姿势再说笔者之所以会用到 SSR，现在回想起来也有点偶然：那个时候笔者的前主管经过一番调研，发现淘系的前后端分离框架 Midway 不错，于是基于它开发了一个轻量级的 Web 应用。 Midway 内置了一款名为 XTemplate 的模板引擎（类似 Nunjucks 的轮子），那时候身为前端小白的笔者看了这玩意，心想不就是一个 HTML 的超集么，虽然是方便那么一丢丢，但是为什么会有这类模板引擎，没想明白。 在没有吃透这项技术的情况下，笔者和师兄写出了 Xtpl 和 Vue “水乳交融” 的代码，而整个页面渲染逻辑如下： 由于业务长期对页面性能方面缺乏需求，大家都觉得这套方案没啥问题，即使偶尔在登入、刷新时会出现一些排列整齐的「{{}}」符号一闪而过，也只被解释成这就是稍微有点慢。 意识到这个姿势有问题时笔者已经换了一个团队，完全没有前端工程基础，打造一套服务于当前业务的高效前端开发体系是首要目标。在回顾之前使用的技术栈时，针对 SSR 笔者一下子就想到了两个问题（OS：“你个傻X当初想什么去了…”）： 既然客户端要异步请求表格数据，为何一开始不直接存在 DOM 中发过去？ 需要 Vue 渲染的内容，能不能用模板引擎（如 XTemplate）渲染？如果能为什么要留到客户端渲染？ 第一个问题讨论的就是 SSR 的主要价值之一，在文章开头已经介绍过；而第二个问题后面还会有详细讨论。总而言之，之前的那种设计思路，完全废掉了这项技术，相比单纯的客户端渲染还浪费了服务器上模板引擎解析的时间，尽管理论上这个性能损耗极小。 姿势小结使用 SSR 的原则应当是尽量把页面所需的数据都渲染或存在页面中，能节省一次或多次 HTTP 请求时间；需要大量数据的图表是个例外，但这种情况更合适的做法应该是首次粗粒度显示、后续再通过异步请求灵活调整。另外能在服务器端渲染的内容尽量使用模板引擎渲染，后续客户端的工作再交由 Vue 等框架来做。 至于收益嘛，就看异步请求的数量和当下的网速了。 同构还是不同构，这是个问题！书接上文，有一个问题是 Xtpl 能否替代 Vue 渲染一些内容，其实这个问题反过来问才更合适：React, Vue 官方都已支持 SSR，甚至出现了 Next.js 和 Nuxt.js 这样的定制 Web 框架，是否还需要使用 Xtpl 之类的模板工具？ 既然做技术选型，优缺点的对比必不可少。 先说 React, Vue 这样的同构渲染，最大的好处就是一套 JS 代码在服务端和客户端是共用的。以 React 为例，使用 renderToString 或 renderToStaticMarkup 将客户端的组件转化为字符串供服务端使用，具体的实现可以参考 引用2。同构的好处反过来也就是使用模板渲染的坏处，在 UI 框架必备的前提下，多学习、使用、调试一门语言，成本肯定会增加。 但是使用模板的好处也是存在的，首先是性能上的优势。 笔者使用 Rax 提供的跑分方法对主流渲染框架/引擎进行了性能测试，具体结果如下。测试结果以每秒钟执行测试代码的次数（Ops/sec）显示，这个数值越大渲染性能越好。可以看到 Xtpl 的性能远超 React, Vue 等框架，这是因为 React 等框架在渲染时需要构造 vDOM 然后才能输出 HTML，而 Xtpl 这样的模板引擎只需要在模板上做简单的“翻译”命令即可。 12345678React#renderToString x 540 ops/sec ±2.43% (78 runs sampled)Rax#renderToString x 878 ops/sec ±5.38% (74 runs sampled)Inferno#renderToString x 1,111 ops/sec ±6.35% (70 runs sampled)Preact#renderToString x 557 ops/sec ±6.72% (67 runs sampled)Vue#renderToString x 233 ops/sec ±36.37% (68 runs sampled)Marko#renderToString x 4,580 ops/sec ±5.25% (73 runs sampled)Xtpl#renderFile x 4,606 ops/sec ±7.13% (53 runs sampled)Fastest is Marko#renderToString,Xtpl#renderFile 除此之外，Xtpl 的优势就是在开发 Memory Analysor 等应用时积累的业务代码和经验了，没有学习成本，当业务压力大时，先顶一阵子也没什么问题；） 注：现在无论是 React 还是 Vue 都对 SSR 进行了优化，通过缓存策略极大地改善响应时间并减少服务器的负载，延伸阅读可参考 引用4 引用5。下图为 React 针对 SSR 优化的前后性能对比图。 姿势小结这是在最近开发一款新应用时遇到的问题，考虑到项目中第一次使用 React 和 Webpack 进行开发构建，为了进度的平稳，还是先采用 Xtpl + React 这样的混合方案，等未来迭代时再逐步替换为同构方式。得益于模块化的开发风格，Xtpl 和 React 各司其职，完全解耦。 请求不要放在一个篮子里某一次笔者特意给自己挖了个坑，想看看什么时候会掉下去，没想到很快就如愿以偿了=。= 前文总结时已经提到过，既然是请求首屏数据，就只需要先获取第一屏的内容，并且如果遇到大量数据的图表时还应调整粒度进行“压缩”。但是为了体会到那种慢的感觉，笔者特意把页面所有的数据都请求完了才进行渲染，而页面内容包含三图一表… 起初完全感觉不到这样做的危害，直到数据库库表里的数据达到百万条，一条 SQL 请求语句需要 6-7s 时，页面载入的速度就令人很不爽了。 姿势小结和 SSR 相关的解决办法其实就是初次渲染时只请求首屏数据，其他数据待客户端加载完毕后再异步请求。 不过既然都提到了这个例子，也顺带说一下还做了其他哪些事： 添加 SQL 请求中的条件字段为索引 根据业务背景增加有意义的条件限制 服务端 cache 住可以复用的共享数据 报告！HTML字符串有小动作又在某一个项目开发中，笔者将首屏数据存在了 DOM 里，准确地说是将数据存放在了一个节点的属性中，当客户端加载代码后再读取数据进行后续工作。代码示例如下： 123&lt;!-- index.xtpl --&gt;&lt;div id="module1" data="&#123;&#123;data&#125;&#125;"&gt;&lt;/div&gt;&lt;script type="text/javascript" src="/public/index.js"&gt;&lt;/script&gt; 1234// index.jsimport Module1 from './module1.jsx';let src = $('#module1').attr('data');Module1.render(JSON.parse(src)); 后来在 review 代码时，发现一个显而易见的性能优化点：DOM 的操作很昂贵， 将数据存放在 DOM 中再通过 API 获取属于多此一举。Xtpl 文件作为模板，实质上就是字符串，数据插入到字符串的任意位置都是允许的，只是最终的意义不同。如果将数据写到模板的 &lt;script&gt; 中，客户端加载时数据就直接到内存里了。 改进后的代码如下： 12345&lt;!-- index.xtpl --&gt;&lt;div id="module1"&gt;&lt;/div&gt;&lt;script&gt; window.INITIAL_DATA = &#123;&#123;&#123;data&#125;&#125;&#125;;&lt;/script&gt; 1234// index.jsimport Module1 from './module1.jsx';Module.render(window.INITIAL_DATA);delete window.INITIAL_DATA; 不过笔者对于性能方面的担忧是多余的（DOM 操作昂贵没错，但不是贵在这里！可从浏览器的工作原理角度出发思考这一问题），这两段代码的执行效率几乎没有差别：在数据（字符串形式）量达到 36.7 KB 时，第一份代码对 DOM 的读取操作和 JSON.parse() 方法都是在 5ms 以内完成的。 反倒是页面体积有了明显的变化： 数据存在DOM中 数据存在内存中 Page1 42.1KB 23.9KB Page2 67KB 38.6KB 原因很有趣，当把数据存在 DOM 中时，需要先将 JS Object 转换为 JSON 格式的字符串。随后在 JSON 字符串写入 HTML 的过程中，所有的双引号都被转义字符 $quot; 所替换。而将数据直接写在 &lt;script&gt; 中就不存在这种情况，简单的字符串拼接后，就是一条赋值语句。经模板生成的网页源代码如下所示： 12345678&lt;!-- Previous --&gt;&lt;div id="module1" data="&#123;&amp;quot;key&amp;quot;:value&#125;"&gt;&lt;/div&gt;&lt;!-- Now --&gt;&lt;div id="module1"&gt;&lt;/div&gt;&lt;script&gt; window.INITIAL_DATA = &#123;"key":value&#125;;&lt;/script&gt; 姿势小结在 UTF-8 编码下，每当 JSON 字符串中出现一个双引号，前者就要比后者多耗费 5 个字节，当数据量很大时，页面体积就会出现很明显的差异。这在无线端等网络状况不稳定的业务场景中值得关注。 引用&amp;延伸阅读 精读前后端渲染之争 一看就懂的 React Server Rendering（Isomorphic JavaScript）入門教學 从零开始React服务器渲染 server-side-rendering-comparison React Server-Side Rendering Optimization Library Vue.js 服务器端渲染指南 - 缓存]]></content>
      <tags>
        <tag>SSR</tag>
        <tag>server-side</tag>
        <tag>render</tag>
        <tag>isomorphic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[响应式网站设计基础]]></title>
    <url>%2F2017%2F10%2F04%2Frwd-fundamentals-note%2F</url>
    <content type="text"><![CDATA[Why Responsive?Setting up Chrome’s Dev Tools使用 Chrome 浏览器的开发者工具除了可以调试 PC 端的页面外，也可以模拟其他尺寸的设备进行调试。 首先打开 DevTools，点击设备反转按钮开启移动端视图： 如果想模拟特定的设备，可以点击 设备列表 - Edit… ，以打开 Settings 列表；然后新增定制设备，设置 Width , Height , Device pixel ratio , User agent string 属性。 Using dev tools on mobile Android 设备 PC 端和 Android 手机安装对应平台的 Chrome 浏览器 Android 手机开启隐藏的 开发者选项 ，进入选项后勾选 USB调试 功能 手机连接电脑，打开各自的 Chrome 浏览器 在电脑的 Chrome 浏览器中登录 chrome://inspect ，可以看到连接的手机设备 点击 inspect 功能，打开调试页面后即可像调试本地页面一样调试手机端的页面 适用于 iOS 的移动工具 请参考以下文章： iOS WebKit 调试代理 Testing Mobile: Emulators, Simulators And Remote Debugging 如果觉得麻烦，也可以在 Chrome DevTools 中运行模拟器 Starting SmallDefining the ViewportQ：当我制作网页时，有时候内容过大溢出界面，又或者内容太小需要放大页面才能看清，这是怎么回事呢？ A：最大的问题是你的视窗没有设置好。 视窗（Viewport）是指浏览器显示内容的区域。不过不同设备的像素密度是不同的，例如某一 Chromebook 的屏幕分辨率是 2560 * 1700，但是浏览器全屏显示时，窗口的宽度是 1280 而非 2560。 Pixels, pixels and more pixels!浏览器并不是根据屏幕硬件的像素宽度而工作的，而是根据 DIPs（Device Independent Pixels） 宽度。当硬件像素为 2560，而 DIPs 为 1280 时，DPR（Device Pixel Ratio）也就是 2 倍。 如果没有设定 meta viewport，浏览器会怎么样呢？ 在渲染网页的时候，如果它原本是显示在一个宽 980 DIPs 的屏幕上，现在显示在一个只有 360 DIPs 的屏幕上时，内容就会以超过 2 倍的比例被压缩。 然后浏览器为了内容的美观性，会进行一项名为 font boosting 的工作，试图放大页面中的主要内容，而其他内容则维持大小不变。（如下图所示） Quiz: Setting the Viewport1&lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; width=device-width ：指导页面针对具体设备进行宽度调整，使得页面可以匹配不同屏幕尺寸 initial-scale=1 ：添加初始缩放比例属性并赋值为 1，使得 DIPs 和 CSS 像素的比例是一比一。如果不把初始缩放比例设为 1，有的浏览器会在切换到横屏模式时依旧保持之前的页面宽度，而且它们还会使内容只进行比例缩放，而无法自动调整布局（Reflow） Max-width on elementsCSS 是允许内容溢出其容器的，预防这一情况出现可以进行如下推荐的设置： 123img, embed, object, video &#123; max-width: 100%;&#125; Tap Target Sizes使用鼠标可以很轻松地点击到按钮等元素，但是如果使用手指，操作的精准度相比之下就糟糕许多。 我们的手指宽度大概是 10mm ，约等于 40 CSS 像素，所以按钮的大小至少要设置为 40*40px。推荐设置为 48*48px，这样能确保元素之间有足够的距离，也能照顾到手指更粗的人。 1234a, button &#123; min-width: 48px; min-height: 48px;&#125; Start Small设计响应式网页的概念与过程和非响应式是一样的，除了前者需要多画几种宽度的设计稿以适应不同屏幕尺寸。 这里推荐从最小屏幕尺寸的页面开始设计，通常是手机设备。做完之后再接着做更大一点的，依次类推，直至页面宽度上限。从最小的屏幕做起，开发者就必须优先考虑什么是对用户最重要的（Prioritize content!）、什么操作是用户最常做的、什么内容是用户最希望在屏幕上看到的。如果从最大尺寸往小设计，一些重要的信息很可能会被删除。因此，明确内容的优先级，然后从小到大设计，最重要的内容永远都会留在页面上。无论用户使用什么样的设备，也能得到最完整的体验。 除了设计上从小到大外，代码的编写也推荐如此，这样就能知道页面的风格和布局是否能兼容任何设备。此外，这样做也能帮助开发者从性能角度思考。 Building UpAdding a Basic Media Query12&lt;link rel="stylesheet" href="style.css"&gt;&lt;link rel="stylesheet" media="screen and (min-width: 500px)" href="over500.css" 添加了上面的媒体查询属性后，”over500.css” 样式表将在 DIPs 宽度大于 500px 时应用。 如果查询 Media Query 的相关文档，References 中可能还会提到其他媒体类型如 handheld projected embossed ，其实这些类型并不起作用，可以先忽略。目前只需要掌握 screen 和 print （打印页面时使用）即可。 除了在 &lt;link&gt; 标签中使用媒体属性外，以下还列举了两种方式进行媒体查询。 1234567@media screen and (max-width: 300px) &#123; /* Set style here */&#125;/* Complex Media Query */@media screen and (min-width: 480px) and (max-width: 960px) &#123; /* Set style here */&#125; 1@import url("over500.css") only screen and (min-width: 500px); 不过由于性能的因素，应该避免使用 @import 方式！它是一个性能消耗和优先级都非常高的标签（It’s pretty expensive and perf matters），相比 @media 方式需要更多的 HTTP 请求。 另外不推荐 min-device-width 和 max-device-width 这两个属性，原因自己想吧；） Breakpoints and Picking Them使用媒体查询的 min-width 和 max-width 可以改变整个页面的布局，而页面布局改变时的那个宽度尺寸叫做间断点。以 medium.com 来说，有 2 个间断点（ 于 2017.09 观察 medium 首页），观察间断点时建议从小的尺寸开始。 你永远不知道下一个热门的设备是什么，也不会知道两年后的流行趋势会是怎样，因此根据自己网页的内容寻找合适的间断点才是正道。 我们不应该规定任何间断点，相反，我们应该使用内容作为指引找到它们。—— Scott Yale Grids当我们可以使用媒体查询和间断点控制 CSS 样式后，自然而然会想问，有没有什么常用的模式（Patterns）或基本策略（Strategies）可以参考。 在常用的一些模式中，最简单的当属动态网格系统（Grid Fluid System），可以参考 HTML5 Rocks 作为范例。 在这个系统中有一些动态调整的纵列，当窗口变小时，它们将自动顺延到下一行。目前已经有一些优秀的框架可以使用，例如 Bootstrap、960px grid layout system。 FlexboxFlexbox 是目前最强大的布局工具之一，被广泛推荐，也已经被绝大多数浏览器支持。下面将会介绍一些基本语法，需要注意的是，在未来编写产品代码时，一定要包含所有版本的浏览器引擎前缀（Vendor Prefixed Version），以确保使用旧版浏览器的用户也能获得相同体验。 Flexbox 之所以功能强大，是因为它能够自动填充空白区域。如果一个元素周围出现了空白，它会自动填补上；而如果空间变得拥挤，元素会自动缩小。 使用 Flexbox 的第一步是加入 display: flex; 属性，这样容器内垂直排列的元素将会自动显示在一行内（ Flex 的默认堆放方式为横向堆放 row ）。此时拖动浏览器，无论宽度多少，横向堆放的元素们都不会换行。 1234.container &#123; width: 100%; display: flex;&#125; 要改变这种情况，可以为容器添加 flex-wrap: wrap; 属性，这是在告诉浏览器，允许内部的元素换行。 12345.container &#123; width: 100%; display: flex; flex-wrap: wrap;&#125; Flexbox 还有一个有用的特性是利用 CSS order 属性来改变元素的次序。 Common Responsive Patterns模式的变化很快，但也有一些通用的模式几乎能在任何设备上有不错的表现。响应式网页布局大致可以分为四种模式：Mostly Fluid、Column Drop、Layout Shifter 和 Off Canvas，有时候一个页面也会使用如 Column Drop 和 Off Canvas 的组合。 接下来将会讲解每种模式是怎样工作的，以及如何使用 Flexbox 和媒体查询技术来实现它们。注意在以下的示意图中，不同色块代表不同的内容区域。 Column Drop此布局共有两个间断点，在不同宽度时的排版如下图所示。 代码范例非常简单： 12345&lt;div class="container"&gt; &lt;div class="box dark-blue"&gt;&lt;/div&gt; &lt;div class="box light-blue"&gt;&lt;/div&gt; &lt;div class="box green"&gt;&lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920212223.container &#123; display: flex; flex: wrap;&#125;.box &#123; width: 100%;&#125;@media screen and (min-width: 450px) &#123; .dark-blue &#123; width: 25%; &#125; .light-blue &#123; width: 75%; &#125;&#125;@media screen and (min-width: 550px) &#123; .dark-blue, .green &#123; width: 25%; &#125; .light-blue &#123; width: 50%; &#125;&#125; Mostly Fluid此布局与 Column Drop 模型相似，但是更像网格系统，最明显的区别在于当视窗宽度达到最大宽度时，两边会出现外边距而内容不再延展。 代码范例如下： 1234567&lt;div class="container"&gt; &lt;div class="box dark-blue"&gt;&lt;/div&gt; &lt;div class="box light-blue"&gt;&lt;/div&gt; &lt;div class="box green"&gt;&lt;/div&gt; &lt;div class="box red"&gt;&lt;/div&gt; &lt;div class="box orange"&gt;&lt;/div&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627.container &#123; display: flex; flex-wrap: wrap;&#125;.box &#123; width: 100%;&#125;@media screen and (min-width: 450px) &#123; .light-blue, .green &#123; width: 50%; &#125;&#125;@media screen and (min-width: 550px) &#123; .dark-blue, .light-blue &#123; width: 50%; &#125; .green, .red, .orange &#123; width: 33.333333%; /* TODO: use "flex: 1" instead */ &#125;&#125;@media screen and (min-width: 700px) &#123; .container &#123; width: 700px; margin-left: auto; margin-right: auto; &#125;&#125; Layout ShifterLayout Shifter 布局模型应该是最灵活的响应式模型了，它有很多适用于不同设备的间断点，但最关键的是它的布局变化方式并不是单纯的重排到其它列的下方（参见下图中的红色列）。Flexbox 的亮点在这才真正凸显，因为我们可以利用 CSS 顺序属性来实现这种变化。 这次的代码范例稍微复杂一点： 12345678&lt;div class="container"&gt; &lt;div class="box dark-blue"&gt;&lt;/div&gt; &lt;div class="container" id="container2"&gt; &lt;div class="box light-blue"&gt;&lt;/div&gt; &lt;div class="box green"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="box red"&gt;&lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829.container &#123; width: 100%; display: flex; flex-wrap: wrap;&#125;.box &#123; width: 100%;&#125;@media screen and (min-width: 500px) &#123; .dark-blue &#123; width: 50%; &#125; #container2 &#123; width: 50%; &#125;&#125;@media screen and (min-width: 600px) &#123; .dark-blue &#123; width: 25%; order: 1; &#125; #container2 &#123; width: 50%; &#125; .red &#123; width: 25%; order: -1; &#125;&#125; Off Canvas在此模型中，内容并不是垂直堆放的，而是将不常用的内容比如导航栏或者应用菜单放在屏幕外，只有当屏幕足够大的时候才显示出来。在小尺寸屏幕上，溢出画布的内容通常会在用户点击菜单按钮时出现。 代码范例如下： 123&lt;nav id="drawer" class="dark-blue"&gt;&lt;/nav&gt;&lt;main class="light-blue"&gt;&lt;/main&gt; 12345678910111213141516171819202122232425262728html, body, main &#123; height: 100%; width: 100%;&#125;nav &#123; width: 300px; height: 100%; position: absolute; transform: translate(-300px, 0); transition: transform 0.3s ease;&#125;nav.open &#123; transform: translate(0, 0);&#125;@media screen and (min-width: 600px) &#123; nav &#123; position: relative; transform: translate(0, 0); &#125; body &#123; display: flex; flex-flow: row nowrap; &#125; main &#123; width: auto; flex-grow: 1; &#125;&#125; 1234menu.addEventListener('click', e =&gt; &#123; draw.classList.toggle('open'); e.stopPropagation();&#125;); 点击此处查看 Live demo。 Quiz: Off Canvas Visualization Quiz OptimizationsImages A picture is worth 1000 words. 使用同一张图片时，改变其分辨率可能是最常用的方式之一。试想在笔记本电脑上显示一张标准图片，但显示一张两倍大的图片给一个更高 DPI 的显示器，例如一台 Retina iMac。又或者是在不同尺寸的设备上显示图片时，显示不同内容的图片。要实现这些效果，图片元素可以使用媒体查询来选择使用哪张图片。 Responsive Tables表格有很多花样，如果其列超过一定的数量，是很有可能溢出视窗的，在小屏幕上会产生水平滚动条。有一些方法可以解决这个问题，以下是三种参考方案。 Hidden Columns当视窗尺寸缩小时，Hidden Columns 实际上是根据表格的重要性来进行隐藏的。从小屏幕开始设计时，思考什么信息是最重要的，然后保留下来，隐藏其他不显示的内容。 Hidden Columns 最大的问题在于隐藏了内容，如果这些被隐藏的内容刚好是用户想知道的就麻烦了。如果可以，请使用缩写而不是完全隐藏内容。 No More Tables当视窗小于一定值时，表格会瓦解，并重组成长列表。这种方法的好处是所有数据都是可见的，无论视窗尺寸多大。 Contained Scrolling为了把表格放在视窗中，最简单的做法就是把它放在一个 div 里，然后设置宽度为 100%，最后设置 overflow-x: auto;。虽然表格还是会占据同样的宽度，但是可以用滚动条在视窗中拖动查看。 Fonts如果一段文字的每一行太短或太长，阅读起来都会让人感到不舒服，因此理想的文字行宽很重要。这是个很有技术含量的问题，目前已经有一些研究成果表明，依据使用的字体、显示的设备不同，每行 45 个字符到 90 个字符都是合理的。不过，在网页中大概每行 65 个字符是最常见的。这并不是硬性规定，但是个不错的建议。与此同时，行宽也是选择断点时的重要参考因素之一。 此外，用户的阅读体验也非常重要。以字体的大小和行高来举例：在不同设备上字体需要足够的大以保证用户看得清楚，通常建议至少设为 16px；而行高至少有 1.2em 才不会使文字看起来太拥挤。 Minor Breakpoints除了选择令布局显著改变的主断点（Major Breakpoints）外，增加副断点来实现一些小的改变是很有帮助的。例如，在主断点之外调整元素的外边距，或者给一些内容增大字号使其更容易阅读（布局上也会更加自然一点）。 References Udacity - Responsive Web Design Fundamentals PageSpeed Insights - Configure the Viewport]]></content>
      <tags>
        <tag>note</tag>
        <tag>web</tag>
        <tag>rwd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Weex Android 发车指南（已弃车）]]></title>
    <url>%2F2017%2F08%2F06%2Fweex-android-quick-tutorial%2F</url>
    <content type="text"><![CDATA[前言还记得刚入职见到第一个 YunOS App 时，笔者问师兄 Manifest.json 文件是干嘛用的，师兄说如果你有 Android 开发经验的话就会明白了。当下笔者立马找了本电子书放在桌面准备苦读，结果…时至今日未曾宠幸过。对于没有一点 Java 经验的笔者来说，不知道何时才会迈出无线开发第一步，直到最近遇见了 Weex。 Weex 是集团去年推出的移动开发框架，Apache 顶级开源项目，已经被手淘、天猫等业务广泛使用，经历了双十一等活动的考验。它与传统的移动开发不同、也是吸引笔者的地方，即使用 Web 前端技术进行开发且能达到 Native 级别的性能体验。 既然笔者毫无 Java 以及 Android 开发经验，必然会站在 纯前端人员的视角 来带领大家上车。此外，Weex 在集团内外的热度真的是非常之高，相关的文档、博文也是数不胜数，因此文中将会使用一些引用来保证心得的简洁同时给大家更多延伸的内容。 什么是 Weex ？理论角度，官方文档上已经说得挺清楚的了，一张流程图可以说明一切。 不过回到实际开发，Weex 是什么，这点在没有上手前很难从官方文档中得出结论。（网上有不少声音吐槽 Weex 文档写的不好，笔者持保留态度，不过确实从落地的角度来说，缺乏一些必要的细节，这个后面还会再提。此外作者还有一个疑问，官方文档究的目标群体究竟是谁？是传统的移动端开发者？还是 Web 前端背景的开发人员？至少笔者觉得不是后者。） 以实践的角度，在笔者看来，Weex 有两部分，一是前端技术方面的自动化框架，在PC端帮助开发人员快速进行 vue 文件的开发、打包等，这部分可以在官网搭建开发环境的教程中获取；二是使 JS 代码能在移动端成功运行起来的各平台 SDK 套件或源码，在编译各平台安装包时加入，文档中也有提及。 除了 Weex 本身，其配套的开发工具比较丰富。有脚手架 weex-toolkit 、移动端的预览工具 Weex Playground 、在线代码执行工具 Weex Playground 等。 最后，官方手册介绍了 Weex 支持的 element 组件、内建的模块、各平台的 API 等开发时需要查阅的东东，很全面，在此不赘述。 至于 Vue 我想 Web 前端开发者或多或少都是熟悉的，在此不多做介绍。 如何在 Android 上运行一个最简单的例子？官方的入门教程包中含一段最简单的 Hello world 例程，既然 Weex 是为移动端设计，那么是个工程师都想赶快在手机上跑起例程来看看效果，而非在线上模拟器中体验。此时就暴露了文档的缺失——读完《集成 Weex 到已有应用》一文档后，对没经验的人来说，甚至没办法成功编译出 APK 文件，可谓是出师未捷身先死。 同时，现实总是残酷的。想在 Android 上运行 Weex 应用，还是需要懂得配置 Android 应用、编写一些 Java 代码，这对前端工程师来说，又是一次 雪上加霜 成长的机会=。= 在这里推荐两篇文章帮助大家快速上车，正是通过它们笔者成功实现了最小例程的编译及运行： 第一篇是来自 ATA 的《weex新手指南》，其中包含一个 “知乎日报” 应用源码的详细分析，从中可以知道 为什么要编写那些 Java 代码 。 第二篇文章名为《Weex Android 初体验》，其更多地覆盖了实践细节上的问题，并且提供了一个类似最小例程的 github repo，可以 参考其 Java 源码编写自己的代码 。 踩坑心得 Weex 环境中没有 DOM，因此无法使用像 Jquery 之类关于 DOM 操作的类库。同样的道理，Weex 中样式只支持 px 单位，无法使用 em , rem 。 Weex 中页面宽度是以 750px 作为标准的！更多信息请参考《Weex学习与实践（一）》，评论区勾股还贴出了社区讨论的链接。 开发时一定要使用手机版的 Playground 进行预览，而不是观察本地浏览器中的画面！ 更多阅读 《WEEX系列文章汇总》：Weex 官方的 ATA 文章，入口帖 《关于Weex，你想了解的一切都在这里》：又一 Weex 官方的 ATA 文章，入口帖 《weex vs react-native》：同为前端无线技术，不对比就难以了解 Weex 的诉求是什么，对吧 《Weex总结之Android Weex工程搭建趟坑》：通俗易懂的实践文 《weex新手指南》：针对最简单的 Android Weex 代码做了详细说明，并提供了一个详细案例（知乎日报）的分析和 github 源码 姿势观摩 Weex Vue Examples：包含很多基本组件使用的范例 weex-hackernews：很牛逼的 weex 版 hackernews app，包含 Android 工程在内所有的代码，亲测编译 APK 到 7.0 系统中运行 vue-hakcernews-2.0：想了解更多 Vue 开发可以关注此 repo，web 版 hackernews，Vue 作者亲自开发 后话没有详细的文档讲解如何产出最终 APK 文件，蛋疼的 CSS 写法，以及种种…已弃坑（微笑脸]]></content>
      <tags>
        <tag>weex</tag>
        <tag>android</tag>
        <tag>web</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL 笔记]]></title>
    <url>%2F2017%2F03%2F26%2Fmysql-note%2F</url>
    <content type="text"><![CDATA[这是一篇关于 MySQL 的语法笔记，主要供自己和新手们查看。 参考资料写在最前面…当然是不要重复造轮子！做笔记也是如此！So ~ 先引用一发： 21分钟 MySQL 入门教程 遣词造句像翻译英语句子一样来记录语法。 按用户名查询用户的所有昵称12SELECT DISTINCT(nick) FROM TABLE_SAMPLE WHERE name IN(SELECT name FROM TABLE_SAMPLE GROUP BY name) 按月以及平台查询用户数123SELECTDATE_FORMAT(time, '%Y-%m') months, COUNT(DISTINCT(uid)) AS user_countFROM TABLE_SAMPLE GROUP BY months, platforms 查询时间单位的数据总和12345678910111213141516# 每分钟SELECTSUM(data) AS sumFROM TABLE_SAMPLE GROUP BY YEAR(time), MONTH(time), DAY(time), HOUR(time), MINUTE(time)# 每10分钟SELECTSUM(data) AS sumFROM TABLE_SAMPLE GROUP BY YEAR(time), MONTH(time), DAY(time), HOUR(time), FLOOR(MINUTE(time)/10)# 每小时SELECTSUM(data) AS sumFROM TABLE_SAMPLE GROUP BY YEAR(time), MONTH(time), DAY(time), HOUR(time)# 后面依此类推... 查询每小时的数据总和一次查询里查询多样数据123SELECT(SELECT uid FROM TABLE_SAMPLE_1 WHERE name = '我最帅') AS uid,(SELECT height FROM TABLE_SAMPLE_2 WHERE name = '我最帅') AS height 一次更新多条数据123456UPDATE TABLE_SAMPLESET credit = credit + CASE WHEN name = '我最帅' THEN 1000 WHEN name = '我不帅' THEN 0 END, time = CURRENT_DATEWHERE name IN ('我最帅', '我不帅') 一次插入多条数据12INSERT INTO TABLE_SAMPLE (name, credit)VALUES ('我最帅', 1000), ('我不帅', 0) Tips 字串存在： LOCATE(你要查的字符串，对应的域) &gt; 0 字串连接：CONCAT(STR1, STR2, ...) ， CONCAT_WS 第一个参数是分隔符 时间：FROM_UNIXTIME 和 UNIX_TIMESTAMP 查看倒数第 20 到 30 笔数据：ORDER BY id DESC LIMIT 20, 30 日期：CURDATE() = DATE(NOW())]]></content>
      <tags>
        <tag>mysql</tag>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小议 Javascript 数组去重]]></title>
    <url>%2F2017%2F02%2F01%2Fremove-duplicates-from-javascript-array%2F</url>
    <content type="text"><![CDATA[几乎所有 Javascript （以下简称 js）初学者都会遇到的一个问题：如何（优雅地）去除数组中重复的元素。这个问题在 stack overflow 上被赞了近五百次，不过这并不重要。重要的是，有热心网友给出了全面、专业的回答，让博主看了大呼过瘾。在此对原文进行翻译，与大家一起分享。 注： 下文中的“物件”对应英文”object”。 “Smart” but naïve way (图片来源：http://www.keepcalm-o-matic.co.uk/) 123uniqueArray = a.filter(function(item, pos) &#123; return a.indexOf(item) == pos;&#125;) 最基本的版本：我们迭代整个数组，检查其中每一个元素在数组中第一次出现的位置与该元素实际的位置是否相等，如果不等则为重复元素。使用 filter 的回调函数中的第三个参数 self ，可以避免数组变量的闭包问题（数组中的元素还是数组）。 123uniqueArray = a.filter(function(item, pos, self) &#123; return self.indexOf(item) == pos;&#125;) 尽管这种算法简洁明了，但是对于大型数组来说尤其缺乏效率（时间复杂度为 n^2）。 Hashtables to the rescue123456function uniq(a) &#123; var seen = &#123;&#125;; return a.filter(function(item) &#123; return seen.hasOwnProperty(item) ? false : (seen[item] = true); &#125;);&#125; 通常使用的方法是将每个元素存入一张哈希表中，然后直接检查它是否存在。这保证了线性的时间复杂度，但存在至少两个缺点： 由于在 JavaScript 中，哈希键 (key) 只能为字符串，这将导致上述代码无法区分数字和字符串数字。例如，uniq([1,&quot;1&quot;]) 将只会返回 [1] 。 同理，例如 uniq([{foo:1},{foo:2}]) 这样具有相同键的物件也会被认为是一样的，仅得到 [{foo:1}] 。 也就是说，如果你的数组中仅包含 js 的原始类型 (primitives) 且你无需在意它们的具体种类（例如它们全都是数字），这个算法是最佳的。 The best from two worlds结合上述两种方法，有一个通用的解决方案：原始类型使用哈希表查找，而物件使用线性查找。 1234567891011function uniq(a) &#123; var prims = &#123;"boolean":&#123;&#125;, "number":&#123;&#125;, "string":&#123;&#125;&#125;, objs = []; return a.filter(function(item) &#123; var type = typeof item; if(type in prims) return prims[type].hasOwnProperty(item) ? false : (prims[type][item] = true); else return objs.indexOf(item) &gt;= 0 ? false : objs.push(item); &#125;);&#125; sort | uniq还有一个选择是先对数组排序，然后去除与前一元素相等的元素： 12345function uniq(a) &#123; return a.sort().filter(function(item, pos, ary) &#123; return !pos || item != ary[pos - 1]; &#125;)&#125; 同理，由于 sort 方法无法直接对物件进行排序，因此这种方法对物件无效。另外存在一个副作用——原始数组已被改变。假如输入数组已经是有序的，则可以使用这种方法（同时去掉上述代码中的 sort() 方法）。 Unique by…有时候我们希望能基于一些条件而不仅仅是根据数值相等进行唯一化，例如过滤出有共性但是实际是不同的物件（后面会举例说明）。传递回调函数可以优美地解决这一需求。由于 key 预期会返回一个原始类型，因此哈希表在这里可以正常工作： 1234567function uniqBy(a, key) &#123; var seen = &#123;&#125;; return a.filter(function(item) &#123; var k = key(item); return seen.hasOwnProperty(k) ? false : (seen[k] = true); &#125;)&#125; JSON.stringify 就是一个特别有用的 key 回调函数，可以移除“看起来”一样但实际不同的物件： 123a = [[1,2,3], [4,5,6], [1,2,3]]b = uniqBy(a, JSON.stringify)console.log(b) // [[1,2,3], [4,5,6]] 如果 key 返回的不是原始类型，则需要依赖线性搜索： 1234567function uniqBy(a, key) &#123; var index = []; return a.filter(function (item) &#123; var k = key(item); return index.indexOf(k) &gt;= 0 ? false : index.push(k); &#125;);&#125; 或是使用 ES6 中的 Set 物件： 1234567function uniqBy(a, key) &#123; var seen = new Set(); return a.filter(item =&gt; &#123; var k = key(item); return seen.has(k) ? false : seen.add(k); &#125;);&#125; (相比 seen.has(k) ? false : seen.add(k) ，有些人更喜欢 !seen.has(k) &amp;&amp; seen.add(k) ) LibrariesUnderscore 和 Lo-Dash 都提供了 uniq 方法，他们的算法与上述第一段代码类似，总结就是： 123456var result = [];a.forEach(function(item) &#123; if(result.indexOf(item) &lt; 0) &#123; result.push(item); &#125;&#125;); 其时间复杂度是二次方，但是有些额外的好处，例如封装了原生的 indexOf 方法、可以通过键进行唯一化（官方说法叫 iteratee）、对于有序数组有优势。 如果使用 jQuery 并且喜欢以美刀符号开头，则大概长这样： 12345$.uniqArray = function(a) &#123; return $.grep(a, function(item, pos) &#123; return $.inArray(item, a) === pos; &#125;);&#125; 同样的，也是第一段代码的变体而已。 PerformanceJavaScript 中函数呼叫的成本昂贵，因此上述方法即使简洁明了，但是并不高效。如果以效能为最高宗旨，将 filter 全部替换成回圈以避免多余的函数呼叫： 1234567891011121314function uniq_fast(a) &#123; var seen = &#123;&#125;; var out = []; var len = a.length; var j = 0; for(var i = 0; i &lt; len; i++) &#123; var item = a[i]; if(seen[item] !== 1) &#123; seen[item] = 1; out[j++] = item; &#125; &#125; return out;&#125; 这段丑陋的代码和第三段代码做了相同的事情，但是执行速度上快了一个数量级。 （测试代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041function uniq(a) &#123; var seen = &#123;&#125;; return a.filter(function(item) &#123; return seen.hasOwnProperty(item) ? false : (seen[item] = true); &#125;);&#125;function uniq_fast(a) &#123; var seen = &#123;&#125;; var out = []; var len = a.length; var j = 0; for(var i = 0; i &lt; len; i++) &#123; var item = a[i]; if(seen[item] !== 1) &#123; seen[item] = 1; out[j++] = item; &#125; &#125; return out;&#125;/////var r = [0,1,2,3,4,5,6,7,8,9], a = [], LEN = 1000, LOOPS = 1000;while(LEN--) a = a.concat(r);var d = new Date();for(var i = 0; i &lt; LOOPS; i++) uniq(a);document.write('&lt;br&gt;uniq, ms/loop: ' + (new Date() - d)/LOOPS)var d = new Date();for(var i = 0; i &lt; LOOPS; i++) uniq_fast(a);document.write('&lt;br&gt;uniq_fast, ms/loop: ' + (new Date() - d)/LOOPS) ） ES6ES6 提供了 Set 物件，让事情变得简单许多： 123function uniq(a) &#123; return Array.from(new Set(a));&#125; 或者 1let uniq = a =&gt; [...new Set(a)]; 需要注意的是，与 Python 不同，ES6 的 set 以插入顺序进行迭代，因此代码保证了原始数组的顺序。 无论如何，如果你需要一个唯一化的数组，为何不从正确地使用 set 开始呢？ 后话文章发在公司内网的技术论坛后，有一些很有价值的反馈。 有同学按照上述方法进行了测试，发现 demo 的第一种和第二种并不存在“数量级”的差异，另外 Set 的效率也并不高，比前两者都慢。 我随即也进行了测试，发现确实如此。 123456MacBook Air (13-inch, Early 2015) 8G RamChrome (版本 56.0.2924.87)uniq, ms/loop: 0.362uniq_fast, ms/loop: 0.171uniq_set, ms/loop: 1.728 其次一位资深同学提出以下观点，很有启发： 数组去重的关键点是：如何判断“重复”，是否完备可靠。 数组类型的 indexOf() 方法不能处理 NaN 的情况 Set 类型的key不支持Object类型，而且会区别对待 1 和 &#39;1&#39; 关于性能测试。建议到jsperf上去写个case跑一跑，比如：https://jsperf.com/js-unique-array ；而且要在多个浏览器下测试。因为不同内核对es语法的实现不一样，表现出来的性能也不一样 这篇文章也讨论了数组去重问题：https://www.toobug.net/article/array_unique_in_javascript.html 原文链接:Remove Duplicates from JavaScript Array]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>array</tag>
        <tag>remove duplicates</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从硅谷软件企业学习到的细节]]></title>
    <url>%2F2016%2F04%2F29%2Fthe-details-i-learned-from-software-company-in-silicon-valley%2F</url>
    <content type="text"><![CDATA[前言Ryan 哥是我在 Lilee 实习时的同事，按时间来说他比我还晚进入 Lilee (笑)。虽然相处天数很短，但对他印象深刻：个子不高，酷酷的很有型，CMU 毕业，湾区大公司工作经历。在公司每季(？)的新人介绍茶话会上，发现他也是一个很好聊的人。最后我打包滚蛋时，他也是为数不多写邮件给我践行的人。 就在这个月中旬， Ryan 哥在自己的脸书上写了这里分享的这篇文章，颇具视野和深度，对于我这样的新人来说很受启发，因此也搬运到我的博客上来。本文的原出处，里面还有一些精彩评论，有兴趣也可以去看看。 從矽谷軟體企業學習到的細節回來台灣一年多了，在矽谷工作時，我總是想說服大家一起回台灣做點小貢獻。但現在，我的確認為台灣需要有更多人出國看一看拓展新的視野，未來有機會再帶回更多新的思維回到家鄉，和台灣原本就保有的優點融合。 之前很高興有機會到交大還有 Sudo 的活動分享在矽谷工作時感受到的文化和經驗。最近還是有許多朋友有興趣想了解台灣軟體業除了以往在資源上的限制，還有什麼樣不同的文化和制度對目前軟體產業造成衝擊和差異性。所以趁這個機會分享一些目前在台灣軟體產業觀察和聽聞的現況，去探討我們可能可以自省的方面。在我們努力衝刺的過程中，希望可以提及幾項在台灣軟體產業看似還普遍缺乏的思維和觀點： 人是公司最大的資產：在台灣是企業選擇員工，在矽谷是員工選擇企業。矽谷企業普遍認為，人是公司最大的資產。除了公司選擇比較多以外，企業團隊也總是很感激員工的加入， 並且願意提出更好的 counter-offer 努力把好的人才吸引過來。同時，員工也可以用更健康的心態去 negotiate 自己的 offer 讓彼此都達到滿意的結果。 以人為本，公司對人的尊重，是大家最嚮往的文化。 人格特質 vs 學歷/技術：學歷的迷思應該慢慢被擺脫。在台灣工作，學經歷在一開始就會非常被注重和強調，導致公司對你有了預期，但這個預期指的是”技術”這方面而已。學經歷不錯的人很容易被公司預期在短期內要有所產出。 如果短期內沒有達成，公司會默默的打分數，一切完全以短期技術可行性，當成參考依據來預期未來你對公司可能的影響。矽谷的企業各式各樣的學經歷的人更多元，但比較不一樣的是，公司不會太明顯對每個人預設立場。這之中最大的不同點是，美國公司對你的預期不會純粹以技術為考量，而是整個人的人格特質和全面性。公司願意花更多資源投資每個員工，以幫助公司了解 team member 的人格和個性，積極度，潛力，爆發力，做事的 tempo 和 learning curve 的時間，儘管小公司也有類似的認知。回到以往很多 CMU 的學弟妹都會問我說，INI 會不會是 ECE &amp; CS 底下合開的學院造成在美國找工作的影響。我告訴他們，工作以後就會了解到那並不是矽谷公司在找尋人才唯一強調的事。不論是 Google, Apple 還是各大公司 / startup，在面試聊天時，除了去了解一個人的個性之外，也需要考白板的 coding 測試你的技術能力。考題的例子包括：資料結構的 binary tree，queue，linked-list，演算法的 sorting，Dijkstra，八皇后題目，OS 和系統相關的 synchroization，networking, process / thread，memory management，brain teaser 相關題目像是給兩個雞蛋用數學來測出雞蛋在哪一層會破掉的問題 (我很喜歡的題目之一)。聽起來好像很制式化的流程，但其實對於矽谷的公司來說，那才是他們注重的基本能力和了解一個人是否能與團隊有良好的溝通能力。不論你是什麼學歷，只要你夠積極去充實這些知識，保有好奇心和培養良好的 teamwork，好的人格特質和個性加上技術才是公司想招募的人。 Code review / QA / 開發流程時間：這是許多公司心裡記得很重要可是卻最不願意花時間和錢投資的項目，原因免不了是 time to market 跟追趕 project 進度。台灣許多公司想要開發高利潤產品走向國際，策略模式卻還是採取以往 hit and run 模式的代工思維。全世界企業都有時間壓力，除了技術以外，我們更應該開始強調軟體管理的學問。Code review 的重要性建立在一個軟體開發的長遠計畫之上，注重的是開發者的邏輯思維和 coding style 會不會影響目前和未來的產品，還有 code 提供給其他工程師的可讀性。開發時，要想著這個軟體未來可能會變幾千行，幾萬行，甚至是幾十萬行的產品。而每個人的 coding style 有所不同，公司需要訂立 coding guideline 來規劃基本規則以方便大家產出 code。這種觀念的缺乏導致很多 code 沒有被 review，或是變成 reviewer 灌輸 developer 他心裡想要的 coding style。而 QA 的方面，感覺各企業對此重視的程度很多年來還是嚴重不足，自然沒有扎實的測試方法論和流程來把關品質。對於開發者來說，應該普遍建立 QA 實際上是公司第一個客戶的觀念，所以測試流程像是 smoke test，regression test，white box testing 在交予 QA 前應該是已經需要被建立好的。Hit and run 的策略短期內也許可以拿到客戶，但長久下來如果價格和品質無法成正比，這樣的關係無法長久。再者，以往累積的 technical debt 在未來需要花的時間還是得花。如果企業想賣高規格的東西，一定要確保品質再出貨。在美國做一樣的工作，一樣執行 waterfall 或 agile 的流程，時間的安排卻是全然不同。因為 time to market 的原因所以在固定時間需要出貨這點是可以理解的，這個時候 PM 很重要。有經驗的 PM 要滿足客戶需求同時也要能替工程師在一定時間內斟酌合理的開發數量和可行性，將開發者方面的測試考慮進去是必要的技能。 缺乏純技術者的 career path 和職務的 misplace：以技術面來說，台灣軟體技術人才眾多，演算法人才也不在少數，但是普遍需要廣度的員工包山包海，所以欠缺了 Technical Leader 和系統架構師類型的人物的培養。專才需要長期在廣度和深度的訓練和培養，並有著對任何事物的好奇心來整合元件而建立有門檻的大架構，而培養對於任何事物的好奇心回到了教育的本質。普遍來說，台灣企業往往將年資久的員工或是技術領導者全都佈署在管理人的 career path 上。這樣造成的問題是，技術者只有鑽研技術的熱情，並沒有技能去處理跟人相關的事物，導致職缺的misplace。美國的公司普遍在升遷時會要你選擇未來你期許的 career path 是往管理的路或是技術領導者的職涯前進。適合經營管理的人會經歷 software engineer -&gt; senior engineer -&gt; manager -&gt; senior manager -&gt; director -&gt; VP，而技術領導者會經歷 software engineer -&gt; senior engineer -&gt; tech lead -&gt; senior tech lead -&gt; architect / distinguished engineer. 這不僅清楚的替每個升遷的人規劃了更適合自己的路，也替公司員工找到能夠真正管理人的主管進而幫助公司整體的成長和營運。 本位主義和信賴問題：在人文方面，部門的本位主義過於強烈，所以職場上卡到了許多人跟人的問題或是各單位之間沒有太多向心力是比較多朋友都會提及的經驗。主管應該多培養底下的人有獨立思考的能力，有些時候花些時間跟員工單獨聊天，可以發現目前很多年青人對公司有很多不同的想法和未來的期許。以一個健康的角度來看，主管應該多鼓勵底下的人發言討論，或是鼓勵員工有一天能夠超越自己，但很重要的前提是要彼此尊重。然而，為什麼主管要鼓勵員工超越自己？其實員工有良好的表現不僅幫助了自己，更重要的是同時也幫助了主管和公司向上成長。現在的時代注重團體戰而非英雄主義，不論是員工或主管都應該要知道在不同位子看事物的角度一定有所不同。如果彼此一直無法了解對方的思考方式和表達方式，每個人就始終無法由內而外說服自己為了同個目標前進。矽谷企業的強盛給我的感覺是建立在共存共榮的 teamwork 文化，職權區分明確，良好的溝通管道，傾向對事不對人的模式而一同完成公司的目標。 缺乏文件整理和 mentor，造成資訊落差：一樣是卡在時間資源的問題，過去的人需要趕時間出貨所以沒有多餘的時間把以往的經驗，技術資訊，或是曾犯過的錯記錄下來，導致新進員工沒有文件可參考也沒有特定的 mentor 可仿效。新人往往會不好意思請求協助，所以元老級的人物每天理解事物越來越快，但新進員工卻越來越追趕不上前人而造成資訊和技術程度上的落差，會逐漸形成公司的一個隱性問題。所以鼓勵大家，可以多使用協作工具，如果在開發時遇到問題，或者是發現以往的技術開發沒有參考文件，都應該踴躍幫忙公司記錄和整理文件，如同開源軟體的無私貢獻。當越來越多同伴到達同樣的水平，才會有可能替企業創造更多的可能性。 整體而言，這幾年開始可以感受到台灣軟體業的興起和企業對軟體的重視程度提高許多，這是非常正向的鼓勵。同時也有更多學術單位，政府和企業都願意投入更多的金錢，人力，研發資源在軟體產業中。想要捨棄台灣長久以來的代工思維而轉型成高利潤高門檻的產業結構痛苦是必然的過程。很多對台灣企業看來好像要有多出的時間才能執行的項目，其實對於矽谷的企業來說其實都應該是需要注重的細節和基本功。台灣企業如果想要成功走向國際，也會需要很多領導者願意推翻自己過往的經驗和思維，並且有足夠的心胸去接受新世代的觀念而學習。回台灣後當然也總算可以開始體會為什麼台灣年青人都想往外出走，去到一個更健康的工作環境學習。但希望大家還是不要對台灣失望，繼續花點時間感受問題。除了技術的加強，如果更多人能開始注重以人為本的概念，強調更多軟體管理方面細節的改善，就算台灣短期無法被影響，但未來還是有許多值得被改變的事。大家共勉之。]]></content>
      <tags>
        <tag>silicon valley</tag>
        <tag>software</tag>
        <tag>inspiration</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Online notes of John Chou]]></title>
    <url>%2F2016%2F04%2F14%2Fonline-notes-of-john-chou%2F</url>
    <content type="text"><![CDATA[公开课学习笔记 Operating Systems From: Coursera Instructor：Chen Xiangqun (Peking University) Lang：Simplified Chinese State：12 / 12 Note Jserv 指导的嵌入式课程 Embedded Graphics Entry 课程资料 WIKI 2015 嵌入式系统课程资料整理 「你所不知道的 C 语言」系列讲座 计算机组织结构 环境搭建 2015 Q1-Q2 Week 2：环境搭建、ARM Architecture Week 3：FreeRTOS Week 4：Visualization for scheduling Week 5：许富皓教授的 Linux 核心教材 Week 7 &amp; Week 8：STM32程序开发：以GNU Toolchain为例、Mini ARM OS Week 9：GDB &amp; CGDB 使用 RT-Thread： Wiki Hackpad Addition：Disassemble a simple C code to analyse the stack behavior 2015 Q3-Q4 HW_1：GNUPlot、GProf、SIMD HW_2：Assert、ARM Architecture、Perf、Phonebook 搜寻 HW_3：Quiz from Leetcode HW_4：Calling convention、Compiler 基础 HW_5：补全之前的作业 HW_6：基础理论 HW_7：SIMD(SSE, AVX)、prefetch HW_9：阅读资料、提出问题 (GPIO/ADC/USART/SPI/Flash/I2C/USB) HW_10：个人简历 补考 μVisor: WIKI Hackpad 通用笔记 面试相关 面试题目 嵌入式的面試題]]></content>
      <tags>
        <tag>note</tag>
        <tag>embedded</tag>
        <tag>CS</tag>
        <tag>collaborate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的 Ubuntu 系统配置]]></title>
    <url>%2F2016%2F04%2F09%2Fmy-configuration-for-ubuntu-distribution%2F</url>
    <content type="text"><![CDATA[安装 Ubuntu 几次便会形成一套 SOP，在此做一个整理。 给新系统减肥 修改 terminal 配色、字体大小… 通过 Tweak 设置桌面显示图标（个人癖好） 删除无用软件（只是列举几个而已) 1sudo apt-get remove unity-webapps-common thunderbird evolution 各种更新 12345sudo apt-get updatesudo apt-get install -fsudo apt-get upgradesudo apt-get dist-upgradesudo apt-get autoremove 下载安装 Chrome，搜狗拼音输入法，vim，cgdb，git Terminal 配置 首先将我的 配置文件 克隆到电脑上，然后将里面的东西都复制到自己的用户目录下。如果没有使用 TMUX 软件则不必复制 .tmux.conf 文件。123cp .bashrc .vimrc .gitconfig .tmux.conf ~/.cd ~source .bashrc VIM 配置 安装 VIM Plugin 管理插件 Vundle； 进入 VIM 并输入:VundleInstall； 使用 Pathogen 插件； 1curl -LSso ~/.vim/autoload/pathogen.vim https://tpo.pe/pathogen.vim 安装 xptemplate 插件（自动补全功能）。直接将其项目克隆到家目录下的.vim文件夹中即可； 安装 ctags，下载源码编译即可，初始化直接在目录下进入 vim 按ctrl &amp; F12，使用直接在代码上用ctrl &amp; ]追踪，ctrl &amp; t返回； 安装 cscope，直接通过apt-get即可，初始化代码如下，使用上覆盖了 ctags 的操作，并且可以使用ctrl &amp; \ + s查找当前光标所在符号出现过位置（更多指令请man cscope）；123cscope -Rbq -f &lt;name&gt;.out# Enter vi:cs add &lt;name&gt;.out 清除临时文件以.un~结尾的临时文件还蛮讨厌的，像我个人有强迫症，看到就会想删掉，可以输入以下命令来打扫。1234find . -name "*~" &gt; ToBeClear.shchmod +x ToBeClear.sh# Add rm to the head of ToBeClear.sh by vim, sort multi-lines to one line by "shift j"./ToBeClear.sh]]></content>
      <tags>
        <tag>github</tag>
        <tag>ubuntu</tag>
        <tag>vim</tag>
        <tag>config</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[五分钟快速搭建一个博客]]></title>
    <url>%2F2016%2F04%2F09%2Fbuild-a-blog-in-5-minutes%2F</url>
    <content type="text"><![CDATA[作为部落格的第一篇文章，就记录一下它的诞生过程吧：）博客很阳春，使用了 Github 和 Hexo，都是一谷歌就能找许多答案的技术。 搭建流程 安装 node.js 和 npm，推荐直接从官网下载源码编译； 安装 hexo： 123npm install hexo-cli -ghexo init blogcd blog 安装主题，本博客使用 NexT 主题： 1git clone https://github.com/iissnan/hexo-theme-next themes/next 启用主题，在根目录下将_config.yml文件中的theme:改为你所需的主题名； 验证主题： 1hexo s --dedbug Git 初始化并同步到 Github 上： 123456echo "# blog" &gt;&gt; README.mdgit initgit add README.mdgit commit -m "first commit"git remote add origin git@github.com:Joouis/blog.gitgit push -u origin master 使用 hexo 部署功能，补充根目录_config.yml文件中的deploy，然后： 1hexo d -g 在 source 目录下加入CNAME文件，在登陆 DNS 服务商增添 CNAME 记录即可； 參考主題配置、第三方服务一步步客制化自己的博客。 心得 五分钟是完全足够搭建起博客的，不过真正费时的，就是一点点把它修改成自己想要的样子吧。 头一次使用 Hexo ，比 Jekyll 更方便，并且使用的 NexT 主题基于 Hexo 增添了很多功能接口，像搜索、评论平台等，只需要设置_config.yml一个文档基本上就能解决问题，确实很好用！ 博客的用途是用来记录，Markdown 语言的特质就是帮助你专注在记录上，而今天使用的 Hexo 和 NexT 亦是如此。]]></content>
      <tags>
        <tag>blog</tag>
        <tag>github</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
