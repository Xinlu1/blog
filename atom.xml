<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>江边的旱鸭子</title>
  
  <subtitle>Blog of Joou</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.joouis.com/"/>
  <updated>2019-04-10T17:35:40.000Z</updated>
  <id>https://blog.joouis.com/</id>
  
  <author>
    <name>John Chou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>分享一下我的内推心得，顺便招人</title>
    <link href="https://blog.joouis.com/2019/04/11/a-thought-of-referral/"/>
    <id>https://blog.joouis.com/2019/04/11/a-thought-of-referral/</id>
    <published>2019-04-10T17:35:40.000Z</published>
    <updated>2019-04-10T17:35:40.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>哈喽各位，又是金三银四的季节。今年本来不打算发帖招人，一是最近工作比较忙，二是合适的人确实不好招，已经佛系了。不过这两天水 V 站看到两个帖子有感现在发起面试其实是一件门槛很低的事，却会同时增加候选人和面试公司的无效投入，因此分享一下自己内推的心得，顺便打个广告。那两个帖子待会也会提到，但绝对不是批评或嘲讽其他大厂的面试体验不好，只是举例，我是真的看到这两个案例才想发帖的。</p><a id="more"></a><h2 id="1-发招聘帖"><a href="#1-发招聘帖" class="headerlink" title="1. 发招聘帖"></a>1. 发招聘帖</h2><p>实事求是介绍公司的情况，最重要的是走心。</p><p>一直觉得实事求是很简单，不过这两天有 Shopee 的同学发帖说自己是 965 公司，下方留言纷纷打脸，酿成翻车现场。微软在 955.WLB repo 稳居前三（好吧前三就是第三），我也不敢说微软不加班。这事还是看组，看团队，看个人发展。不过确实加班的人很少，有些还是因为跨国团队协作的原因。</p><p>我理解的走心就是与大家分享这家公司的优势所在，内推人为什么愿意在这家公司工作，比如在上一个<a href="https://www.v2ex.com/t/518252" target="_blank" rel="noopener">招聘帖</a>中详细介绍了微软会提供给员工的各种福利待遇。我乐意向大家推荐这家公司，是出自认同，同时希望找到靠谱的同事，而不是为了 KPI。</p><h2 id="2-收到候选人邮件"><a href="#2-收到候选人邮件" class="headerlink" title="2. 收到候选人邮件"></a>2. 收到候选人邮件</h2><p>手头一直有个 iPhone 的重要原因之一就是 iPhone 可以不翻墙收到 Gmail 推送。我对候选人的承诺是 24 小时之内一定会<strong>认真</strong>读完你的邮件，了解你的情况，并给出对应的回应（前提是靠谱的邮件哈，有正式一点的标题和具体的一些经历介绍，一句话之类太奇怪的邮件抱歉回不了）。</p><p>为什么这里强调认真了解候选人情况，就是我今晚看到《<a href="https://www.v2ex.com/t/553858" target="_blank" rel="noopener">谈一下 4.4 号裸辞 4.6 号来杭 开始投简历的经历</a>》，原帖楼主是 18 届的，却被内推面试蚂蚁的 Java 开发专家，p5 去面 p7 职位，这不搞笑吗？</p><p>回应一般有以下几种：</p><ul><li>劝退。是的，劝退，只是为了候选人负责。劝退时通常会解释，大厂一般都有简历系统，你面试的情况都会记录下来，如果没有十足的准备，或者你的经历距离普遍录用标准有明显的差距，就别刷负评了。</li><li>进一步了解。抱着劝退的心态了解更多细节，比如学历不好的话有没有 ACM 经历，项目经验太宽泛问问有没有一些具体的实践推动业务等亮点。</li><li>确认投递职位和兴趣爱好。确认过简历，是我们要的人，但还需要再沟通。为什么要确认职位和兴趣，是因为我们尊重候选人的想法，希望尽量能帮助候选人找到喜欢的、合适的工作内容，而不是把人骗过来干活。这个马上还会细说。</li></ul><h2 id="3-内推系统，HR-联系"><a href="#3-内推系统，HR-联系" class="headerlink" title="3. 内推系统，HR 联系"></a>3. 内推系统，HR 联系</h2><p>内推后候选人的邮箱会收到系统邮件，然后我会联系 HR 赶紧捞简历，继续评估，并与候选人联系。联系的时候可能还会给候选人几个选择，因为有职位招满关闭或是评估觉得候选人不适合此团队的情况，总之是有的选，并且 JD 都会发给候选人看，待候选人确认后，再开启面试之旅。</p><p>这里就要说到这两天另外看的一篇帖子《<a href="https://www.v2ex.com/t/553057" target="_blank" rel="noopener">shopee 即将三面的时候被告知不要我了</a>》，第一段便是</p><blockquote><p>当时想要投 web 后端，结果被推到了 devops，向 HR 告知我更想做的方向后对方也没说什么，就还是按照原来的计划面试了</p></blockquote><p>这种情况在现今找工作似乎有点常见，套路就跟看租房一样，什么半推半就、”来了再说”、”进来都好说”，我个人是非常反感。本质上这些招聘人员只是把你当做他们的业绩，却并没有考虑未来共事和人员稳定性等问题。如上面所说，在微软不太可能出现此类问题，我们会给你一个到多个选择。如果你真的不喜欢，那么通常就是再等等看别的机会，毕竟最近发展挺快的。</p><h2 id="4-面试"><a href="#4-面试" class="headerlink" title="4. 面试"></a>4. 面试</h2><p>最后，终于要开始面试了。这个环节我没啥好发挥的，也就是面试前嘱咐几句刷刷题、别紧张啥的，面试嘛本来就是一场缘分。</p><p>面试完后我会尽量帮你询问面试的反馈，当然 HR 也会给你。这个过程中会遇到一些有意思的事情，例如有位老哥面完后很有自信但结果很凉，如何向工作经验比我久很多的老哥委婉表达一些负面反馈同时照顾他的感受，是个技术活。</p><p>通常面试完后的结果不会等待太久，基本上过一两天就有了。</p><h2 id="5-职位获取渠道"><a href="#5-职位获取渠道" class="headerlink" title="5. 职位获取渠道"></a>5. 职位获取渠道</h2><p>好了废话那么多，进入正题吧(???)。通常招聘帖底下都会遇到很多人问 XX 职位招不招、X 年经验招不招，这里列了个表格给大家介绍我们近期正在招的一些职位以及对应要求。</p><p><img src="https://vq4xlg.bn.files.1drv.com/y4msrXqv1wi3A2GqY4A3cAYnMYDceCsHiW0cYO-HHHmXYfiX1UvGtirTR7TLDniugj5yV3Lw5CrSqNs0qsNp-hUQzXRZxqmstO3uJdj-2A-eEdr1VzKldgDI09UwLNIvqnOWadSSKV7070kFie3YHUTxgeDBmnq-9PA43BcMJBPCHb07mbnh89XjTSoiJyzviAWa8XsZCkFY5oaKupZ2mGazw" alt="Posted at 2019.04.11"></p><p>至于想问 XX 职位招不招的朋友们，除了可以直接问我外，也可以线访问以下两个链接查看、搜索目前开放的职位：</p><ul><li>推荐手机端查看：<a href="https://microsoft.tupu360.com/position/list?type=SOCIALRECRUITMENT" target="_blank" rel="noopener">https://microsoft.tupu360.com/position/list?type=SOCIALRECRUITMENT</a></li><li>推荐 PC 端查看：<a href="https://careers.microsoft.com/us/en/search-results?rt=professional" target="_blank" rel="noopener">https://careers.microsoft.com/us/en/search-results?rt=professional</a></li></ul><h2 id="6-联系方式"><a href="#6-联系方式" class="headerlink" title="6. 联系方式"></a>6. 联系方式</h2><p>请写信至 <code>luckyjoou ## gmail.com</code>，24 小时内必回喔~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;哈喽各位，又是金三银四的季节。今年本来不打算发帖招人，一是最近工作比较忙，二是合适的人确实不好招，已经佛系了。不过这两天水 V 站看到两个帖子有感现在发起面试其实是一件门槛很低的事，却会同时增加候选人和面试公司的无效投入，因此分享一下自己内推的心得，顺便打个广告。那两个帖子待会也会提到，但绝对不是批评或嘲讽其他大厂的面试体验不好，只是举例，我是真的看到这两个案例才想发帖的。&lt;/p&gt;
    
    </summary>
    
      <category term="技术人生谈" scheme="https://blog.joouis.com/categories/%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F%E8%B0%88/"/>
    
    
      <category term="work" scheme="https://blog.joouis.com/tags/work/"/>
    
      <category term="referral" scheme="https://blog.joouis.com/tags/referral/"/>
    
      <category term="recruit" scheme="https://blog.joouis.com/tags/recruit/"/>
    
      <category term="feedback" scheme="https://blog.joouis.com/tags/feedback/"/>
    
  </entry>
  
  <entry>
    <title>写在博客三周年</title>
    <link href="https://blog.joouis.com/2019/04/08/3rd-blog-anniversary/"/>
    <id>https://blog.joouis.com/2019/04/08/3rd-blog-anniversary/</id>
    <published>2019-04-08T14:15:38.000Z</published>
    <updated>2019-04-14T15:05:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>有的时候事情就是这么巧。比如这篇博文，不是特意为了三周年而写，而是刚好在这个时间节点博客有了一些质的变化，值得记录一下。</p><a id="more"></a><h2 id="引"><a href="#引" class="headerlink" title="引"></a>引</h2><p>起因是今年过年的泰国游，准备在博客上记录第一篇游记。一直拖到现在还没动笔，除了年后工作比较忙外，也是考虑想给博客找一个合适的图床托管图片，毕竟游记涵盖大量照片。此外偶尔也想到过距离博客搭建起来已经很久，会不会最新的版本有一些新的特性可以用到，例如支持视频、音乐播放等。</p><p>于是，在清明假期的第一天，我看了下本博客用的 <a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">NexT</a> 主题，发现都已经到了第七个版本，支持不少新特性，像是三方脚本可从 CDN 请求、支持 <code>quicklink</code>、代码可复制等等。翻着翻着，突然好奇自己的博客是从什么时候开始写的，查了下 commit，惊奇地发现是 2016.04.28，也就是说博客即将满三年咯！因此趁着假期，不如把博客好好整理、升级一下，就当三周年的纪念，也为后面书写、阅读更多内容提供更好的体验。</p><h2 id="升级思路"><a href="#升级思路" class="headerlink" title="升级思路"></a>升级思路</h2><p>关于博客是怎么搭建的当初建站之时就写了一篇<a href="https://blog.joouis.com/2016/04/09/build-a-blog-in-5-minutes/">文章</a>，后面两年多的时间里添加了评论功能、小修小补了一些地方。照理说这类静态博客的核心就是文章，只要把文章转移到新的工程里，其他的工作量主要就在于配置。</p><p>因此首先更新了 HEXO 脚手架，用脚手架生成一个最新版的工程范例。对比原有博客的工程结构，把属于内容的部分抠出来，复制到新的工程里，主要是 <code>source</code> 目录下的东西。接着对照旧版 <code>_config.yml</code> 文件，一点点把新的填好就行了。这时候在本地起个服务看看，应该要和之前的博客长得一模一样，毕竟主题没变。</p><p>然后就是更新主题了。我并没有按照官方推荐的方式通过 <code>git clone</code> 把 <code>master</code> 分支的工程拉下来，而是出于习惯在 <code>releases</code> 下载了最新版本的 <code>zip</code> 文件解压到主题目录下。考虑到之前可能魔改过一些 layout 文件，这种做法不太可取，另外新版主题也可能已经升级过一些样式细节，因此我就只对照 <code>_config.yml</code> 文件重新配置主题好了，未来哪里看着不顺眼再改。</p><p>7.1.0 版本的 NexT 主题配置文件已经有一千两百多行，内容非常的丰富，看每一个配置也是学习博客功能的过程。就这么每一个配置都看看是干嘛的，旧的里面配过没、怎么配的，然后决定新的里要怎么配。通常依赖到 hexo 第三方库的功能，要额外 <code>yarn add</code> 一下；而主题自己支持的功能，通常以 <code>theme-next-</code> 开头，其实并不用把代码放到指定的 <code>source/js/</code> 目录下，因为配置已经支持 CDN，非常的方便！</p><p>在配置博客的过程中，可以通过 <code>hexo server</code> 本地起一个服务实时查看，有的配置也是通过打开查看的方式才知道是干嘛的。完成配置后，本地生成静态资源，通过脚手架推送到 <code>gh-pages</code> 分支，线上检查是否和本地调试的结果一致。另外有些问题，如百度打点推送功能，也只有线上环境才能验证。</p><p>此外，在整个升级过程中，由于新增了分类页、主页文章列表支持预览功能等等，对原本的博客也要进行一些对应的改造。后续更换图床后还会更新图片链接，补充一些标签以便发挥”相关热门文章”功能，甚至是给一些适合的文章添加合适的音乐 ;)</p><h2 id="改善点"><a href="#改善点" class="headerlink" title="改善点"></a>改善点</h2><p>针对之前的博客，这次主要有以下更新：</p><ul><li>为每篇博文添加 Creative Common 证书，选择 <code>BY-ND</code> 而非 <code>BY-NC-ND</code> 是考虑如果我的博文能帮助别人赚到钱，那么何乐而不为呢</li><li>将所有图片从 GitHub 迁移到了 OneDrive 上，后者的 CDN 极大提升了图片的可访问性与访问速度</li><li>优化了一些 SEO 配置项，更新了蜘蛛协议的 <code>robots.txt</code>，向 Google 和百度提交了 <code>sitemap.xml</code> 文件，不知道一个月后再看数据会不会有涨幅呢</li><li>预加载页面内的链接内容，加速访问体验</li><li>侧边栏<ul><li>社交媒体全部改成图标展示，增加了邮箱链接</li><li>点击其他区域自动隐藏侧边栏</li><li>移动端文章页支持展示侧边栏</li></ul></li><li>博文<ul><li>首页支持博文预览</li><li>Meta 信息添加了博文更新时间、分类以及预计阅读时长</li><li>代码区块支持复制</li><li>添加相关热门文章阅读推荐</li><li>添加打赏娱乐功能 XD</li><li>自动对文章内容做空格处理</li></ul></li><li>优化搜索方案，从以前的 Swifttype 改成本地索引方式，感觉很不错</li><li>升级 Fancybox 版本，图片浏览体验大大增强</li><li>添加 pace 进度条，加载体验也是好很多</li><li>支持页面阅读位置保存，这个功能最早在微信公众号上体验，阅读长文时很有用</li><li>隐藏了标签菜单入口，考虑到标签几十上百种太多太杂，不如留给分类，但是保留文章内的标签展示，类似一个二级入口</li><li>支持 Aplayer 音乐播放器</li><li>添加了一个小彩蛋，希望你能发现 LOL</li></ul><h2 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h2><p>博客的升级花了大概两天的时间，一点点扣细节，既当技术又做产品，搞一个自嗨的项目，还是玩得非常开心。未来当然还是以输出文章为主，除了内容本身外，也试着丰富展现形式，达到一个比较舒服的阅读体验。最后就是博客的推广，其实建站之初只想做一个给自己看的空间，不过现在慢慢感受到，如果自己的文字能帮助到更多人，是一件正能量满满的事情。</p><p>等五周年时再看看会有什么变化吧~</p>    <div id="aplayer-vpjJZmoW" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="28737747" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86" data-mini="true"></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有的时候事情就是这么巧。比如这篇博文，不是特意为了三周年而写，而是刚好在这个时间节点博客有了一些质的变化，值得记录一下。&lt;/p&gt;
    
    </summary>
    
      <category term="技术人生谈" scheme="https://blog.joouis.com/categories/%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F%E8%B0%88/"/>
    
    
      <category term="blog" scheme="https://blog.joouis.com/tags/blog/"/>
    
      <category term="anniversary" scheme="https://blog.joouis.com/tags/anniversary/"/>
    
      <category term="hexo" scheme="https://blog.joouis.com/tags/hexo/"/>
    
      <category term="refactor" scheme="https://blog.joouis.com/tags/refactor/"/>
    
  </entry>
  
  <entry>
    <title>读书简记：《非暴力沟通》</title>
    <link href="https://blog.joouis.com/2019/01/01/reading-notes-nonviolent-communication/"/>
    <id>https://blog.joouis.com/2019/01/01/reading-notes-nonviolent-communication/</id>
    <published>2019-01-01T09:24:08.000Z</published>
    <updated>2019-01-02T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>2018 年末尾终于读完了《非暴力沟通》，之所以说“终于”是因为这本书是 15 年在台湾时一位师姐送的，当时出于某些原因一直没拆封看，但又一直没舍得送人或卖掉，就这么随我一路回到了大陆，从杭州到了苏州。18 年的下半年我开始重拾阅读的乐趣，小时候没有手机、电脑和互联网，最大乐趣之一就是读书，管它三教还是九流，只要好看我都照单全收。因此在那个时代，我从《傲慢与偏见》《简爱》《三国演义》等经典名著看到了《小兵传奇》《何以笙箫默》《诛仙》等网络小说，甚至还认识了侯龙涛、少年阿宾等人物…咳咳。</p><p>回到本书，我一开始的期望值其实非常低，有点担心它是一本“洗脑”的书（书一直是塑封状态，我没法大致翻阅）。不过开始阅读后却出乎我的意料，迅速意识到这是一本非常优秀的教材，可以帮助我们在生活中更加有效地沟通，从而推动以致达成我们的目标。书中提出了非暴力沟通的四个要素，即观察、感受、需要和请求，将它们串联起来的流程非常具备逻辑性，是一套思路清晰的沟通方法论。更具体一点说，因为我们不善于表达或带有某些情绪，经常会出现毫无意义甚至引发矛盾的沟通，这套方法论通过引导我们把话说清楚、表达更确切来达到沟通原有的积极目的。<br><a id="more"></a></p><p>书中列举了很多真实案例帮助我们理解和运用非暴力沟通技巧，还提供了一些实用的辅助练习。例如在评价一个人的时候，很显然说“欧文是个差劲的前锋”不如“欧文在过去的5场比赛中没有进一个球”更加理性客观，在谈论周遭的人或事时这种态度尤为重要。又比如父母常常会对子女说“你学习不好让我很失望”，那么真的是子女导致父母的伤心难过吗？为什么天下父母经常这么说而效果不明显？这样的表达方式给子女带来的感受是什么？</p><p>此外，随着我加入微软，了解了更多微软的新闻，惊奇地发现现任 CEO Satya 也会要求高管们阅读本书，这无疑加大了我对本书的认可度以及对微软的信心。</p><p>本书共十三章，每一章节都有一个简洁明了的小结，在此摘抄这些小结，以便未来温习与实践非暴力沟通方法时查阅。当然，也推荐给正在阅读这篇简记的读者们，希望你们掌握更加高效的沟通方式。</p><h2 id="第一章：让爱融入生活"><a href="#第一章：让爱融入生活" class="headerlink" title="第一章：让爱融入生活"></a>第一章：让爱融入生活</h2><h3 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h3><p>也许我们并不认为自己的谈话方式是“暴力”的，但我们的语言确实常常引发自己和他人的痛苦。后来，我发现了一种沟通方式，依照它来谈话和聆听，能使我们情意相通，乐于互助。我称之为“非暴力沟通”。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>非暴力沟通提醒我们专注于彼此的观察、感受、需要和请求。它鼓励倾听，培育尊重与爱，使我们情意相通，乐于互助。有些人用非暴力沟通理解自己，有些人用它改善人际关系，还有人借助它改进工作。在世界各地，非暴力沟通被用来协调各个层面的争论和冲突。</p><h2 id="第二章：是什么蒙蔽了爱？"><a href="#第二章：是什么蒙蔽了爱？" class="headerlink" title="第二章：是什么蒙蔽了爱？"></a>第二章：是什么蒙蔽了爱？</h2><h3 id="导读-1"><a href="#导读-1" class="headerlink" title="导读"></a>导读</h3><p>我从小就学着以貌似客观的语言表达自己。如果老师布置的作业我不想做，那他就“太过分了”。如果有人开车横冲到我面前，那他就是“混蛋”。如果女友想多一些体贴，那她就“太粘人了”。可是，如果我想多一些体贴，那她“冷漠得像个木头”。如果同事更关心细节，他就是“有强迫症”。反之，如果我更在乎细节，他就是“粗心大意”。</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>人天生热爱生命，乐于互助。可是，异化的沟通方式使我们难以体会到心中的爱。道德评判就是其中的一种，它将不符合我们价值观的人看作是不道德的或邪恶的。进行比较也是一种评判，它会蒙蔽对人对己的爱意。异化的沟通方式还淡化了我们对自己的思想、情感和行为的责任意识。此外，强人所难也会造成心灵的隔阂。</p><h2 id="第三章：区分观察和评论"><a href="#第三章：区分观察和评论" class="headerlink" title="第三章：区分观察和评论"></a>第三章：区分观察和评论</h2><h3 id="导读-2"><a href="#导读-2" class="headerlink" title="导读"></a>导读</h3><p>我从未见过愚蠢的孩子/我见过有个孩子有时做的事/我不理解/或不按我的吩咐做事情/但他不是愚蠢的孩子/请在你说他愚蠢之前/想一想，他是个愚蠢的孩子，还是/他懂的事情与你不一样？</p><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>非暴力沟通的第一个要素是观察。将观察和评论混为一谈，别人就会倾向于听到批评，并反驳我们。非暴力沟通是动态的语言，不主张绝对化的结论。它提倡在特定的时间和情境中进行观察，并清楚地描述观察结果。例如，它会说“欧文在过去的5场比赛中没有进一个球”，而不是说“欧文是个差劲的前锋”。</p><h2 id="第四章：体会和表达感受"><a href="#第四章：体会和表达感受" class="headerlink" title="第四章：体会和表达感受"></a>第四章：体会和表达感受</h2><h3 id="导读-3"><a href="#导读-3" class="headerlink" title="导读"></a>导读</h3><p>我在美国学校学了21年，却想不起有什么人问过我的感受。人们认为感受是无关紧要的，重要的是各种权威主张的“正确思想”。于是，我们被鼓励服从权威而非倾听自己。</p><h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>非暴力沟通的第二个要素是感受。通过建立表达感受的词汇表，我们可以更清楚地表达感受，从而使沟通更为顺畅。在表达感受时，示弱有助于解决冲突。此外，非暴力沟通还对表达具体感受的词语与陈述想法、评论以及观点的词语作了区分。</p><h2 id="第五章：感受的根源"><a href="#第五章：感受的根源" class="headerlink" title="第五章：感受的根源"></a>第五章：感受的根源</h2><h3 id="导读-4"><a href="#导读-4" class="headerlink" title="导读"></a>导读</h3><p>如果我们想利用他人的内疚，我们通常采取的办法是，把自己不愉快的感受归咎于对方。家长也许会和孩子说：“你成绩不好让爸爸妈妈伤透了心！”言下之意是，他们快乐或不快乐是孩子的行为造成的。看到父母的痛苦，孩子可能会感到内疚，并因此调整行为来迎合他们。遗憾的是，这种调整只是为了避免内疚，而非出自对学习的热爱。</p><h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><p>他人的言行也许和我们的感受有关，但并不是我们感受的起因。感受根源于我们自身的需要——非暴力沟通的第三个要素。听到不中听的话时，我们可以有四种选择：1）责备自己；2）指责他人；3）体会自己的感受和需要；4）体会他人的感受和需要。</p><p>对他人的职责、批评、评论以及分析反映了我们的需要和价值观。如果我们通过批评来提出主张，人们的反应常常是申辩或反击。反之，如果直接说出我们的需要，其他人就较有可能做出积极的响应。</p><p>社会文化并不鼓励我们揭示个人需要。对妇女来说，尤其如此。因为她们的形象常常和无私奉献联系在一起——这是社会对女性的期待。</p><p>对于大多数人来说，个人成长一般会经历三个阶段：（1）“情感的奴隶”——我们认为自己有义务使他人快乐；（2）“面目可憎”时期——此时，我们拒绝考虑他人的感受和需要；（3）“生活的主人”——我们意识到，虽然我们对自己的意愿、感受和行动负有完全的责任，但无法为他人负责。与此同时，我们还认识到，我们无法牺牲他人来满足自己的需要。</p><h2 id="第六章：请求帮助"><a href="#第六章：请求帮助" class="headerlink" title="第六章：请求帮助"></a>第六章：请求帮助</h2><h3 id="导读-5"><a href="#导读-5" class="headerlink" title="导读"></a>导读</h3><p>我们越是将他人的不顺从看作是对我们的排斥，我们所表达的愿望就越有可能被看作是命令。</p><p>一旦人们认为我们是在强迫他们，他们就会不太想满足我们的愿望。</p><h3 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h3><p>非暴力沟通的第四个要素是请求。我们告诉人们，为了改善生活，我们希望他们做什么。我们避免使用抽象的语言，而借助具体的描述，来提出请求。</p><p>在发言时，我们将自己想要的回应讲得越清楚，就越有可能得到理想的回应。由于我们所要表达的意思与别人的理解有可能不一致，有时，我们需要请求他人的反馈。特别是在集体讨论中发言时，我们需要清楚地表明自己的期待。否则，讨论可能只是在浪费大家的时间。</p><p>一旦人们认为不答应我们就会受到责罚，他们就会把我们的请求看作是命令。如果我们清楚地表达我们无意强人所难，人们一般会相信，我们提出的是请求而非命令。非暴力沟通的目的不是为了改变他人来迎合我们。相反，非暴力沟通重视每个人的需要，它的目的是帮助我们在诚实和倾听的基础上与人联系。</p><h2 id="第七章：用全身心倾听"><a href="#第七章：用全身心倾听" class="headerlink" title="第七章：用全身心倾听"></a>第七章：用全身心倾听</h2><h3 id="导读-6"><a href="#导读-6" class="headerlink" title="导读"></a>导读</h3><p>遭遇他人的痛苦时，我们常常急于提建议，安慰或表达我们的态度和感受。可是，倾听意味着全心全意地体会他人的信息——这为他人充分表达痛苦创造了条件。</p><h3 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h3><p>当他人遭遇不幸时，我们常常急于提建议，安慰，或表达我们的态度和感受。为了倾听他人，我们需要先放下已有的想法和判断，全心全意地体会对方。倾听他人有助于对他人的理解和接纳。</p><p>与此同时，不论别人用怎样的词语表达自己，我们都可以用心体会他们的观察、感受、需要和请求。有时，我们可以主动表达我们的理解，来帮助对方了解我们在何种程度上明白了他的意思。在交流的过程中，我们保持持续的关注，为对方的充分表达创造条件。</p><p>当我们痛苦得无法倾听他人时，我们需要（1）体会自己的感受和需要；（2）大声地提出请求；（3）换一个环境。</p><h2 id="第八章：倾听的力量"><a href="#第八章：倾听的力量" class="headerlink" title="第八章：倾听的力量"></a>第八章：倾听的力量</h2><h3 id="导读-7"><a href="#导读-7" class="headerlink" title="导读"></a>导读</h3><p>通过倾听，我们将意识到他人的人性以及彼此的共通之处，这会使自我表达变得容易些。</p><p>我们越是倾听他人语言背后的感受和需要，就越不怕与他们坦诚地沟通。</p><p>我们最不愿意示弱的时候往往是因为担心失去控制想显得强硬的时候。</p><h3 id="小结-7"><a href="#小结-7" class="headerlink" title="小结"></a>小结</h3><p>倾听使我们勇于面对自己的弱点。它还可以帮助我们预防潜在的暴力，使谈话生动有趣，并了解“不！”和沉默所反映的感受和需要。一次又一次，我见证了，倾听帮助人民治愈心灵的创伤。</p><h2 id="第九章：爱自己"><a href="#第九章：爱自己" class="headerlink" title="第九章：爱自己"></a>第九章：爱自己</h2><h3 id="导读-8"><a href="#导读-8" class="headerlink" title="导读"></a>导读</h3><p>我深信，出于对生命纯洁的爱，而不是出于恐惧、内疚、羞愧、职责或义务来选择生活，是爱惜自己的重要体现。</p><h3 id="小结-8"><a href="#小结-8" class="headerlink" title="小结"></a>小结</h3><p>非暴力沟通最重要的应用也许在于培育对自己的爱。当我们的表现不完美时，我们可以通过体会忧伤和自我宽恕，来看清个人成长的方向，以及避免自我惩罚。评价自己的行为时，我们专注于尚未满足的需要；这样，我们就不再依赖于羞愧、内疚、愤怒或沮丧的心理来寻求改变，而让爱主导我们的学习和成长。</p><p>同时，在日常生活中，我们主动根据需要和价值观来选择生活。我们的行为不再是为了履行职责、获得回报、逃避惩罚或避免感到内疚和羞愧。通过深入理解我们行为的动机，并用“选择做”来取代“不得不”，我们的生活将变得和谐并充满欢乐。</p><h2 id="第十章：充分表达愤怒"><a href="#第十章：充分表达愤怒" class="headerlink" title="第十章：充分表达愤怒"></a>第十章：充分表达愤怒</h2><h3 id="导读-9"><a href="#导读-9" class="headerlink" title="导读"></a>导读</h3><p>在我看来，愤怒是我们的思维方式造成的。它的核心是尚未满足的需要。</p><p>如果我们能够借助它来提醒自己——我们有需要没有得到满足，而我们的思维方式正使它难以得到满足，那愤怒就是有价值的。</p><h3 id="小结-9"><a href="#小结-9" class="headerlink" title="小结"></a>小结</h3><p>在生气时，批评和指责他人都无法真正传达我们的心声。如果想充分表达愤怒，我们就不能归咎于他人，而把注意力放在自己的感受和需要上。与批评和指责他人相比，直接说出我们的需要更有可能使我们的愿望得到满足。</p><p>表达愤怒的四个步骤是：（1）停下来，除了呼吸，什么都别做；（2）想一想是什么想法使我们生气了；（3）体会自己的需要；（4）表达感受和尚未满足的需要。有时，在第3步和第4步之间，我们需要先倾听他人。在得到倾听和理解之后，他们也就可以静下心来体会我们的感受和需要。</p><p>我们需要给自己充分的时间来学习和运用非暴力沟通。</p><h2 id="第十一章：运用强制力避免伤害"><a href="#第十一章：运用强制力避免伤害" class="headerlink" title="第十一章：运用强制力避免伤害"></a>第十一章：运用强制力避免伤害</h2><h3 id="导读-10"><a href="#导读-10" class="headerlink" title="导读"></a>导读</h3><p>我们都知道，惩罚将导致关系的疏远。一旦我们被看作是施暴的人，我们就很难得到友善的回应。</p><h3 id="小结-10"><a href="#小结-10" class="headerlink" title="小结"></a>小结</h3><p>在有些情形中，我们没有机会和他人交流，这时，我们也许需要使用强制力来保护自己和他人。我们这样做，是为了避免伤害，而不是为了惩罚他人。如果我们威胁他人或实施惩罚，人们常常会产生敌意和抵触心理。这样，彼此的关系将会疏远。同时，惩罚还可能使人忽视事情本身的意义，而把注意力放在不服从的后果上。如果我们试图通过惩罚来使人们认识自己的需要，那么，我们很可能适得其反。</p><h2 id="第十二章：重获生活的热情"><a href="#第十二章：重获生活的热情" class="headerlink" title="第十二章：重获生活的热情"></a>第十二章：重获生活的热情</h2><h3 id="导读-11"><a href="#导读-11" class="headerlink" title="导读"></a>导读</h3><p>通过运用非暴力沟通，我们不再试图分析自己或他人有什么毛病，而是用心去了解我们的需要，这样，我们的内心将逐渐变得平和。</p><h3 id="小结-11"><a href="#小结-11" class="headerlink" title="小结"></a>小结</h3><p>在情绪低落的时候，我们也许会怨天尤人。然而，如果我们以苛刻的态度对人对己，我们的心情也好不到哪里去。通过运用非暴力沟通，我们不再试图分析自己或他人有什么毛病，而是用心去了解我们的需要，这样，我们的内心将逐渐变得平和。一旦我们发现自己心底深处的愿望，并采取积极的行动，我们将会重获生活的热情。心理咨询和心理治疗行业的从业人员可以考虑借助非暴力沟通来与来访者进行坦诚的交流。</p><h2 id="第十三章：表达感激"><a href="#第十三章：表达感激" class="headerlink" title="第十三章：表达感激"></a>第十三章：表达感激</h2><h3 id="导读-12"><a href="#导读-12" class="headerlink" title="导读"></a>导读</h3><p>有一天晚上，当我向我的儿子布莱特指出他没做好家务活时，他反驳说：“爸，你想想，你是不是倾向于指出问题，而很少肯定我？”他的话在我脑海中盘绕了许久。</p><h3 id="小结-12"><a href="#小结-12" class="headerlink" title="小结"></a>小结</h3><p>在赞扬他人时，我们很少揭示内心活动，而把自己放在了裁判的位置。赞扬也常常被人用来实现个人目的。非暴力沟通鼓励我们充分表达感激。在表达感激时，我们说出：（1）对我们有益的行为；（2）我们的哪些需要得到了满足；（3）我们的需要得到满足后，我们是什么样的心情。</p><p>当别人以这样的方式表达对我们的感激时，我们可以与对方一起庆祝生命的美——既不自大，也不假谦虚。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2018 年末尾终于读完了《非暴力沟通》，之所以说“终于”是因为这本书是 15 年在台湾时一位师姐送的，当时出于某些原因一直没拆封看，但又一直没舍得送人或卖掉，就这么随我一路回到了大陆，从杭州到了苏州。18 年的下半年我开始重拾阅读的乐趣，小时候没有手机、电脑和互联网，最大乐趣之一就是读书，管它三教还是九流，只要好看我都照单全收。因此在那个时代，我从《傲慢与偏见》《简爱》《三国演义》等经典名著看到了《小兵传奇》《何以笙箫默》《诛仙》等网络小说，甚至还认识了侯龙涛、少年阿宾等人物…咳咳。&lt;/p&gt;
&lt;p&gt;回到本书，我一开始的期望值其实非常低，有点担心它是一本“洗脑”的书（书一直是塑封状态，我没法大致翻阅）。不过开始阅读后却出乎我的意料，迅速意识到这是一本非常优秀的教材，可以帮助我们在生活中更加有效地沟通，从而推动以致达成我们的目标。书中提出了非暴力沟通的四个要素，即观察、感受、需要和请求，将它们串联起来的流程非常具备逻辑性，是一套思路清晰的沟通方法论。更具体一点说，因为我们不善于表达或带有某些情绪，经常会出现毫无意义甚至引发矛盾的沟通，这套方法论通过引导我们把话说清楚、表达更确切来达到沟通原有的积极目的。&lt;br&gt;
    
    </summary>
    
      <category term="读书简记" scheme="https://blog.joouis.com/categories/%E8%AF%BB%E4%B9%A6%E7%AE%80%E8%AE%B0/"/>
    
    
      <category term="communication" scheme="https://blog.joouis.com/tags/communication/"/>
    
      <category term="nonviolent communication" scheme="https://blog.joouis.com/tags/nonviolent-communication/"/>
    
      <category term="efficiency" scheme="https://blog.joouis.com/tags/efficiency/"/>
    
      <category term="empathy" scheme="https://blog.joouis.com/tags/empathy/"/>
    
  </entry>
  
  <entry>
    <title>阿里，江湖再见</title>
    <link href="https://blog.joouis.com/2018/11/13/goodbye-alibaba/"/>
    <id>https://blog.joouis.com/2018/11/13/goodbye-alibaba/</id>
    <published>2018-11-12T17:34:13.000Z</published>
    <updated>2018-11-12T17:34:13.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>还记得刚来阿里听到“一年香，三年陈，五年醇”的说法时，内心想着一定要至少待满五年再走；也还记得在争取转岗时，感到前途一片迷茫，每天都不想来上班，但也没想过要离开阿里。然而此时，精神上非常享受现在工作的我，身体扛不住了，不得不先离开这片江湖。</p><p>于是，感恩在阿里的这八百余天，如同老人们一样，写下这篇离职帖作为告别吧。<br><a id="more"></a></p><p>我于 16 年作为应届生加入阿里，那会在台湾读硕士，为毕业论文挣扎，错过了国内的秋招。16 年春的时候，经若远师兄内推加入了阿里。<a href="https://blog.joouis.com/2018/01/13/interviews-for-the-offer-of-alibaba/">过程其实很曲折，技术面面了 7 轮，全是电话和视频面，差点就挂了</a>，感谢最后峰哥和珈夜给我机会，把我带进了阿里的大门，也让我进入了互联网行业。</p><p>我此前一直从事嵌入式相关的开发，来阿里前以为做 ARM Trustzone 相关的东西，结果没想到入职第一天便“拥抱变化”转行做了 Web 前端开发（还不是特别互联网的那种），所在小组的主要产品是基于 Atom (Electron) 二次开发的 YunOS IDE。那段日子过得比较苦，没有产品、设计资源，除了技术开发，需求梳理、外观设计包括后面的客服答疑都得自己来，同时我之前一直是 Terminal + VIM 党，IDE 相关的业务背景为 0，加上前端储备几乎为 0…这里必须要感谢第一任主管晓璐给了我很长一段时间适应和学习，至少在着陆时没有脑袋直接着地，连滚带爬还能往前苟活。</p><p>那会我个人的状态不好，YunOS 部门状态更差：看不清方向，看不到未来，项目说做就做、说停就停，CEO 发给全员的邮件里自己打 3.25，接着整个 BU 3.25。更可怕的是，YunOS 给人一种强烈的国企氛围，都烂成这样了，各个群里都还是随缘点赞的祥和氛围，除了开始有人陆续离开。作为一名 Web 前端开发，我当时危机感特别强，也在犹豫要不要继续干前端。大家都说你很聪明，技术功底不错，但你没法拿出事实证明自己！开发吃的是技术饭，而小组那会情况很不理想：UI 框架在 2017 年上半年才玩了半年 Vue，之前是 Backbone，React 在后来才被少数模块使用；Node 服务莫名采用了针对淘系业务产出的 Midway.js 框架，diamond 是啥不知道，就看日志里打了一堆东西；没人搞明白 SSR 和 VM，乱用模板引擎；没有文件版本号维度管理；没人关注性能优化；缺少自动化代码打包、构建、发布 CDN 等一整套完整的流程；没有自适应和无线端开发的业务和经验；等等。</p><p>这里并非指责任何人和事，毕竟时间过去那么久，已然成为一段经历。只想说明当时的我意识到太多问题，慌了！想了很久，决定在入职不满一年的情况下尝试转岗，去业务第一线，继续做前端。</p><p>转岗给了我很大的信心，聊过的几个团队都愿意接受我，这让我很感动。但卡住我的最大问题是入职未满两年，以及 YunOS 那会“号称”冻结转岗（因为大家没见到集团的通知，都是口口相传）。最终在珈夜的沟通与帮助下，“抗争”了几个月，我在 17 年底终于加入 Lazada 卖家团队。</p><p>Lazada 的工作量非常大在加入前就早有耳闻，那会打听的时候就有好几个人劝不要来，但我就想好好体验一把“地狱模式”，弥补过去一年成长的缓慢。而给我这个机会的是现任主管 Tank 和大老板 Gary。Gary 作为男神级人物，老阿里人，82 年的 P9，业务思考、团队管理、沟通能力都让人十分佩服。而 Tank 则是让我义无反顾愿意加入的理由。试想今天有一位候选人与你联系想主动转岗，但受限于集团政策，你会怎么办？大多数 TL 都是友好而简洁地表示以后有机会再联系，这合情合理。但 Tank 和我说了不少关于工作上的建议，即便我不能过去，但依然非常诚恳、希望能帮助我。当然除了有情有义，他也年轻有为，28 岁加入阿里时就是 P7，带过团队。事实证明这个选择没有错，卖家团队配置齐全、高手如云、比较团结。在与产品、设计、后端以及客户端同学的配合切磋中，在各种业务场景和技术方案的高压下，我被虐得很爽，感受到了成长的滋味。此外对内与多个部门合作、对外响应多国的业务同学甚至用户，着实打开了我的眼界。可以这么说，在 Lazada 的这段时光，才让我有种真正进入阿里的感觉。</p><p>然而在精神非常享受的时候，我的身体却有点跟不上节奏了。颈椎问题以往晚上才会开始冰凉刺痛，现在刚到下午就开始提醒我要活动一下。此外由于免疫力下降，最近几个月皮肤出了一些问题，目前还好，但看了网上一些病情严重的案例，有点被吓到。再加上之前赤铁去世的事，让我很震惊，他是我进阿里的面试官之一，一位正值壮年的前辈就这么走了，这件事又令我想了很久。</p><p>我决定离开，去外企，多一点个人时间休养身心。</p><p>离开的第一个原因上面已经说了，第二个原因是我不喜欢余杭。虽说很多同事在周边买了房，但我始终认为余杭配不上阿里。环境，素质，基建，房价，哪一个拿得出手？但这种地域黑的观点说出来难免被喷，就到此为止。</p><p>得益于在 Lazada 扎实的工作经历和技术打磨，我在裸面的情况下把想拿的 Offer 基本上都拿到了，最终选择去微软亚洲工程院做机器学习相关的事。选微软其实很简单，一是即使现在中国互联网盛行、外企的人才竞争力下降，但王坚博士等一票优秀的前辈都是从那里出来（不过不少是从 MSRA 来的）滋润了阿里，我想去看看；二是刚好有个机会可以从工程角度再次接触人工智能方面的东西，我也想往这个方向看看，同时不会和互联网行业太脱节。</p><p>两年的时光过得太快，经历了许多。现在回头想想，纵使是出了非常多幺蛾子、见识了不少奇葩，也都是满满的人生收获。除了专业和心智上的成长外，最珍贵的就是认识了一帮优秀的同学，有前面提过的一些前辈，也有许多同龄人。珈夜、瀚雷、卖家团队的前端小伙伴们、YunOS 相互取暖的基友们、畅谈技术的三哥、给我抛过橄榄枝的剑翘、羽括等等等等，是你们让我感受到了“一群有情有义的人，在一起做有价值的事情”。</p><p>阿里这个大平台使我们相识相聚，就让我们江湖再见吧。</p>    <div id="aplayer-JYFqvhnL" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="1439534" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86" data-mini="true"></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;还记得刚来阿里听到“一年香，三年陈，五年醇”的说法时，内心想着一定要至少待满五年再走；也还记得在争取转岗时，感到前途一片迷茫，每天都不想来上班，但也没想过要离开阿里。然而此时，精神上非常享受现在工作的我，身体扛不住了，不得不先离开这片江湖。&lt;/p&gt;
&lt;p&gt;于是，感恩在阿里的这八百余天，如同老人们一样，写下这篇离职帖作为告别吧。&lt;br&gt;
    
    </summary>
    
      <category term="技术人生谈" scheme="https://blog.joouis.com/categories/%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F%E8%B0%88/"/>
    
    
      <category term="leave" scheme="https://blog.joouis.com/tags/leave/"/>
    
  </entry>
  
  <entry>
    <title>2018 年 JavaScript 测试概观</title>
    <link href="https://blog.joouis.com/2018/10/29/an-overview-of-javascript-testing-in-2018/"/>
    <id>https://blog.joouis.com/2018/10/29/an-overview-of-javascript-testing-in-2018/</id>
    <published>2018-10-29T13:26:06.000Z</published>
    <updated>2018-12-13T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote><p>源文链接：<a href="https://medium.com/welldone-software/an-overview-of-javascript-testing-in-2018-f68950900bc3" target="_blank" rel="noopener">An Overview of JavaScript Testing in 2018</a></p></blockquote><p><strong>摘要：使用 Jest 进行单元和集成测试，使用 TestCafe 进行 UI 测试。</strong><br><a id="more"></a></p><h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>看看 Facebook 推出的测试框架 Jest 的 logo：</p><p><img src="https://ua6ucg.bn.files.1drv.com/y4mzt4dGxfvhghwHmJ1cOG61-jm4I3sK7rl1JeHhEqMY9t8bKW2Ednwn7ntduQywMmbQ6WAA0aKyvkcuTySVHOV4mgEJG8jxro9Cowdfi_oi8PBPK7A8muv2Rfq5rUQ4KAYyucW79coT9KXdQBtOvfTgIrhI0x2b-sIuloCLvSrNnNMXGJ3UoulMDRbZ2mSAuvL_HX5-kdXVt0fKl7GcvhTTg" alt></p><p>你可以看到他们的口号承诺“无痛”地进行 JavaScript 测试，然而“<a href="https://news.ycombinator.com/item?id=13128146#13128900" target="_blank" rel="noopener">评论中的某些人</a>”指出：</p><p><img src="https://uq63cg.bn.files.1drv.com/y4mBInnhjMSj7yDXlFnklP4Ts-MyNAfN0ptQlUnrBzA5yEC2mA2vP4uxB347fuh86GLCNnQJwqNuQgvkCcLWqoW3ZdOrnS-tAJO4fbma7Ri8cE2kbu2c3EAl4jXPiyobqVKhrSb6gLuqG8UTlLuBAuw3vJ2jAqhjKktMsZn867h0MyMk_oyA_hRLbmSjUh8WGaeAtPPt90-dHU-znudYdueZA" alt></p><p>不过 Facebook 确实有一个很棒的理由使用这个口号。通常 JS 开发者都<a href="http://2016.stateofjs.com/2016/testing/" target="_blank" rel="noopener">不太喜欢网站测试</a>，JS 测试意味着受限制、很难实现、进度缓慢且时而代价昂贵。尽管如此，只要使用正确的策略和正确的工具组合，一次接近全覆盖的测试也可以完成得有组织、简单并相对快速。</p><h2 id="测试的类型"><a href="#测试的类型" class="headerlink" title="测试的类型"></a>测试的类型</h2><p>你可以通过<a href="http://stackoverflow.com/questions/520064/what-is-unit-test-integration-test-smoke-test-regression-test" target="_blank" rel="noopener">这里</a>、<a href="https://www.sitepoint.com/javascript-testing-unit-functional-integration/" target="_blank" rel="noopener">这里</a>以及<a href="https://codeutopia.net/blog/2015/04/11/what-are-unit-testing-integration-testing-and-functional-testing/" target="_blank" rel="noopener">这里</a>更深入地了解不同的测试类型。大体上，对于一个网站来说，最重要的几类测试有：</p><ul><li><strong>单元测试 (Unit Tests)</strong>：通过输入和预期的输出结果测试独立的函数或者类；</li><li><strong>集成测试 (Integration Tests)</strong>：测试流程或组件的表现是否符合预期，包括副作用；</li><li><strong>UI 测试 (UI Test)</strong>（又名<strong>功能测试 (Functional Tests)</strong>）：在浏览器中对产品进行一些使用场景测试，无视其内部结构，只保证行为符合预期。</li></ul><h2 id="测试工具的类型"><a href="#测试工具的类型" class="headerlink" title="测试工具的类型"></a>测试工具的类型</h2><p>测试工具可以划分为以下功能类型，其中一些提供单一功能，而另一些则提供功能组合。为了功能性更加灵活，使用组合工具也很常见，即使存在一款工具可以实现类似的功能。</p><ol><li>提供一个<strong>测试结构 (testing structure)</strong> (<a href="https://mochajs.org/" target="_blank" rel="noopener">Mocha</a>, <a href="http://jasmine.github.io/" target="_blank" rel="noopener">Jasmine</a>, <a href="https://facebook.github.io/jest/" target="_blank" rel="noopener">Jest</a>, <a href="https://github.com/cucumber/cucumber-jshttps://github.com/cucumber/cucumber-js" target="_blank" rel="noopener">Cucumber</a>)</li><li>提供<strong>断言函数 (assertions functions)</strong> (<a href="http://chaijs.com/" target="_blank" rel="noopener">Chai</a>, <a href="http://jasmine.github.io/" target="_blank" rel="noopener">Jasmine</a>, <a href="https://facebook.github.io/jest/" target="_blank" rel="noopener">Jest</a>, <a href="http://unexpected.js.org/" target="_blank" rel="noopener">Unexpected</a>)</li><li>生成、<strong>展示 (display) 并观察 (watch)</strong>测试结果 (<a href="https://mochajs.org/" target="_blank" rel="noopener">Mocha</a>, <a href="http://jasmine.github.io/" target="_blank" rel="noopener">Jasmine</a>, <a href="https://facebook.github.io/jest/" target="_blank" rel="noopener">Jest</a>, <a href="https://karma-runner.github.io/" target="_blank" rel="noopener">Karma</a>)</li><li>生成并对比组件和数据结构的<strong>快照 (snapshots)</strong>确保早先运行中的变化符合预期 (<a href="https://facebook.github.io/jest/" target="_blank" rel="noopener">Jest</a>, <a href="https://github.com/avajs/ava" target="_blank" rel="noopener">Ava</a>)</li><li>提供 <strong>mocks</strong>、<strong>spies</strong> 和 <strong>stubs</strong> (<a href="http://sinonjs.org/" target="_blank" rel="noopener">Sinon</a>, <a href="http://jasmine.github.io/" target="_blank" rel="noopener">Jasmine</a>, <a href="http://airbnb.io/enzyme/docs/api/" target="_blank" rel="noopener">enzyme</a>, <a href="https://facebook.github.io/jest/" target="_blank" rel="noopener">Jest</a>, <a href="https://github.com/testdouble/testdouble.js" target="_blank" rel="noopener">testdouble</a>)</li><li>生成<strong>代码覆盖 (code coverage)</strong> 报告 (<a href="https://gotwarlost.github.io/istanbul/" target="_blank" rel="noopener">Istanbul</a>, <a href="https://facebook.github.io/jest/" target="_blank" rel="noopener">Jest</a>, <a href="http://blanketjs.org/" target="_blank" rel="noopener">Blanket</a>)</li><li>提供<strong>浏览器或近似浏览器环境 (browser or browser-like environment)</strong> 并可以在场景执行时进行控制 (<a href="http://www.protractortest.org/" target="_blank" rel="noopener">Protractor</a><strong>,</strong> <a href="http://nightwatchjs.org/" target="_blank" rel="noopener">Nightwatch</a>, <a href="http://phantomjs.org/" target="_blank" rel="noopener">Phantom</a><strong>,</strong> <a href="http://casperjs.org/" target="_blank" rel="noopener">Casper</a>)</li></ol><p>让我们解释上述提到的一些术语：</p><p><strong>测试结构</strong>指的是测试的组织方式。如今测试经常被组织成支持<a href="https://en.wikipedia.org/wiki/Behavior-driven_development" target="_blank" rel="noopener">行为驱动开发</a> (behavior-driven development) 的 <strong>BDD 结构 (BDD structure)</strong> 。通常看起来像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'calculator'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 使用嵌套 "describe" 函数描述一个模组</span></span><br><span class="line">  describe(<span class="string">'add'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 详述预期行为</span></span><br><span class="line">    it(<span class="string">'should add 2 numbers'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="comment">// 使用断言函数测试预期行为</span></span><br><span class="line">       ...  </span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>断言函数</strong>确保被测试的变量包含预期值。它们通常看起来像这样，其中最流行的写法莫过于前两种方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Chai expect (流行)</span></span><br><span class="line">expect(foo).to.be.a(<span class="string">'string'</span>)</span><br><span class="line">expect(foo).to.equal(<span class="string">'bar'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Jasmine expect (流行)</span></span><br><span class="line">expect(foo).toBeString()</span><br><span class="line">expect(foo).toEqual(<span class="string">'bar'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Chai assert</span></span><br><span class="line">assert.typeOf(foo, <span class="string">'string'</span>)</span><br><span class="line">assert.equal(foo, <span class="string">'bar'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unexpected expect</span></span><br><span class="line">expect(foo, <span class="string">'to be a'</span>, <span class="string">'string'</span>)</span><br><span class="line">expect(foo, <span class="string">'to be'</span>, <span class="string">'bar'</span>)</span><br></pre></td></tr></table></figure><p><em>TIP: 这里有一篇关于进阶的 Jasmine 断言<a href="https://medium.com/@boriscoder/the-hidden-power-of-jest-matchers-f3d86d8101b0" target="_blank" rel="noopener">好文</a>。</em></p><p><strong><a href="http://sinonjs.org/releases/v2.1.0/spies/" target="_blank" rel="noopener">Spies</a></strong> 提供了函数相关的信息：函数被调用了多少次，在什么情况下被调用，被谁调用？在集成测试中我们会使用它确保一个流程中的副作用符合预期，例如在下列场景中观察该方法是否只执行了一次？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">'should call method once with the argument 3'</span>, () =&gt; &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 创建一个 sinon spy 来监视 object.method</span></span><br><span class="line">  <span class="keyword">const</span> spy = sinon.spy(object, <span class="string">'method'</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 调用方法，入参为 "3"</span></span><br><span class="line">  object.method(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 确保在入参正确的情况下 object.method 只被调用了一次</span></span><br><span class="line">  assert(spy.withArgs(<span class="number">3</span>).calledOnce)</span><br><span class="line">  </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><a href="http://sinonjs.org/releases/v4.2.2/stubs/" target="_blank" rel="noopener"><strong>Stubbing</strong> 或 <strong>dubbing</strong></a> （好比电影中的替身演员）通过<strong>替换选中的函数</strong>来测试模块的正确性。如果我们在测试另外的组件时希望 <code>user.isValid()</code> 总是返回 <code>true</code>，可以这么做：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sinon</span></span><br><span class="line">sinon.stub(user, <span class="string">'isValid'</span>).returns(<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Jasmine stubs 实际是有 stubbing 功能的 spies</span></span><br><span class="line">spyOn(user, <span class="string">'isValid'</span>).andReturns(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure><p>也可以使用 promise 的方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">'resolves with the right name'</span>, done =&gt; &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 确保 User.fetch "回复"的是我们配置的值"David"</span></span><br><span class="line">  <span class="keyword">const</span> stub = sinon</span><br><span class="line">    .stub(User.prototype, <span class="string">'fetch'</span>)</span><br><span class="line">    .resolves(&#123; <span class="attr">name</span>: <span class="string">'David'</span> &#125;)</span><br><span class="line">  </span><br><span class="line">  User.fetch()</span><br><span class="line">    .then(<span class="function"><span class="params">user</span> =&gt;</span> &#123;</span><br><span class="line">      expect(user.name).toBe(<span class="string">'David'</span>)</span><br><span class="line">      done()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><a href="http://sinonjs.org/releases/v4.2.2/mocks/" target="_blank" rel="noopener"><strong>Mocks</strong> 或 <strong>Fakes</strong></a> 通过<strong>伪装成某些模块或行为</strong>测试一系列过程中的不同情况。举例来说，Sinon 能<a href="http://sinonjs.org/releases/v4.2.2/fake-xhr-and-server/" target="_blank" rel="noopener">仿冒一个服务器</a>离线和网络状况良好的情况来测试期望的应答。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">'returns an object containing all users'</span>, done =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建并配置一个假的服务器取代原生的网络请求</span></span><br><span class="line">  <span class="keyword">const</span> server = sinon.createFakeServer()</span><br><span class="line">  server.respondWith(<span class="string">'GET'</span>, <span class="string">'/users'</span>, [</span><br><span class="line">    <span class="number">200</span>,</span><br><span class="line">    &#123; <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span> &#125;,</span><br><span class="line">    <span class="string">'[&#123; "id": 1, "name": "Gwen" &#125;,  &#123; "id": 2, "name": "John" &#125;]'</span></span><br><span class="line">  ])</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用一个包含我们模拟网络请求的流程</span></span><br><span class="line">  Users.all()</span><br><span class="line">    .done(<span class="function"><span class="params">collection</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> expectedCollection = [</span><br><span class="line">        &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">'Gwen'</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">'John'</span> &#125;</span><br><span class="line">      ]</span><br><span class="line">      expect(collection.toJSON()).to.eql(expectedCollection)</span><br><span class="line">      done()</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 响应请求</span></span><br><span class="line">  server.respond()</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 移除假服务器</span></span><br><span class="line">  server.restore()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>快照测试 (Snapshot Testing)</strong> 会对某一数据结构与期望值进行比较。<a href="https://facebook.github.io/jest/docs/en/snapshot-testing.html" target="_blank" rel="noopener">下面的例子来自 Jest 官方文档</a>，展示了某一 <code>Link</code> 组件的快照测试。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">'renders correctly'</span>, () =&gt; &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 创建一个包含页面链接和内部文字的 Link 组件实例</span></span><br><span class="line">  <span class="keyword">const</span> linkInstance = (</span><br><span class="line">    &lt;Link page=<span class="string">"http://www.facebook.com"</span>&gt;Facebook&lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ 创建一个组件的数据快照</span></span><br><span class="line"><span class="regexp">  const tree = renderer.create(linkInstance).toJSON()</span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ 比较数据和上一次快照</span></span><br><span class="line"><span class="regexp">  expect(tree).toMatchSnapshot()</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br></pre></td></tr></table></figure><p>在此过程中不会真正渲染该组件并截图，而是在一个独立的文件中保存其内部数据结构，大概长这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">exports[<span class="string">`renders correctly 1`</span>] = <span class="string">`</span></span><br><span class="line"><span class="string">&lt;a</span></span><br><span class="line"><span class="string">  className="normal"</span></span><br><span class="line"><span class="string">  href="http://www.facebook.com"</span></span><br><span class="line"><span class="string">  onMouseEnter=&#123;[Function]&#125;</span></span><br><span class="line"><span class="string">  onMouseLeave=&#123;[Function]&#125;</span></span><br><span class="line"><span class="string">&gt;</span></span><br><span class="line"><span class="string">  Facebook</span></span><br><span class="line"><span class="string">&lt;/a&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure><p>当新产生的快照与上一次不同时，将提示开发者是否同意此次改动是有意为之。</p><p><img src="https://uq62cg.bn.files.1drv.com/y4mTfqnysoW01bKk4CWz60Y2v43G_VRxvulJeWDZklZz0IJY5Bs-Vjxkn1ALXo8Jp5jMsm6e2_4gJiQ5nRu8UEHRvZfU_xKZ_mFYaAcwd4bpWB5b7l0ySjfzhlQx84BTU3dMQZ-g7Z-4WmvjjxQUBg-I_TJ5sHhDU9QJ3SOXbHQDGej28ivoAikmDz3Cn9P30gQqGE5PjxVoc25P7oIgp7Lrg" alt></p><blockquote><p><strong>注意：</strong>快照通常用来比对体现数据的组件，其实它们也可以比较其他的数据类型，如 redux stores 或应用中不同单元的内部结构。</p></blockquote><p><strong>浏览器或近似浏览器环境</strong>可以是以下三种之一：</p><ul><li><a href="https://github.com/jsdom/jsdom" target="_blank" rel="noopener"><strong>jsdom</strong></a> —— 一个模拟真实浏览器的纯 JavaScript 环境。它没有 UI 也不做渲染，只提供浏览器 JS 运行时所需的 window, document, body, location, cookies, selectors 等接口。</li><li><strong>无头浏览器环境 (Headless Browser Environment)</strong> —— 一个为了响应速度更快而缺省 UI 的浏览器。</li><li><strong>真实浏览器环境 (Real Browser Environment)</strong> —— 一个运行你测试用例的真实浏览器。</li></ul><h2 id="把所有东西放在一起…"><a href="#把所有东西放在一起…" class="headerlink" title="把所有东西放在一起…"></a>把所有东西放在一起…</h2><p>如果可以，我们建议面对所有测试类型都使用同一套工具：相同的<strong>测试结构和语法 (1)</strong>、<strong>断言函数 (2)</strong>、<strong>结果报告</strong>以及<strong>监控机制 (4)</strong>。</p><p>我们还建议创建两类不同的流程，一类运行单元和集成测试，另一类则运行 UI 测试。这是因为 UI 测试需要耗费更长的时间，尤其在跨浏览器测试时通常会使用外部提供的多设备、多浏览器付费服务（这个后续还会讨论），因此相比第一类流程你不会想跑更多的 UI 测试，譬如只在合并一条特征分支前才运行一次。</p><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>应当覆盖应用中所有小而纯粹的单元：工具 (utils)、服务 (services) 以及助手 (helpers)。给这些单元简单和边界情况的输入并<strong>使用断言函数 (3)</strong> 确保输出正确。另外也需要使用<strong>覆盖率报告工具 (6)</strong> 了解哪些单元被测试到了。</p><blockquote><p>单元测试是尽可能使用函数式编程以及纯函数的理由之一——你的应用越纯粹就越容易被测试。</p></blockquote><h3 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h3><blockquote><p>老派的测试往往注重单元测试，这导致了应用的各个微观部分功能正常，但是所有流程合在一起时就会出错。</p><p>当你修复了某个问题，但是又破坏了其他部分时，集成测试（包含快照）可以从另一个角度捕捉许多未知的错误。</p><p>同样需要记住的是，在这个真实的世界存在因各种理由而出现的不完美的设计和广泛应用的黑盒子，并不是所有单元模块都是纯函数，也不是所有单元都可以被测试——有一些单元仅作为某个更大流程中的一部分而能被测试到。</p></blockquote><p>集成测试需要覆盖重要的跨模组流程。相较于单元测试，你可能会使用 <strong>spies (5)</strong> 确保一些预期的副作用而非只对输出做断言，同时使用 <strong>stubs (5)</strong> 模拟、修改在特定测试中不存在的部分流程。</p><p>并且与单元测试相反，<strong>一个浏览器或近似浏览器环境 (7)</strong> 可以支持依赖 <code>window</code> 、渲染某一组件或与组件交互的各种流程。</p><p><strong>组件快照测试 (4)</strong> 也属于此类测试。它们提供了一种无需真实渲染或使用浏览器就可以测试流程对选中组件影响的方式。</p><h3 id="UI-测试"><a href="#UI-测试" class="headerlink" title="UI 测试"></a>UI 测试</h3><p>有时候快速高效的单元和集成测试还不够。</p><p>UI 测试总是运行在<strong>一个浏览器或近似浏览器环境 (7)</strong> 中，模拟用户行为（点击，输入，滚动等等…），确保这些场景在终端用户眼中确实工作。</p><p>请记住这类测试是最难准备的。设想你自己创建一个环境在不同的机器、设备、浏览器类型和版本上运行一个测试… 这就是为什么有<a href="https://www.keycdn.com/blog/browser-compatibility-testing-tools" target="_blank" rel="noopener">很多服务商</a>为你提供这项服务。<a href="https://www.guru99.com/top-10-cross-browser-testing-tools.html" target="_blank" rel="noopener">你还可以在这里发现更多</a>。</p><h3 id="常见的知名测试工具"><a href="#常见的知名测试工具" class="headerlink" title="常见的知名测试工具"></a>常见的知名测试工具</h3><h4 id="Jsdom"><a href="#Jsdom" class="headerlink" title="Jsdom"></a><a href="https://github.com/jsdom/jsdom" target="_blank" rel="noopener">Jsdom</a></h4><p>jsdom 是 WHATWG DOM 和 HTML 标准的一个 JavaScript 实现。换言之 jsdom 仅用纯 JS 模拟了一个浏览器环境。之前提过，在这样的模拟浏览器环境中，测试运行的速度十分快。缺点则是在一个真实浏览器之外 jsdom 无法模拟所有功能，因此这会限制你的测试范围。</p><p>值得一提的是 JS 社区很快改进了它，目前的版本已经非常接近真实浏览器。</p><h4 id="Istanbul"><a href="#Istanbul" class="headerlink" title="Istanbul"></a><a href="https://istanbul.js.org/" target="_blank" rel="noopener">Istanbul</a></h4><p>Istanbul 会告诉你有多少代码被单元测试所覆盖。它通过报告状态、行数、函数和分支覆盖维度的百分比情况以便你更好地理解哪些部分代码没有被覆盖到。</p><h4 id="Karma"><a href="#Karma" class="headerlink" title="Karma"></a><a href="https://karma-runner.github.io/2.0/index.html" target="_blank" rel="noopener">Karma</a></h4><p>Karma 允许你在浏览器和近似浏览器环境甚至 jsdom 中进行测试。它运行的<strong>测试服务器有一个特殊网页</strong>可以让你的测试运行在页面环境中，而这个页面还可以跨浏览器运行。这也意味着测试可以通过 <a href="https://www.browserstack.com/" target="_blank" rel="noopener">BrowserStack</a> 之类的服务远程执行。</p><h4 id="Chai"><a href="#Chai" class="headerlink" title="Chai"></a><a href="https://github.com/chaijs/chai" target="_blank" rel="noopener">Chai</a></h4><p>Chai 是最流行的断言库。<em>（译者注：此处人狠话不多）</em></p><h4 id="Unexpected"><a href="#Unexpected" class="headerlink" title="Unexpected"></a><a href="https://github.com/unexpectedjs/unexpected" target="_blank" rel="noopener">Unexpected</a></h4><p>Unexpected 是一个与 Chai 的语法稍有不同的断言库。其可扩展性衍生出了一些使断言功能更高级的库例如 <a href="https://github.com/bruderstein/unexpected-react" target="_blank" rel="noopener">unexpected-react</a> ，你可以从<a href="https://medium.com/@bruderstein/enzyme-vs-unexpected-react-ee9cb099d12b" target="_blank" rel="noopener">这里</a>了解更多。</p><h4 id="Sinon-js"><a href="#Sinon-js" class="headerlink" title="Sinon.js"></a><a href="http://sinonjs.org/" target="_blank" rel="noopener">Sinon.js</a></h4><p>Sinon 是一个强大的 spies, stubs 和 mocks 独立库，可与任何单元测试框架配合工作。</p><h4 id="testdouble-js"><a href="#testdouble-js" class="headerlink" title="testdouble.js"></a><a href="https://github.com/testdouble/testdouble.js" target="_blank" rel="noopener">testdouble.js</a></h4><p>testdouble 是一个声称比 Sinon 更加优秀但名气稍逊的库。其设计、哲学和特性与 Sinon 略有不同使其在许多情况下更实用，你可以从<a href="https://www.sitepoint.com/javascript-testing-tool-showdown-sinon-js-vs-testdouble-js/" target="_blank" rel="noopener">这里</a>、<a href="https://spin.atomicobject.com/2016/03/21/javascript-mocking-testdouble/" target="_blank" rel="noopener">这里</a>和<a href="http://blog.testdouble.com/posts/2016-03-13-testdouble-vs-sinon.html" target="_blank" rel="noopener">这里</a>读到更多。</p><h4 id="Wallaby"><a href="#Wallaby" class="headerlink" title="Wallaby"></a><a href="https://wallabyjs.com/" target="_blank" rel="noopener">Wallaby</a></h4><p>Wallaby 是另一款值得一提的工具。尽管需要付费，但很多用户推荐购买。它运行在你的 IDE （支持所有主流 IDE）之上，执行代码变更相关的测试，并在失败后实时定位错误代码。</p><p><img src="https://uq60cg.bn.files.1drv.com/y4mYsR4FCiOSU6upwCHNy5GuzHpJwYIOc1EDSs688BAdAmiY280rv-rbSgsEufXYttC34OqCpq3B-z2w2AVYIfLRy1CzjjxMto8H0BGMOGIMBd9h1F5ZPNAzwU86jayH4ylT2NC17YNmrwbGXABhEvm1xPBxcHn1QUoGd72g1rmq55T8flw-jAiv2iM7kOK_B6QQ9DUNHe3-n_7RU3PWTEnIw" alt></p><h4 id="Cucumber"><a href="#Cucumber" class="headerlink" title="Cucumber"></a><a href="https://github.com/cucumber/cucumber-js" target="_blank" rel="noopener">Cucumber</a></h4><p>Cucumber 通过按验收准则文件 (accpetance criteria files，使用 <strong>Gherkin</strong> 语法) 划分并按与之对应的方式协助编写 BDD 结构的测试用例。框架支持的多种语言都可以编写测试用例，包含我们关注的 JS：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> Filename: "like-article.feature"</span><br><span class="line">Feature: A reader can share an article to social networks</span><br><span class="line">  As a reader</span><br><span class="line">  I want to share articles</span><br><span class="line">  So that I can notify my friends about an article I liked</span><br><span class="line">Scenario: An article was opened</span><br><span class="line">    Given I'm inside an article</span><br><span class="line">    When I share the article</span><br><span class="line">    Then the article should change to a "shared" state</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Filename: "like-article.step.js"</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.Given(<span class="regexp">/^I'm inside an article$/</span>, <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 函数式测试工具代码</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.When(<span class="regexp">/^I share the article$/</span>, <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 函数式测试工具代码</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.Then(<span class="regexp">/^the article should change to a "shared" state$/</span>, <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 函数式测试工具代码</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>许多团队会发现这种语法比 TDD 更方便。</p><h2 id="选择你的单元和集成测试框架"><a href="#选择你的单元和集成测试框架" class="headerlink" title="选择你的单元和集成测试框架"></a>选择你的单元和集成测试框架</h2><p>第一个选择你应该做得也许是框架与其相关函数库。建议使用框架内提供的工具直到依赖某些绝无仅有工具的需求出现。</p><blockquote><ul><li>简而言之，如果你只想入门或针对大型功能寻找一款够快的框架，选择 <strong>Jest</strong>。</li><li>如果你想要灵活和可扩展的配置，选择 <strong>Mocha</strong>。</li><li>如果你喜欢简单选择 <strong>Ava</strong>。</li><li>如果你想要非常底层的框架，选择 <strong>tape</strong>。</li></ul></blockquote><p>这里有一份介绍主流工具及其特性的列表：</p><h3 id="mocha"><a href="#mocha" class="headerlink" title="mocha"></a><a href="https://github.com/mochajs/mocha" target="_blank" rel="noopener">mocha</a></h3><p>Mocha 是目前最常用的库。不像 Jasmine，它使用第三方的断言、mocking 和 spying 工具（通常是  Enzyme 和 Chai ）。这意味着 Mocha 在初始配置时有一定难度并需要了解更多库，但这也会变的更加灵活、更开放去扩展。</p><p>举例来说，如果你想要<a href="https://mochajs.org/#assertions" target="_blank" rel="noopener">特殊的断言逻辑</a>，可以 fork Chai（<em>译者注：此处怀疑是笔误，fork Mocha 看起来更合理</em>）并使用自己的断言库仅替换 Chai。虽说这在 Jasmine 中也可以实现，但这种修改在 Mocha 中更显而易见。</p><ul><li><strong>社区 (Community)</strong>：有许多插件和扩展来测试独特的场景。</li><li><strong>扩展性</strong>：插件、扩展和例如 Sinon 之类的库包含了许多 Jasmine 没有的特性。</li><li><strong>全局变量 (Globals)</strong>：默认会创建测试结构的变量，但是显然不像 Jasmine 那样包含了断言、spies 和 mocks ——有些人对这种看似不一致的变量感到吃惊。</li></ul><h3 id="Jest"><a href="#Jest" class="headerlink" title="Jest"></a><a href="https://facebook.github.io/jest/" target="_blank" rel="noopener">Jest</a></h3><p>Jest 是 Facebook 推荐的测试框架，基于我们将会讨论的 Jasmine 开发。不过现如今 Facebook <a href="https://jestjs.io/blog/2016/09/01/jest-15.html" target="_blank" rel="noopener">已经替换了大多数 Jasmine 的功能</a>并在顶层新增了许多特性。</p><blockquote><p>在阅读了大量文章和博客之后，人们对 Jest 速度与便利的印象深刻令人难以置信。</p></blockquote><ul><li><p><strong>性能 (Performance)</strong>：Jest 首要考虑的是通过实现一个<a href="https://jestjs.io/blog/2016/03/11/javascript-unit-testing-performance.html" target="_blank" rel="noopener">灵活的并行测试机制</a>使得处理包含大量测试文件的大型工程速度更快（以我们的经验和一些博客为例：<a href="https://hackernoon.com/testing-react-components-with-jest-and-enzyme-41d592c174f" target="_blank" rel="noopener">这里</a>，<a href="https://medium.com/@kentcdodds/migrating-to-jest-881f75366e7e" target="_blank" rel="noopener">这里</a>，<a href="https://medium.com/@gethylgeorge/testing-a-react-redux-app-using-jest-and-enzyme-b349324803a9" target="_blank" rel="noopener">这里</a>，<a href="https://medium.com/aya-experience/testing-an-angularjs-app-with-jest-3029a613251" target="_blank" rel="noopener">这里</a>）。</p></li><li><p><strong>用户界面</strong>：清楚方便。</p></li><li><p><strong>直接上手 (Ready-To-Go)</strong>：自带和 Sinon 功能相同的断言、spies 和 mocks 库。如果你需要一些额外的特性，使用函数库也很容易。</p></li><li><p><strong>全局变量</strong>：与 Jasmine 类似，Jest <a href="https://jestjs.io/docs/en/api.html" target="_blank" rel="noopener">默认创建了测试相关的全局变量</a>因此不用导入它们。虽然这可能导致测试不够灵活和可控而被诟病，但在绝大多数情况下都让测试更加容易：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// "describe" 已经在全局范围中，因此不需要这些导入代码：</span></span><br><span class="line"><span class="comment">// import &#123; describe &#125; from 'jest'</span></span><br><span class="line"><span class="comment">// import &#123; describe &#125; from 'jasmine'</span></span><br><span class="line"></span><br><span class="line">describe(<span class="string">'calculator'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p><strong>快照测试</strong>：Facebook 开发并维护了 <a href="https://github.com/facebook/jest/tree/master/packages/jest-snapshot" target="_blank" rel="noopener">jest-snapshot</a>，不过它也可以作为工具集成的一部分被绝大多数框架使用，或通过正确的插件来使用。</p></li><li><p><strong>改进后的模组仿真 (Improved modules mocking)</strong>：Jest 提供了一种简单的方法模拟任务繁重的模组以提升测试速度。例如一项服务可以通过 resolve 一个 promise 模拟一次网络请求。</p></li><li><p><strong>代码覆盖</strong>：包含一个基于 <a href="https://github.com/gotwarlost/istanbul" target="_blank" rel="noopener">Istanbul</a> 的功能强大、高效的内置代码覆盖工具。</p></li><li><p><strong>可靠性 (Reliability)</strong>：尽管这是一个相对年轻的函数库，但从 2017 年 Jest 逐步稳定直到现在被认为可靠，且被所有主流 IDEs 和相关工具所支持。</p></li><li><strong>开发 (Development)</strong>：Jest 会对测试文件进行增量更新，因此在观察模式下的测试速度非常快。</li></ul><h3 id="Jasmine"><a href="#Jasmine" class="headerlink" title="Jasmine"></a><a href="https://github.com/jasmine/jasmine" target="_blank" rel="noopener">Jasmine</a></h3><p>既然有了基于 Jasmine 构建的 Jest，为什么还要使用 Jasmine 呢？答案是后者存在得时间更久，有大量来自社区的文章和工具可以参考。同时，Angular 依然推荐使用它而非 Jest，尽管 Jest 目前也已完美适配 Angular 测试，且有很多人在使用。</p><ul><li><strong>直接上手</strong>：包含所有测试所需的东西。</li><li><strong>全局变量</strong>：在全局范围内提供所有重要的测试特性。</li><li><strong>社区</strong>：自从 2009 年问世以来积攒了海量文章、建议及工具。</li><li><strong>Angular</strong>：Angular 的所有版本都支持 Jasmine，并在<a href="https://angular.io/guide/testing" target="_blank" rel="noopener">其官方文档</a>中推荐使用。</li></ul><h3 id="AVA"><a href="#AVA" class="headerlink" title="AVA"></a><a href="https://github.com/avajs/ava" target="_blank" rel="noopener">AVA</a></h3><p>Ava 是一个并行执行测试的极简 (minimalistic) 测试库。</p><ul><li><p><strong>直接上手</strong>：包含所有测试所需的东西（除了可以秒加 spying 和 dubbing）。在测试结构使用以下语法、断言函数，并在 Node.js 中运行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> test <span class="keyword">from</span> <span class="string">'ava'</span></span><br><span class="line"></span><br><span class="line">test(<span class="string">'arrays are equal'</span>, t =&gt; &#123;</span><br><span class="line">  t.deepEqual([<span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p><strong>全局变量</strong>：上文可见，Ava 没有创建任何测试相关的全局变量，因此你对你的测试有更多控制。</p></li><li><p><strong>简单 (Simplicity)</strong>：支持许多高级特性时有着简单的结构和断言函数，摒弃了复杂的 API。</p></li><li><p><strong>开发</strong>：Ava 会对测试文件进行增量更新，因此在观察模式下的测试速度很快。</p></li><li><p><strong>速度 (Speed)</strong>：以独立 Node.js 进程的方式并行执行测试。</p></li><li><p><strong>快照测试</strong>：<a href="https://github.com/avajs/ava#snapshot-testing" target="_blank" rel="noopener">作为框架的一部分被支持</a>。</p></li></ul><h3 id="tape"><a href="#tape" class="headerlink" title="tape"></a><a href="https://github.com/substack/tape" target="_blank" rel="noopener">tape</a></h3><p>Tape 是这些框架中最简单的。它仅有一个 Node.js 文件和一个非常简短的 API。</p><ul><li><strong>简单</strong>：简约的结构和断言函数，没有一个复杂的 API，甚至超越了 Ava。</li><li><strong>全局变量</strong>：不创建任何测试相关的全局变量因此你可以更多地掌控你的测试。</li><li><strong>测试间无共享状态 (No Shared State between tests)</strong>：Tape 不鼓励使用 “beforeEach” 之类的函数以确保测试模块化以及对于测试周期的用户最大化控制。</li><li><strong>无命令行界面 (No CLI)</strong>：Tape 在任何 JS 可以运行的地方都能跑。</li></ul><h2 id="UI-测试工具"><a href="#UI-测试工具" class="headerlink" title="UI 测试工具"></a>UI 测试工具</h2><p>首先就像之前提过的，你可以在<a href="https://www.keycdn.com/blog/browser-compatibility-testing-tools" target="_blank" rel="noopener">这里</a>和<a href="https://www.guru99.com/top-10-cross-browser-testing-tools.html" target="_blank" rel="noopener">这里</a>找到有关服务提供商的好文，这些服务提供商提供主机帮助你在不同的设备和浏览器上执行你的测试。</p><p>长期以 UI 测试为目标的工具从实现、哲学到 API 都多种多样，因此强烈建议花时间理解不同的解决方案并在你的产品中检验它们。</p><ul><li><em>简短说，如果你只想通过一个可靠、设置简单的多浏览器合一的工具入门，使用 <strong>TestCafe</strong>。</em></li><li><em>如果你想要随波逐流并获得最多的社区支持，<strong>WebdriverIO</strong> 是正道。</em></li><li><em>如果你不在乎跨浏览器支持，使用 <strong>Puppeteer</strong>。</em></li><li><em>如果你的应用没有复杂的交互和图像，例如一个充满表格和导航的系统，可以使用跨浏览器无头工具如 <strong>Casper</strong>。</em></li></ul><h3 id="selenium"><a href="#selenium" class="headerlink" title="selenium"></a><a href="https://github.com/SeleniumHQ/selenium" target="_blank" rel="noopener">selenium</a></h3><p>Selenium 使用浏览器自动化模拟用户行为。它并不是专为测试创造，通过暴露一个在浏览器上模拟用户行为的服务器来达到多种用途。</p><p>Selenium 可以被多种方式控制，支持许多编程语言，甚至搭配一些工具后无需任何实际编程。</p><p>对我们的需求而言，通过一个 <a href="https://seleniumhq.github.io/selenium/docs/api/javascript/index.html" target="_blank" rel="noopener">Selenium WebDriver</a> 提供通信层供我们的 NodeJS 代码与操作浏览器的 Selenium 服务器通信从而实现控制。</p><p>​    <strong>Node.js &lt;=&gt; WebDriver &lt;=&gt; Selenium Server &lt;=&gt; FF/Chrome/IE/Safari</strong></p><p>WebDriver 被引入测试框架后，测试代码可参考如下的部分代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'login form'</span>, () =&gt; &#123;</span><br><span class="line"> </span><br><span class="line">  before(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> driver.navigate().to(<span class="string">'http://path.to.test.app/'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  it(<span class="string">'autocompletes the name field'</span>, () =&gt; &#123;</span><br><span class="line">    driver</span><br><span class="line">      .findElement(By.css(<span class="string">'.autocomplete'</span>))</span><br><span class="line">      .sendKeys(<span class="string">'John'</span>)</span><br><span class="line">    </span><br><span class="line">    driver.wait(until.elementLocated(By.css(<span class="string">'.suggestion'</span>)))</span><br><span class="line">    </span><br><span class="line">    driver.findElement(By.css(<span class="string">'.suggestion'</span>)).click()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> driver</span><br><span class="line">      .findElement(By.css(<span class="string">'.autocomplete'</span>))</span><br><span class="line">      .getAttribute(<span class="string">'value'</span>)</span><br><span class="line">      .then(<span class="function"><span class="params">inputValue</span> =&gt;</span> &#123;</span><br><span class="line">        expect(inputValue).to.equal(<span class="string">'John Doe'</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  after(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> driver.quit()</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>WebDriver 本身对你来说可能已经足够，实际上<a href="https://marmelab.com/blog/2016/04/19/e2e-testing-with-node-and-es6.html" target="_blank" rel="noopener">一些人</a>也建议使用它本体，不过还是有许多库通过分支或包装的形式扩展了它。包装后的 WebDriver 可能添加了多余的代码导致调试更加困难，而分支方式则可能偏离 <a href="https://github.com/SeleniumHQ/selenium/commits/master" target="_blank" rel="noopener">2018 年正在活跃开发中</a>的 WebDriver 。</p><p>就算这样，一些人仍偏向不直接使用它，所以让我们看看有关 Selenium 操作的库吧。</p><h3 id="Appium"><a href="#Appium" class="headerlink" title="Appium"></a><a href="https://github.com/appium/appium" target="_blank" rel="noopener">Appium</a></h3><p>Appium 提供类似 Selenium 的 API 测试移动设备上的站点，同时使用了以下工具：</p><ul><li><strong>iOS 9.3+</strong>： Apple 的 <a href="https://developer.apple.com/reference/xctest" target="_blank" rel="noopener">XCUITest</a></li><li><strong>Before iOS 9.3</strong>： Apple 的 <a href="https://developer.apple.com/library/ios/documentation/DeveloperTools/Reference/UIAutomationRef/" target="_blank" rel="noopener">UIAutomation</a></li><li><strong>Android 4.2+</strong>： Google 的 <a href="http://developer.android.com/tools/help/uiautomator/index.html" target="_blank" rel="noopener">UiAutomator/UiAutomator2</a></li><li><strong>Android 2.3+</strong>： Google 的 <a href="http://developer.android.com/reference/android/app/Instrumentation.html" target="_blank" rel="noopener">Instrumentation</a>. （通过打包一个独立的工程提供指令支持, <a href="http://selendroid.io/" target="_blank" rel="noopener">Selendroid</a>）</li><li><strong>Windows Phone</strong>： Microsoft 的 <a href="http://github.com/microsoft/winappdriver" target="_blank" rel="noopener">WinAppDriver</a></li></ul><p>因此如果你使用 Selenium 或基于 Selenium 开发的工具，你同样可以使用 Appium 在移动设备上测试。</p><h3 id="Protractor"><a href="#Protractor" class="headerlink" title="Protractor"></a><strong><a href="https://github.com/angular/protractor" target="_blank" rel="noopener">Protractor</a></strong></h3><p>Protractor 是一个包装 Selenium 并支持 Angular 增强语法以及特殊内置钩子的库。</p><ul><li><strong>Angular</strong>：尽管可以成功接入其他 JS 框架，但针对 Angular 提供了特殊的钩子。<a href="https://angular.io/guide/testing" target="_blank" rel="noopener">Angular 官方文档</a>也推荐使用该工具。</li><li><strong>错误报告 (Error reporting)</strong>：很好的机制。</li><li><strong>支持 (Support)</strong>：目前已支持 Typescript，库本身由庞大的 Angular 团队更新维护。</li></ul><h3 id="WebdriverIO"><a href="#WebdriverIO" class="headerlink" title="WebdriverIO"></a><a href="http://webdriver.io/" target="_blank" rel="noopener">WebdriverIO</a></h3><p>WebdriverIO 实现了另一个版本的 Selenium WebDriver：</p><ul><li><strong>语法</strong>：非常容易和可读。</li><li><strong>灵活</strong>：一个简单、灵活和可扩展的库。</li><li><strong>社区</strong>：拥有良好支持和热心开发者社区提供的丰富插件及扩展。</li></ul><h3 id="Nightwatch"><a href="#Nightwatch" class="headerlink" title="Nightwatch"></a><strong><a href="http://nightwatchjs.org/" target="_blank" rel="noopener">Nightwatch</a></strong></h3><p>Nightwatch 也实现了又一个 Selenium WebDriver，并提供了自己的测试框架包含一个测试服务器、断言和一些工具。</p><ul><li><strong>框架</strong>：也可以与其他框架搭配使用，不过在你想要运行功能性测试而非作为其他框架的一部分时特别有用。</li><li><strong>语法</strong>：看起来是最简单和最可读的。</li><li><strong>支持</strong>：不支持 Typescript，大体上看这个库似乎比其他库的支持要少一丢丢。</li></ul><h3 id="TestCafe"><a href="#TestCafe" class="headerlink" title="TestCafe"></a><strong><a href="https://devexpress.github.io/testcafe/" target="_blank" rel="noopener">TestCafe</a></strong></h3><p>TestCafe 是基于 Selenium 的不错替代品，在 2016 年底重写并<strong>开源</strong>。</p><p><strong>它仍有一款<a href="https://testcafe.devexpress.com/" target="_blank" rel="noopener">付费版本</a>提供一些免编程的测试工具</strong>例如测试录制和用户支持，这很重要，因为有许多过时的文章错误地陈述其代码已停止开发并将这视为库的缺点。</p><p>与 Selenium 不同的是它通过 JavaScript 脚本的形式注入到网站中来控制浏览器。这使得 TestCafe 可以<strong>运行在任意浏览器中，包含移动设备</strong>，并完全控制 JavaScript 的执行循环。</p><p>TestCafe 是 JavaScript 和测试导向的。尽管已经被认为稳定和功能丰富，但目前仍然处于大规模开发状态。</p><ul><li><strong>快速构建 (Fast to set up)</strong>：随意打开一个浏览器就可以跑你的测试。</li><li><strong>跨浏览器和设备 (Cross Browser and Devices)</strong>：支持许多浏览器和设备，可与提供设备和浏览器测试的 <a href="https://saucelabs.com/" target="_blank" rel="noopener">SauceLabs</a> 或 <a href="https://www.browserstack.com/" target="_blank" rel="noopener">BrowserStack </a> 配合使用。这包含了在<a href="https://developers.google.com/web/updates/2017/04/headless-chrome" target="_blank" rel="noopener">无头 Chrome</a> 和<a href="https://developer.mozilla.org/en-US/docs/Mozilla/Firefox/Headless_mode" target="_blank" rel="noopener">无头 Firefox</a> 中运行测试，将会在后续讨论到。</li><li><strong>并行测试 (Parallel Testing)</strong>：TestCafe 可以<a href="https://devexpress.github.io/testcafe/documentation/using-testcafe/common-concepts/concurrent-test-execution.html" target="_blank" rel="noopener">一次在多个浏览器实例中运行你的测试</a>。这个实践可以显著地缩短你的测试时间。</li><li><strong>方便的错误报告 (Convenient Error Reporting)</strong></li><li><strong>自有生态系统 (Own Ecosystem)</strong>：<a href="https://testcafe-discuss.devexpress.com/t/interacting-with-browser-using-testcafe-apis-but-without-testcafe-test-runner/300/6" target="_blank" rel="noopener">TestCafe 使用自己的测试结构</a>。这可能很方便，尤其因为 UI 测试经常与其他测试分开执行，<a href="https://medium.com/tech-quizlet/cypress-the-future-of-end-to-end-testing-for-web-applications-8ee108c5b255" target="_blank" rel="noopener">不过有些人并不喜欢</a>。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Selector &#125; <span class="keyword">from</span> <span class="string">'testcafe'</span>;</span><br><span class="line"></span><br><span class="line">fixture <span class="string">`Getting Started`</span></span><br><span class="line">    .page <span class="string">`https://devexpress.github.io/testcafe/example`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自己的测试结构</span></span><br><span class="line">test(<span class="string">'My first test'</span>, <span class="keyword">async</span> t =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> t</span><br><span class="line">        .typeText(<span class="string">'#developer-name'</span>, <span class="string">'John Smith'</span>)</span><br><span class="line">        .click(<span class="string">'#submit-button'</span>)</span><br><span class="line">        .expect(Selector(<span class="string">'#article-header'</span>).innerText)</span><br><span class="line">        .eql(<span class="string">'Thank you, John Smith!'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Cypress"><a href="#Cypress" class="headerlink" title="Cypress"></a><a href="https://www.cypress.io/" target="_blank" rel="noopener">Cypress</a></h3><p>Cypress 是 TestCafe 的直接竞争对手之一。他们做的事情类似，如注入测试到网站中，但 Cypress 尝试将其做得更加现代化、灵活和方便。</p><p>Cypress 非常年轻，<a href="https://www.cypress.io/blog/2017/10/10/cypress-is-now-public-beta/" target="_blank" rel="noopener">刚从封闭 beta 版推进到公开 beta 版</a>（在 2017 年十月），却已经有<a href="https://medium.com/tech-quizlet/cypress-the-future-of-end-to-end-testing-for-web-applications-8ee108c5b255" target="_blank" rel="noopener">很多发烧友</a>。</p><ul><li><strong>不支持跨浏览器</strong>：目前仅支持 Chrome （<a href="https://github.com/cypress-io/cypress/issues/832" target="_blank" rel="noopener">也不支持无头版</a>）。不过这个问题已经被创建，开发者也正在为之努力。</li><li><strong>缺乏高级功能</strong>：相较 TestCafe 而言缺少并行测试和专有测试工具，不过这些都已经在产品的路线图中了。</li><li><strong>文档</strong>：详实且清楚。</li><li><strong>调试工具</strong>：在测试过程中容易调试和打日志。</li><li><strong>Mocha</strong>：使用 Mocha 作为其测试结构的提供者，确保使用起来非常标准，UI 测试可与其他测试构建在同一结构中。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'My First Cypress Test'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  it(<span class="string">"Gets, types and asserts"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    cy.visit(<span class="string">'https://example.cypress.io'</span>)</span><br><span class="line"></span><br><span class="line">    cy.contains(<span class="string">'type'</span>).click()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 应在一个包含 '/commands/actions' 的新 URL 上</span></span><br><span class="line">    cy.url().should(<span class="string">'include'</span>, <span class="string">'/commands/actions'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取一个输入，打字填入其中，并验证其值已经更新</span></span><br><span class="line">    cy.get(<span class="string">'.action-email'</span>)</span><br><span class="line">      .type(<span class="string">'fake@email.com'</span>)</span><br><span class="line">      .should(<span class="string">'have.value'</span>, <span class="string">'fake@email.com'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Puppeteer"><a href="#Puppeteer" class="headerlink" title="Puppeteer"></a><strong><a href="https://github.com/GoogleChrome/puppeteer" target="_blank" rel="noopener">Puppeteer</a></strong></h3><p>Puppeteer 是一个 Google 开发的 Node.js 库，提供了方便的 Node.js API 操控<a href="https://chromium.googlesource.com/chromium/src/+/lkgr/headless/README.md" target="_blank" rel="noopener">无头 Chrome</a>。</p><p>无头 Chrome 就是一个运行了 <code>--headless</code> 标志位的常规 Chrome v59+。当 Chrome 运行在无头模式时，会暴露出 API 供外界管理，而 Puppeteer 就是 Google 提供控制它的 JavaScript 工具。</p><p>值得一提的是 Firefox 在 2017 年底也推出了<a href="https://developer.mozilla.org/en-US/docs/Mozilla/Firefox/Headless_mode" target="_blank" rel="noopener">无头模式</a>。</p><p>注意其他不同的测试工具如 TestCafe、Krama 也可以使用无头 Chrome 和 Firefox。</p><ul><li>Puppeteer 相对较新，但它有一个很大的社区使用、开发工具和二次封装。</li><li><strong>原生 (Native) 的所以快，并且使用了最新的 Chrome 引擎</strong>，不像 <a href="https://about.gitlab.com/2017/12/19/moving-to-headless-chrome/" target="_blank" rel="noopener">PhantomJS 构建在旧 WebKit 的分支上</a>。（下一小节会讨论）</li><li>无头 Chrome 的（因此也是 Puppeteer 的）一个主要缺点是它<a href="https://bugs.chromium.org/p/chromium/issues/detail?id=706008" target="_blank" rel="noopener">不支持一些扩展</a>，比如 Flash 扩展（并且近期也可能不会支持）。</li></ul><h3 id="PhantomJS"><a href="#PhantomJS" class="headerlink" title="PhantomJS"></a><a href="http://phantomjs.org/" target="_blank" rel="noopener">PhantomJS</a></h3><p>Phantom 通过实现 Chromium 引擎创建了一个可控的类 Chrome 无头浏览器。不过自从<a href="https://www.chromestatus.com/features/5678767817097216" target="_blank" rel="noopener">谷歌宣布自家的 Puppeteer</a> 后，Phantom 的创始人和维护者 <a href="https://medium.com/@vitallium" target="_blank" rel="noopener">Vitaliy Slobodin</a> 便<a href="https://groups.google.com/forum/#!msg/phantomjs/9aI5d-LDuNE/5Z3SMZrqAQAJ" target="_blank" rel="noopener">不再对其投入精力</a>，因此从 2017 年中开始维护和开发速度就大幅下降，尽管还是有人在维护。</p><p>那么，为什么还要使用 Phantom 而非 Puppeteer？</p><ul><li>首先它有<strong>更多的特性</strong>和许多教程、工具。</li><li>它也被许多实用工具如后面会讨论的 <strong>CasperJS</strong> 使用。</li><li>它使用更早的 WebKit 因此可以模拟旧版 Chrome。</li><li>此外之前提过，Phantom <strong>支持如 Flash 扩展</strong>，<a href="https://bugs.chromium.org/p/chromium/issues/detail?id=706008" target="_blank" rel="noopener">与无头 Chrome 相反</a>。</li></ul><h3 id="Nightmare"><a href="#Nightmare" class="headerlink" title="Nightmare"></a><a href="https://github.com/segmentio/nightmare" target="_blank" rel="noopener">Nightmare</a></h3><p>Nightmare 是一款测试语法特别简单的优秀 UI 测试库，使用与 Phantom 类似的 <a href="https://electronjs.org/" target="_blank" rel="noopener">Electron</a> 开发。Electron 基于更新版本的 Chromium，处在活跃维护与开发阶段，主要目标是使用 JavaScript、HTML 和 CSS 构建跨平台的桌面应用。</p><p>同样 Nightmare 也在<a href="https://github.com/segmentio/nightmare/issues/1092" target="_blank" rel="noopener">讨论</a>和<a href="https://github.com/segmentio/nightmare/pull/1211" target="_blank" rel="noopener">实验</a>使用无头 Chrome。以下是 Nightmare 和 Phantom 代码的比较：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 译者注：Nightmare 代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">yield</span> Nightmare()</span><br><span class="line">  .goto(<span class="string">'http://yahoo.com'</span>)</span><br><span class="line">  .type(<span class="string">'input[title="Search"]'</span>, <span class="string">'github nightmare'</span>)</span><br><span class="line">  .click(<span class="string">'.searchsubmit'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 译者注：Phantom 代码</span></span><br><span class="line"></span><br><span class="line">phantom.create(<span class="function"><span class="keyword">function</span> (<span class="params">ph</span>) </span>&#123;</span><br><span class="line">  ph.createPage(<span class="function"><span class="keyword">function</span> (<span class="params">page</span>) </span>&#123;</span><br><span class="line">    page.open(<span class="string">'http://yahoo.com'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">status</span>) </span>&#123;</span><br><span class="line">      page.evaluate(</span><br><span class="line">        <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">var</span> el = <span class="built_in">document</span>.querySelector(<span class="string">'input[title="Search"]'</span>)</span><br><span class="line">          el.value = <span class="string">'github nightmare'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">          page.evaluate(</span><br><span class="line">            <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">              <span class="keyword">var</span> el = <span class="built_in">document</span>.querySelector(<span class="string">'.searchsubmit'</span>)</span><br><span class="line">              <span class="keyword">var</span> event = <span class="built_in">document</span>.createEvent(<span class="string">'MouseEvent'</span>)</span><br><span class="line">              event.initEvent(<span class="string">'click'</span>, <span class="literal">true</span>, <span class="literal">false</span>)</span><br><span class="line">              el.dispatchEvent(event)</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">              ph.exit()</span><br><span class="line">            &#125;</span><br><span class="line">          ) <span class="comment">// page.evaluate</span></span><br><span class="line">        &#125;</span><br><span class="line">      ) <span class="comment">// page.evaluate</span></span><br><span class="line">    &#125;) <span class="comment">// page.open</span></span><br><span class="line">  &#125;) <span class="comment">// ph.createPage</span></span><br><span class="line">&#125;) <span class="comment">// phantom.create</span></span><br></pre></td></tr></table></figure><h3 id="Casper"><a href="#Casper" class="headerlink" title="Casper"></a><a href="https://github.com/casperjs/casperjs" target="_blank" rel="noopener">Casper</a></h3><p>Casper 基于 PhantomJS 和 <a href="https://slimerjs.org/" target="_blank" rel="noopener">SlimerJS</a> （与 Phantom 相同只不过使用了 Firefox 的 Gecko）编写，抽象了在创建 Phantom 和 Slimer 时复杂的异步脚本，从而提供导航、脚本执行和测试工具。</p><p>Slimer 尽管被认为是试验性的产品但已被长期广泛使用，并在 2017 年底<strong>释出了 beta 版本</strong>——使用新版<a href="https://developer.mozilla.org/en-US/Firefox/Headless_mode" target="_blank" rel="noopener">无头 Firefox</a> 的 <code>1.0.0-beta.1</code>，目前正在为稳定后发布 <code>1.0.0</code> 版本而努力。</p><p>Casper 近期可能会从 PhantomJS 移植到 Puppeteer，预期 2.0 版本成为通吃无头 Chrome 和无头 Firefox 的工具，敬请期待吧。</p><h3 id="CodeceptJS"><a href="#CodeceptJS" class="headerlink" title="CodeceptJS"></a><a href="https://github.com/codeception/codeceptjs/" target="_blank" rel="noopener">CodeceptJS</a></h3><p>类似上面讨论过的 CucumberJS，CodeceptJS 通过不同的函数库 API 提供另一层抽象，哲学上期待你的测试更多关注用户行为。</p><p>它大概长这这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Scenario(<span class="string">'login with generated password'</span>, <span class="keyword">async</span> (I) =&gt; &#123;</span><br><span class="line">  I.fillField(<span class="string">'email'</span>, <span class="string">'miles@davis.com'</span>);</span><br><span class="line">  I.click(<span class="string">'Generate Password'</span>);</span><br><span class="line">  <span class="keyword">const</span> password = <span class="keyword">await</span> I.grabTextFrom(<span class="string">'#password'</span>);</span><br><span class="line">  I.click(<span class="string">'Login'</span>);</span><br><span class="line">  I.fillField(<span class="string">'email'</span>, <span class="string">'miles@davis.com'</span>);</span><br><span class="line">  I.fillField(<span class="string">'password'</span>, password);</span><br><span class="line">  I.click(<span class="string">'Log in!'</span>);</span><br><span class="line">  I.see(<span class="string">'Hello, Miles'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>以下是可以使用这段代码执行的函数库，在前文都讨论过：</p><p><a href="https://github.com/Codeception/CodeceptJS/blob/master/docs/helpers/WebDriverIO.md" target="_blank" rel="noopener">WebDriverIO</a>, <a href="https://github.com/Codeception/CodeceptJS/blob/master/docs/helpers/Protractor.md" target="_blank" rel="noopener">Protractor</a>, <a href="https://github.com/Codeception/CodeceptJS/blob/master/docs/helpers/Nightmare.md" target="_blank" rel="noopener">Nightmare</a>, <a href="https://github.com/Codeception/CodeceptJS/blob/master/docs/helpers/Appium.md" target="_blank" rel="noopener">Appium</a>, <a href="https://github.com/Codeception/CodeceptJS/blob/master/docs/helpers/Puppeteer.md" target="_blank" rel="noopener">Puppeteer</a>.</p><p>如果你相信这种语法更适合你的需求，那就试试看吧。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们看完了web 开发社区中最流行的测试策略和工具，希望你能更加轻松地测试你的站点。</p><blockquote><p>最后，如今关于应用架构的最佳决策是在理解活跃开发社区提出的通用解决模式、与自身经验做结合且考虑应用的特性和特殊需求下做出的。</p></blockquote><p>噢，然后编码，再重新编码，再重新编码，再重新编码后，测试不同的解决方案 :)</p><p><img src="https://uq61cg.bn.files.1drv.com/y4m5Hsf55vPDgt2WkOq0qHEeEdQ7dj27ovAZLK4_JyfnwxaZNreWgW8Mh0lNUTdXRIzl2xmx_Oh_gWTPCGuqQuerACxTrxD4McCE5SaLCcWAOSrnDonVPapk7j1L-B3_4WImEfBIGeDsMHpgEgyEG2hRZlJg9_F0gXokxSvAK1RcWWovEWHrIOYkjt5ZEQ5PJtP4Bq6aNi5aI2X4Y1CwLPHmA" alt></p><p>测试快乐 :)</p><p>谢谢 :)</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><h3 id="最佳"><a href="#最佳" class="headerlink" title="最佳"></a>最佳</h3><ul><li><a href="http://mo.github.io/2017/07/20/javascript-e2e-integration-testing.html" target="_blank" rel="noopener"><strong>Javascript tools for end-to-end testing</strong> web applications (July 2017)</a></li><li><a href="https://medium.com/@adrian_lewis/top-5-most-rated-node-js-frameworks-for-end-to-end-web-testing-f8ebca4e5d44" target="_blank" rel="noopener"><strong>Top 5 Most Rated Node.js Frameworks for End-to-End Web Testing</strong>(March 2017)</a></li><li><a href="https://www.blazemeter.com/blog/top-15-ui-test-automation-best-practices-you-should-follow" target="_blank" rel="noopener">Top <strong>UI Test Automation Best Practices</strong> You Should Follow (November 2017)</a></li><li><a href="https://hackernoon.com/how-to-set-up-e2e-browser-testing-for-your-github-project-89c24e15a84" target="_blank" rel="noopener">How to set up E2E browser testing for your <strong>GitHub project (With TestCafe)</strong> (February 2017)</a></li><li><a href="https://blog.logrocket.com/introduction-to-headless-browser-testing-44b82310b27c" target="_blank" rel="noopener">Introduction to <strong>Headless Browser Testing</strong> (September 2017)</a></li><li><a href="https://blog.phantombuster.com/web-scraping-in-2017-headless-chrome-tips-tricks-4d6521d695e8" target="_blank" rel="noopener"><strong>Web Scraping in 2017</strong>: Advanced Headless Chrome Tips &amp; Tricks (august 2017)</a></li><li><a href="https://about.gitlab.com/2017/12/19/moving-to-headless-chrome/" target="_blank" rel="noopener">How GitLab switched to <strong>Headless Chrome for testing (From Phantom)</strong>(December 2017)</a></li></ul><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><ul><li><a href="https://www.joecolantonio.com/2016/06/14/top-8-essential-javascript-automation-frameworks/" target="_blank" rel="noopener">The <strong>Top 8 Essential JavaScript Automation Frameworks</strong> (June 2016)</a></li><li><a href="https://www.sitepoint.com/javascript-testing-unit-functional-integration/" target="_blank" rel="noopener">JavaScript Testing: <strong>Unit vs Functional vs Integration Tests</strong> (April 2016)</a></li><li><a href="https://codeutopia.net/blog/2015/04/11/what-are-unit-testing-integration-testing-and-functional-testing/" target="_blank" rel="noopener">What are <strong>Unit Testing, Integration Testing and Functional Testing</strong>? (April 2015)</a></li><li><a href="https://www.keycdn.com/blog/browser-compatibility-testing-tools/" target="_blank" rel="noopener">Top 12 Browser Compatibility Testing Tools (June 2017)</a></li><li><a href="https://www.guru99.com/top-10-cross-browser-testing-tools.html" target="_blank" rel="noopener">Top 10 Cross Browser Compatibility Testing Tools In 2018 (2018)</a></li></ul><h3 id="spies-和-stubs"><a href="#spies-和-stubs" class="headerlink" title="spies 和 stubs"></a>spies 和 stubs</h3><ul><li><a href="https://spin.atomicobject.com/2016/03/21/javascript-mocking-testdouble/" target="_blank" rel="noopener">Bye-Bye, Sinon — <strong>Hello, testdouble</strong> (March 2016)</a></li><li><a href="https://www.sitepoint.com/javascript-testing-tool-showdown-sinon-js-vs-testdouble-js/" target="_blank" rel="noopener">JavaScript Testing Tool Showdown: <strong>Sinon.js vs testdouble.js</strong> (April 2017)</a></li><li><a href="http://blog.testdouble.com/posts/2016-03-13-testdouble-vs-sinon.html" target="_blank" rel="noopener"><strong>testdouble.js vs. sinon.js</strong> (March 2016)</a></li><li><a href="https://medium.com/@bruderstein/enzyme-vs-unexpected-react-ee9cb099d12b" target="_blank" rel="noopener"><strong>enzyme vs unexpected-react</strong> (April 2017)</a></li></ul><h3 id="测试框架对比"><a href="#测试框架对比" class="headerlink" title="测试框架对比"></a>测试框架对比</h3><ul><li><a href="https://spin.atomicobject.com/2017/05/02/react-testing-jest-vs-mocha/" target="_blank" rel="noopener">React Testing — <strong>Jest or Mocha?</strong> (May 2017)</a></li><li><a href="http://instea.sk/2016/08/testing-react-applications-with-karma-jest-or-mocha/" target="_blank" rel="noopener">Testing React Applications with <strong>Karma, Jest or Mocha</strong> (August 2016)</a></li><li><a href="https://medium.com/cardinal-solutions/lets-compare-javascript-testing-frameworks-bb500f0b1006" target="_blank" rel="noopener">Let’s Compare <strong>Javascript Testing Framework</strong> (August 2016)</a></li><li><a href="http://thejsguy.com/2015/01/12/jasmine-vs-mocha-chai-and-sinon.html" target="_blank" rel="noopener"><strong>Jasmine vs. Mocha, Chai, and Sinon</strong> (Updated February 2016)</a></li><li><a href="http://www.tisa-software.com/news/blog/217-jasmine-mocha-javascript-testing-framework-comparison" target="_blank" rel="noopener"><strong>Jasmine vs. Mocha</strong>- JavaScript Testing Framework Comparison<br>(January 2017)</a></li></ul><h3 id="Jest-1"><a href="#Jest-1" class="headerlink" title="Jest"></a>Jest</h3><ul><li><a href="https://hackernoon.com/how-to-snapshot-test-everything-in-your-redux-app-with-jest-fde305ebedea" target="_blank" rel="noopener">How to <strong>Snapshot</strong> Test Everything in Your <strong>Redux App With Jest</strong><br>(December 2016)</a></li><li><a href="https://medium.com/@kentcdodds/migrating-to-jest-881f75366e7e" target="_blank" rel="noopener"><strong>Migrating to Jest</strong> on the P2P team at PayPal (November 2016)</a></li><li><a href="https://hackernoon.com/from-0-to-100-coverage-real-quick-d71dda7069e5" target="_blank" rel="noopener"><strong>Jest</strong>- From 0 to 100% Coverage Real Quick (January 2017)</a></li><li><a href="https://medium.com/@boriscoder/the-hidden-power-of-jest-matchers-f3d86d8101b0" target="_blank" rel="noopener">The Hidden Power of <strong>Jest Matchers</strong> (January 2017)</a></li><li><a href="https://hackernoon.com/testing-react-components-with-jest-and-enzyme-41d592c174f" target="_blank" rel="noopener">Testing <strong>React components with Jest and Enzyme</strong> (December 2016)</a></li><li><a href="https://medium.com/@gethylgeorge/testing-a-react-redux-app-using-jest-and-enzyme-b349324803a9" target="_blank" rel="noopener">Testing a <strong>React-Redux app using Jest and Enzyme</strong> (January 2017)</a></li><li><a href="https://semaphoreci.com/community/tutorials/snapshot-testing-react-components-with-jest" target="_blank" rel="noopener"><strong>Snapshot</strong> Testing React Components with <strong>Jest</strong> (January 2017)</a></li><li><a href="https://medium.com/aya-experience/testing-an-angularjs-app-with-jest-3029a613251" target="_blank" rel="noopener">Testing an <strong>AngularJS</strong> app with <strong>Jest</strong> (October 2016)</a></li></ul><h3 id="Ava"><a href="#Ava" class="headerlink" title="Ava"></a>Ava</h3><ul><li><a href="https://wecodetheweb.com/2016/04/19/effortless-unit-testing-with-ava/" target="_blank" rel="noopener">Effortless unit testing with <strong>AVA</strong> (April 2016)</a></li><li><a href="https://atendesigngroup.com/blog/javascript-testing-ava" target="_blank" rel="noopener">Javascript Testing with <strong>AVA</strong> (February 2017)</a></li><li><a href="https://tech.just-eat.com/2016/11/10/unit-testing-front-end-javascript-with-ava-and-jsdom/" target="_blank" rel="noopener">Unit testing front-end JavaScript with <strong>AVA and jsdom</strong> (November 2016)</a></li><li><a href="https://shift.infinite.red/testing-the-bejeezus-out-of-react-native-apps-with-ava-330f51f8f6c3" target="_blank" rel="noopener">Testing the Bejeezus out of React Native Apps with <strong>AVA</strong> (June 2016)</a></li></ul><h3 id="Tape"><a href="#Tape" class="headerlink" title="Tape"></a>Tape</h3><ul><li><a href="https://medium.com/javascript-scene/why-i-use-tape-instead-of-mocha-so-should-you-6aa105d8eaf4" target="_blank" rel="noopener">Why I use <strong>Tape Instead of Mocha</strong> &amp; So Should You (July 2015)</a></li><li><a href="https://github.com/dwyl/learn-tape" target="_blank" rel="noopener">Learn <strong>Tape</strong></a></li></ul><h3 id="UI-测试-1"><a href="#UI-测试-1" class="headerlink" title="UI 测试"></a>UI 测试</h3><ul><li><a href="https://moduscreate.com/blog/hybrid-application-testing-with-protractor-and-appium/" target="_blank" rel="noopener">Hybrid Application Testing with <strong>Protractor and Appium</strong> (March 2017)</a></li><li><a href="https://hackernoon.com/benchmark-headless-chrome-vs-phantomjs-e7f44c6956c" target="_blank" rel="noopener"><strong>Headless Chrome vs PhantomJS Benchmark</strong> (September 2017)</a></li><li><a href="http://www.webdriverjs.com/protractor-vs-webdriverio-vs-nightwatch/" target="_blank" rel="noopener"><strong>Protractor vs WebdriverIO vs NightWatch</strong> (November 2016)</a></li><li><a href="https://marmelab.com/blog/2016/04/19/e2e-testing-with-node-and-es6.html" target="_blank" rel="noopener">End to End (e2e) Testing React Apps With <strong>Selenium WebDriver And Node.js</strong> is Easier Than You Think (April 2016)</a></li><li><a href="https://blog.dmbcllc.com/using-javascript-to-drive-selenium-tests/" target="_blank" rel="noopener"><strong>WebdriverIO</strong>- Using JavaScript to Drive Selenium Tests (August 2016)</a></li><li><a href="https://www.sitepoint.com/javascript-functional-testing-nightwatch-js/" target="_blank" rel="noopener">JavaScript Functional Testing with <strong>Nightwatch.js</strong> (August 2016)</a></li><li><a href="https://blog.risingstack.com/end-to-end-testing-with-nightwatch-js-node-js-at-scale/" target="_blank" rel="noopener">Node.js End-to-End Testing with <strong>Nightwatch.js</strong> (March 2017)</a></li><li><a href="http://dsheiko.com/weblog/nightmare-of-end-to-end-testing" target="_blank" rel="noopener"><strong>Nightmare</strong> of End-to-End Testing (September 2016)</a></li><li><a href="http://www.webdriverjs.com/protractor-vs-webdriverio-vs-nightwatch/" target="_blank" rel="noopener"><strong>Protractor vs WebdriverIO vs NightWatch</strong> (November 2016)</a></li><li><a href="http://stackoverflow.com/questions/35981605/what-is-the-difference-between-nightwatch-js-and-webdriver-io" target="_blank" rel="noopener">Stack Overflow- What is the difference between <strong>nightwatch.js And webdriver.io?</strong> (March 2016)</a></li><li><a href="https://watirmelon.blog/2015/12/08/comparison-of-javascript-browser-automation-and-test-specification-libraries/" target="_blank" rel="noopener"><strong>Comparison of JavaScript browser automation and test specification libraries</strong> (December 2015)</a></li><li><a href="https://scotch.io/tutorials/what-is-phantomjs-and-how-is-it-used" target="_blank" rel="noopener">What is <strong>PhantomJS</strong> and How is it Used? (June 2016)</a></li><li><a href="https://medium.com/@armno/setting-up-end-to-end-testing-in-angular-project-with-codeceptjs-ac1784de3420" target="_blank" rel="noopener">Setting up End-to-End Testing in Angular Project with <strong>CodeceptJS</strong>(December 2017)</a></li></ul><h3 id="TestCafe-1"><a href="#TestCafe-1" class="headerlink" title="TestCafe"></a>TestCafe</h3><ul><li><a href="http://onpathtesting.com/automated-testing-tool-testcafe-or-selenium-webdriver/" target="_blank" rel="noopener">Which automated testing tool to pick — <strong>Testcafe or Selenium WebDriver</strong>? (January 2016)</a></li><li><a href="https://devexpress.github.io/testcafe/blog/introducing-testcafe-open-source-testing-framework.html" target="_blank" rel="noopener"><strong>Introducing TestCafe</strong> — Open Source Testing Framework (Octobeer 2016)</a></li><li><a href="https://testcafe-discuss.devexpress.com/t/why-not-use-selenium/47" target="_blank" rel="noopener">Why not use Selenium? (October 2016)</a></li><li><a href="http://mherman.org/blog/2017/03/19/functional-testing-with-testcafe" target="_blank" rel="noopener">Functional Testing With <strong>TestCafe</strong> (March 2017)</a></li><li><a href="http://www.pqatesting.com/our_ideas/blog/u" target="_blank" rel="noopener">UI Test Automation Frameworks Showdown: <strong>TestCafé versus Nightwatch.js</strong> (Fabruary 2018)</a></li></ul><h3 id="Cypress-1"><a href="#Cypress-1" class="headerlink" title="Cypress"></a>Cypress</h3><ul><li><a href="https://quizlet.com/blog/cypress-the-future-of-end-to-end-testing-for-web-applications" target="_blank" rel="noopener"><strong>Cypress</strong>: The future of end-to-end testing for web applications (Fabruary 2018)</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;源文链接：&lt;a href=&quot;https://medium.com/welldone-software/an-overview-of-javascript-testing-in-2018-f68950900bc3&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;An Overview of JavaScript Testing in 2018&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;摘要：使用 Jest 进行单元和集成测试，使用 TestCafe 进行 UI 测试。&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Web 前端" scheme="https://blog.joouis.com/categories/Web-%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="javascript" scheme="https://blog.joouis.com/tags/javascript/"/>
    
      <category term="test" scheme="https://blog.joouis.com/tags/test/"/>
    
      <category term="unit test" scheme="https://blog.joouis.com/tags/unit-test/"/>
    
      <category term="integration test" scheme="https://blog.joouis.com/tags/integration-test/"/>
    
      <category term="ui test" scheme="https://blog.joouis.com/tags/ui-test/"/>
    
      <category term="mocha" scheme="https://blog.joouis.com/tags/mocha/"/>
    
      <category term="jasmine" scheme="https://blog.joouis.com/tags/jasmine/"/>
    
      <category term="jest" scheme="https://blog.joouis.com/tags/jest/"/>
    
      <category term="cucumber" scheme="https://blog.joouis.com/tags/cucumber/"/>
    
      <category term="chai" scheme="https://blog.joouis.com/tags/chai/"/>
    
      <category term="unexpected" scheme="https://blog.joouis.com/tags/unexpected/"/>
    
      <category term="karma" scheme="https://blog.joouis.com/tags/karma/"/>
    
      <category term="ava" scheme="https://blog.joouis.com/tags/ava/"/>
    
      <category term="sinon" scheme="https://blog.joouis.com/tags/sinon/"/>
    
      <category term="enzyme" scheme="https://blog.joouis.com/tags/enzyme/"/>
    
      <category term="testdouble" scheme="https://blog.joouis.com/tags/testdouble/"/>
    
      <category term="istanbul" scheme="https://blog.joouis.com/tags/istanbul/"/>
    
      <category term="blanket" scheme="https://blog.joouis.com/tags/blanket/"/>
    
      <category term="protractor" scheme="https://blog.joouis.com/tags/protractor/"/>
    
      <category term="nightwatch" scheme="https://blog.joouis.com/tags/nightwatch/"/>
    
      <category term="phantom" scheme="https://blog.joouis.com/tags/phantom/"/>
    
      <category term="casper" scheme="https://blog.joouis.com/tags/casper/"/>
    
      <category term="selenium" scheme="https://blog.joouis.com/tags/selenium/"/>
    
      <category term="appium" scheme="https://blog.joouis.com/tags/appium/"/>
    
      <category term="webdriverio" scheme="https://blog.joouis.com/tags/webdriverio/"/>
    
      <category term="testcafe" scheme="https://blog.joouis.com/tags/testcafe/"/>
    
      <category term="cypress" scheme="https://blog.joouis.com/tags/cypress/"/>
    
      <category term="puppeteer" scheme="https://blog.joouis.com/tags/puppeteer/"/>
    
      <category term="nightmare" scheme="https://blog.joouis.com/tags/nightmare/"/>
    
      <category term="codeceptjs" scheme="https://blog.joouis.com/tags/codeceptjs/"/>
    
  </entry>
  
  <entry>
    <title>读书简记：《万历十五年》</title>
    <link href="https://blog.joouis.com/2018/10/06/reading-notes-1587/"/>
    <id>https://blog.joouis.com/2018/10/06/reading-notes-1587/</id>
    <published>2018-10-06T12:26:08.000Z</published>
    <updated>2018-10-06T12:26:08.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>很早之前就慕名买了《万历十五年》这本书，直到这个国庆假期才花了四天的时间一鼓作气读完。读得过程中便不自觉感慨一些片段写得非常精彩，全文读毕只能说这是我在 2018 年读过最精彩的一本书。<br><a id="more"></a></p><p>这本书的内容用一句话概述即讲述了中国从古至今的政治学问。虽然书中分析得是明朝万历皇帝执政时期的政治、经济、军事等情况，但身为读者，你丝毫不会觉得内容过时，反而有种今日不也是如此的既视感。可以说中华五千年的历史，有些本质并没有发生巨大的改变，有些文化也是周而复始。因此通过这本书，可以体会到什么是 “以铜为镜，可以正衣冠；以古为镜，可以知兴替”。</p><p>作为一本历史书籍，作者黄仁宇以纪录片旁白的口吻讲述明朝历史，非常生动，好比在听评书一般。剧情上由人及事，又因事提人，大量穿插，显得内容非常连贯紧凑而节奏适中。虽说书名是万历十五年这一具体年份，但实际全书覆盖了万历皇帝执政的整个时期，从登基直至作古，在此之中还介绍、分析了一些从明朝创始以来就有而到万历年间的情况。这是黄仁宇闻名于世的“大世界观”的分析手法，强调不要单纯去分析一时的问题，而是向前推演，从长久的时间维度解读社会症结。</p><p>书中一针见血地阐述了偌大一个帝国国家机构的运作机制，更为巧妙的是，能站在不同角色如皇帝万历、类似丞相的首辅张居正、将领黄继光、文学家李贽等人的立场来分析他们是如何在这样一个帝国中做出自己的人生选择，同时通过他们介绍明代的政治、经济、军事、哲学等方面文化。</p><p>在这几位中，如果说臣子们的人生选择多少都有些迫不得已，那么万历皇帝真的是令人佩服。既然有的事情反抗不了，作为活着的祖宗，就佛系僵持着一切吧，保守自己内心的一份坚持，而不是一直妥协。</p><p>造成明代灭亡最根本的问题，一言以蔽之就是太多事情用道德代替法律来处理。明代的管理者们号称为人民服务，追求精神上的奉献与仁德，却与物质需求发生极大的冲突。似乎有点眼熟不是吗？</p><p>最后，虽然书中批判了封建时期中国的许多问题，不过黄仁宇也在附录中通过他人之言表达了对新中国的期盼之情。他特意提及《万历十五年》英文本《富序》中有下面一段：</p><blockquote><p>Historians may re-examine the mistakes of the past in the hope of providing warnings for the future, but at the same time caution their readers to preserve what is of value. Presumably, for China the experiences of both East and West must be drawn upon. It is essential that the historian lay everything on the table.</p></blockquote><p>不要因为目前的堰塞，忽视中国伟大的地方。</p><p>这实在是史学家们难能可贵的精神。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很早之前就慕名买了《万历十五年》这本书，直到这个国庆假期才花了四天的时间一鼓作气读完。读得过程中便不自觉感慨一些片段写得非常精彩，全文读毕只能说这是我在 2018 年读过最精彩的一本书。&lt;br&gt;
    
    </summary>
    
      <category term="读书简记" scheme="https://blog.joouis.com/categories/%E8%AF%BB%E4%B9%A6%E7%AE%80%E8%AE%B0/"/>
    
    
      <category term="history" scheme="https://blog.joouis.com/tags/history/"/>
    
      <category term="politics" scheme="https://blog.joouis.com/tags/politics/"/>
    
  </entry>
  
  <entry>
    <title>读书简记：《极限控制》</title>
    <link href="https://blog.joouis.com/2018/08/11/reading-notes-extreme-ownership/"/>
    <id>https://blog.joouis.com/2018/08/11/reading-notes-extreme-ownership/</id>
    <published>2018-08-11T08:16:08.000Z</published>
    <updated>2018-08-11T08:16:08.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>《极限控制》这本书是从同事手里收来的，买得时候以为是讲战争故事，读得过程中才发现是本讲解领导力的书。中文翻译得一般，尤其是书名（原书名为 <strong>Extreme Ownership</strong>）起得让人摸不着头脑，有点烂名字毁了一本书的既视感。</p><p>虽然是误打误撞买得书，我却很乐意将它读完，因为工程师太需要学习一些管理技巧，但平时又不怎么有机会接触到这些东西。从正向看一是帮助管理自己，二是即使一直做技术也会逐渐开始带团队、成为 TL，如何带好一个团队、最大化其战斗力是一门学问；反向说来，从实习到工作发现有不少技术过人的工程师是非常厉害的 IC （Individual Contributor），但可能并非优秀的老板，是管理和沟通成为了他们的绊脚石。<br><a id="more"></a></p><p>书中通过每一个战争案例总结出一点或多点道理，在此摘抄几条我比较有感触的结论。</p><ul><li>关于制定规划</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1. </span>任务分析</span><br><span class="line">  - 理解高层下达的任务、意图，以及分析任务的目标</span><br><span class="line">  - 自行考虑你所希望达成的目标</span><br><span class="line"><span class="bullet">2. </span>确认参与任务的人力、可利用的资源，确定合适的时间</span><br><span class="line"><span class="bullet">3. </span>分散规划权</span><br><span class="line">  - 允许主要相关之人制定相应的行动步骤</span><br><span class="line"><span class="bullet">4. </span>确定行动步骤</span><br><span class="line">  - 主要关注最重要的步骤</span><br><span class="line"><span class="bullet">5. </span>允许主要负责人为所选的步骤制订计划</span><br><span class="line"><span class="bullet">6. </span>为行动的每一步可能出现的意外情况做出计划</span><br><span class="line"><span class="bullet">7. </span>尽可能控制可控的风险</span><br><span class="line"><span class="bullet">8. </span>将主要的任务分派给主要的相关负责者</span><br><span class="line">  - 退后一步，成为指挥天才</span><br><span class="line"><span class="bullet">9. </span>就已经出现的情况对计划进行检验，提出质疑，确保这一计划仍然适用于当前的局面</span><br><span class="line"><span class="bullet">10. </span>简单明了地将这一计划通告所有参与行动的人及支援行动的人</span><br><span class="line">  - 强调“指挥官的意图”</span><br><span class="line">  - 参与集团讨论，并提问</span><br><span class="line"><span class="bullet">11. </span>结束任务之后做“战后汇报”</span><br><span class="line">  - 总结经验教训，并将它们用于以后的行动规划中</span><br></pre></td></tr></table></figure><ul><li>关于沟通</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>无论向上级报备情况，还是向下级传达命令，你都应该采取负责任的态度</span><br><span class="line"><span class="bullet">- </span>若某人没有做你期望的事，首先检讨自己，看看怎样做才能达成所愿</span><br><span class="line"><span class="bullet">- </span>不要向上级询问应该怎么做，而是要告诉他们你准备做什么</span><br></pre></td></tr></table></figure><ul><li>关于“优秀的人”的对立统一</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>自信而不自大</span><br><span class="line"><span class="bullet">- </span>勇敢而不莽撞</span><br><span class="line"><span class="bullet">- </span>关心细节却不会为之左右</span><br><span class="line"><span class="bullet">- </span>坚强且有耐力</span><br><span class="line"><span class="bullet">- </span>善于指挥也要乐于服从</span><br><span class="line"><span class="bullet">- </span>果敢而不专横</span><br><span class="line"><span class="bullet">- </span>平静而不沉默</span><br><span class="line"><span class="bullet">- </span>冷静而不呆板，有逻辑而不乏情趣</span><br><span class="line"><span class="bullet">- </span>跟伙伴打成一片，但不能太过亲近，让其他人取代了你，更不能让坏人取代了你</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《极限控制》这本书是从同事手里收来的，买得时候以为是讲战争故事，读得过程中才发现是本讲解领导力的书。中文翻译得一般，尤其是书名（原书名为 &lt;strong&gt;Extreme Ownership&lt;/strong&gt;）起得让人摸不着头脑，有点烂名字毁了一本书的既视感。&lt;/p&gt;
&lt;p&gt;虽然是误打误撞买得书，我却很乐意将它读完，因为工程师太需要学习一些管理技巧，但平时又不怎么有机会接触到这些东西。从正向看一是帮助管理自己，二是即使一直做技术也会逐渐开始带团队、成为 TL，如何带好一个团队、最大化其战斗力是一门学问；反向说来，从实习到工作发现有不少技术过人的工程师是非常厉害的 IC （Individual Contributor），但可能并非优秀的老板，是管理和沟通成为了他们的绊脚石。&lt;br&gt;
    
    </summary>
    
      <category term="读书简记" scheme="https://blog.joouis.com/categories/%E8%AF%BB%E4%B9%A6%E7%AE%80%E8%AE%B0/"/>
    
    
      <category term="management" scheme="https://blog.joouis.com/tags/management/"/>
    
      <category term="leadership" scheme="https://blog.joouis.com/tags/leadership/"/>
    
      <category term="ownership" scheme="https://blog.joouis.com/tags/ownership/"/>
    
  </entry>
  
  <entry>
    <title>Javascript 简洁之道：如何使用类重构</title>
    <link href="https://blog.joouis.com/2018/08/06/how-you-can-refactor-to-use-classes/"/>
    <id>https://blog.joouis.com/2018/08/06/how-you-can-refactor-to-use-classes/</id>
    <published>2018-08-06T02:29:06.000Z</published>
    <updated>2018-08-06T02:29:06.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote><p>源文链接：<a href="https://medium.freecodecamp.org/javascript-code-cleanup-how-you-can-refactor-to-use-classes-3948118e4468" target="_blank" rel="noopener">JavaScript code cleanup: how you can refactor to use Classes</a></p></blockquote><p>在一些小规模的 React 工程中，将组件里所用的所有方法维护在组件内部没什么问题。不过到了中等规模的项目时，你可能会将那些方法从组件抽取到一个 “helper” 里。本文将展示如何使用类（而非导出独立的函数和变量）来组织代码。<br><a id="more"></a></p><p>注：我使用 React，因此这里讨论的例子也均是 React 所写。</p><h2 id="典型的重构"><a href="#典型的重构" class="headerlink" title="典型的重构"></a>典型的重构</h2><p>一次典型的重构中，我们通常会把组件中的函数维护在一个帮助文件里。</p><p>从：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyComponent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> someFunction = <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'Hey, I am text'</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;someFunction()&#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>到：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; someFunction &#125; <span class="keyword">from</span> <span class="string">'functionHelper.js'</span></span><br><span class="line"><span class="keyword">const</span> MyComponent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;someFunction()&#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> someFunction = <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'Hey, I am text'</span></span><br></pre></td></tr></table></figure><p>这个例子很二，不过你可以从中看到重构的思路：</p><ol><li>将你的函数复制粘贴到一个独立的文件；</li><li>导入它们并像之前一样调用。</li></ol><p>当逻辑复杂起来，你将不得不传一些如控制状态的对象、函数到这些函数里。如今我就遇到一个问题：我有三个入参相同（一个 <code>资源</code> 和一个更新 <code>资源</code> 的函数）的函数希望从组件中提取出来。于是乎就酝酿出了更好的方法…</p><h2 id="使用类重构"><a href="#使用类重构" class="headerlink" title="使用类重构"></a>使用类重构</h2><p>我为本文做了一个隆重的演示，你可以在 <a href="https://github.com/AmberWilkie/class-demo" target="_blank" rel="noopener">GitHub</a> 上查阅源码。初始的提交显示所有功能都写在主组件中（<code>App.js</code>），而随后的提交逐渐使用了类重构代码。</p><p><img src="https://ua6wcg.bn.files.1drv.com/y4mYy_pu9AzJk55bWAa0HOHDdjZDUp6QId12MxyJKxSSyBDQX8L-w321hFpMC47CYkQCl1Hly1JCATTUeP6-KTjE05cxDg46eOARJogyaVeodrYaM3bm3i8hcPo9dbhQ7wQOq0A2SAkUGdhaeS1C7xX2Do4yLK_ThI45fsjemuXGxGAb0UeuqpqghFkUUr-kqnLmw7AQZVQh1-kHQTP9mkTYQ" alt></p><p>你可以尝试运行该工程，不过请记得 <code>yarn install</code> 安装依赖。</p><p>我们从一个”获取”对象（通常是请求一个 API 接口）的组件开始，它有一些确切的属性：repeat（盒子的个数），side（高和宽），text，color。接着我们有一系列操作视图的方法——改变色彩，更新文字，等等。每次视图更改后，我们展示一条信息。</p><p>举个例子，这是我们改变宽高的方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">changeSide = <span class="function"><span class="params">side</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> obj = &#123;...this.state.obj, side&#125;;</span><br><span class="line">  <span class="keyword">this</span>.fetchObject(obj);</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123; <span class="attr">message</span>: <span class="string">`You changed the sides to <span class="subst">$&#123;side&#125;</span> pixels!`</span> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能有些方法中也需要类似的操作，或许这些方法大不相同。这时候我们可能开始考虑将这段代码放到一个帮助文件里，然后创建另一个方法调用 <code>setState</code> ，同时需要将状态对象、<code>side</code> 参数以及 <code>this.fetchObject</code> 传入其中。如果类似的方法多了起来，那么就会存在大量的参数传递，从而导致代码重构起不到作用（或缺乏可读性）。</p><p>取而代之，我们可以使用类的构造函数方法来实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectManipulator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>( &#123; object, fetchObject, markResettable, updateMessage, updateStateValue &#125; ) &#123;</span><br><span class="line">    <span class="keyword">this</span>.fetchObject = fetchObject;</span><br><span class="line">    <span class="keyword">this</span>.markResettable = markResettable;</span><br><span class="line">    <span class="keyword">this</span>.updateMessage = updateMessage;</span><br><span class="line">    <span class="keyword">this</span>.updateStateValue = updateStateValue;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  changeSide = <span class="function">(<span class="params"> object, side </span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> newObject = &#123; ...object, side &#125;;</span><br><span class="line">    <span class="keyword">this</span>.fetchObject(newObject);</span><br><span class="line">    <span class="keyword">this</span>.updateMessage(<span class="string">`You changed the sides to <span class="subst">$&#123;side&#125;</span> pixels!`</span>);</span><br><span class="line">    <span class="keyword">this</span>.markResettable();</span><br><span class="line">    <span class="keyword">this</span>.updateStateValue(<span class="string">'side'</span>, side);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这允许我们创建一个能在主组件中调用其函数的对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> manipulator = <span class="keyword">new</span> ObjectManipulator(&#123;</span><br><span class="line">  object,</span><br><span class="line">  fetchObject: <span class="keyword">this</span>.fetchObject,</span><br><span class="line">  markResettable: <span class="keyword">this</span>.markResettable,</span><br><span class="line">  updateMessage: <span class="keyword">this</span>.updateMessage,</span><br><span class="line">  updateStateValue: <span class="keyword">this</span>.updateStateValue,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上述代码创建了一个对象 <code>manipulator</code> —— <code>ObjectManipulator</code> 类的实例。当我们调用 <code>manipulator.changeSide(object, &#39;800&#39;)</code> 时，将执行之前定义好的 <code>changeSide</code> 方法。这里无需传递 <code>updateMessage</code> 或任何其他方法——当实例创建时已经在构造函数中对这些方法赋好了值。</p><p>可以想象如果我们有许多类似的方法需要处理时这招将变得非常管用。就我而言，我需要在一个异步事件后调用 <code>.then(res =&gt; myFunction(res))</code> 。相比于将 <code>myFunction</code> 传入每个函数的做法，在类实例中提前定义它节省了不少代码。</p><h2 id="保持所有事情井井有条"><a href="#保持所有事情井井有条" class="headerlink" title="保持所有事情井井有条"></a>保持所有事情井井有条</h2><p>这种组织方法还可以促进代码互不越界。例如在前文的范例里，按钮的颜色维护在一个对应的数组之中，将此常量放到 <code>ObjectManipulator</code> 可以确保其不会与应用中的其他 <code>colors</code> 冲突：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectManipulator</span> </span>&#123;</span><br><span class="line">  [...]</span><br><span class="line"></span><br><span class="line">  colors = [<span class="string">'blue'</span>, <span class="string">'red'</span>, <span class="string">'orange'</span>, <span class="string">'aquamarine'</span>, <span class="string">'green'</span>, <span class="string">'gray'</span>, <span class="string">'magenta'</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>鉴于其他地方存在全局 <code>colors</code> 常量的可能性，我可以使用 <code>manipulator.colors</code> 正确地获取我想要的颜色。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="noopener">Good old Mozilla Class docs</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;源文链接：&lt;a href=&quot;https://medium.freecodecamp.org/javascript-code-cleanup-how-you-can-refactor-to-use-classes-3948118e4468&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JavaScript code cleanup: how you can refactor to use Classes&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在一些小规模的 React 工程中，将组件里所用的所有方法维护在组件内部没什么问题。不过到了中等规模的项目时，你可能会将那些方法从组件抽取到一个 “helper” 里。本文将展示如何使用类（而非导出独立的函数和变量）来组织代码。&lt;br&gt;
    
    </summary>
    
      <category term="Web 前端" scheme="https://blog.joouis.com/categories/Web-%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="refactor" scheme="https://blog.joouis.com/tags/refactor/"/>
    
      <category term="javascript" scheme="https://blog.joouis.com/tags/javascript/"/>
    
      <category term="react" scheme="https://blog.joouis.com/tags/react/"/>
    
      <category term="hoc" scheme="https://blog.joouis.com/tags/hoc/"/>
    
  </entry>
  
  <entry>
    <title>简易计数器——年轻人的第一个Flutter应用</title>
    <link href="https://blog.joouis.com/2018/07/25/first-flutter-app-review/"/>
    <id>https://blog.joouis.com/2018/07/25/first-flutter-app-review/</id>
    <published>2018-07-24T18:17:05.000Z</published>
    <updated>2018-07-24T18:17:05.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h2><p>站在负责 UI 层的 Web 前端视角看无线端框架，评判的第一个标准无非是文档够不够全、Demo 能不能很容易在手机上跑起来。近来的热门框架 Flutter 就上手而言给出了漂亮的答案。<br><a id="more"></a></p><h2 id="Prolog"><a href="#Prolog" class="headerlink" title="Prolog"></a>Prolog</h2><ul><li>我是谁：曾是 Embedded C 开发的 Web 前端攻城狮，完全没有 <code>dart</code> 或是 <code>flutter</code> 开发经验</li><li>开发环境：MacBook Pro，XCode with iOS simulator</li><li>学习初心：2018 年的 Weex 开发体验依然不好，不如拥抱下一个技术红利（假笑.jpg</li><li>种草文：什么你还没听过 Flutter，简单介绍一下吧《<a href="https://mp.weixin.qq.com/s/xV-FGR9o2ODLFJFq4YwnKg" target="_blank" rel="noopener">Release Flutter的最后一公里</a>》</li><li>最后一句话：以下”学习笔记”中，若有错误/模糊概念请友好指正，么么哒</li></ul><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Flutter 最近真的是大热，可能笔者身处阿里的缘故，自从咸鱼在他们的商品详情页成功使用后，集团内无论是 ATA 技术论坛还是周报都能看到有人学习研究这门技术。</p><p>笔者一直都想尝试原生的无线端开发，在错过 React Native、受够 Weex 之后，身处这个时间点刚好趁热学习一下 Flutter，说不定这次真的跟过往的轮子不一样。</p><h2 id="Setup"><a href="#Setup" class="headerlink" title="Setup"></a>Setup</h2><p>照着<a href="https://flutter.io/get-started/install/" target="_blank" rel="noopener">官方文档</a>来，一切还算顺利：装好 Flutter SDK，<code>flutter doctor</code> 把相关依赖都装好，插上 iPhone 手机，VS Code 新建一个 <code>Flutter Demo</code> 工程，调试…</p><p>在真机调试时，出现了第一个与苹果应用验证相关的问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Failed to create provisioning profile.</span><br><span class="line">The app ID &quot;com.example.flutterFlutterDemo&quot; cannot be registered to your development team. Change your bundle identifier to a unique string to try again.</span><br></pre></td></tr></table></figure><p>解决方法有两种：</p><ol><li>使用自己的 Apple ID，详见<a href="http://bbs.sightp.com/thread-1241-1-1.html" target="_blank" rel="noopener">这里</a>；（好吧我也没试过）</li><li>使用模拟器。</li></ol><p>命令行输入 <code>open ios/Runner.xcworkspace</code> 打开 Runner 工程，选择模拟器即可跑起来默认的 Demo 工程。</p><h2 id="Code-Review-for-Official-Counter"><a href="#Code-Review-for-Official-Counter" class="headerlink" title="Code Review for Official Counter"></a>Code Review for Official Counter</h2><h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><p>官方默认的 Demo 工程是一个简易计数器。先看眼效果，真的非常简单，右下角点击加号，中间的数字对应增长，就酱~</p><p><img src="https://ua60cg.bn.files.1drv.com/y4mx50xV8910Opf1_TigYabB06b-3qTsFGJf8KmR8dFIArUO5nb5BpePdYkUfp_JA9tj_DeBthEENIc1l8QFt9hVkSDojcSlBHbx7tIxOlqwXqVyrvW1pTDYPTNOj57MVyos5giC9Uv_YTAlLDUcz5ZsH-7vvVEwt_tiwodR5tawta_g1V30y9Br8QdL6TAmuF9Rf603Y4DUjvVFrXZ6a0UwQ" alt></p><p>外行看热闹，内行看门道。应用层代码总共就六十多行，反正也不会 Dart，就边看边学习一下。</p><h3 id="Import"><a href="#Import" class="headerlink" title="Import"></a>Import</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br></pre></td></tr></table></figure><p>首先是 Dart 依赖的导入。Dart 使用 <code>pubspec.yaml</code> 文件定义工程和依赖，类似 Node 世界里的 <code>package.json</code>；<code>pub</code> 则是对应 <code>npm</code> 的存在，<code>pub get</code> 一下即可安装相关的依赖包；安装完成后，会在项目根目录生成一个 <code>.packages</code> 文件，记录了所有依赖包在系统中对应的缓存地址，大概长这样：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> Generated by pub on 2018-07-18 20:28:35.360131.</span><br><span class="line">analyzer:file:///Users/joou/workspace/flutter/.pub-cache/hosted/pub.dartlang.org/analyzer-0.31.2-alpha.2/lib/</span><br></pre></td></tr></table></figure><p>再来说说最上方的引用语句。除了引用相对路径的 dart 文件外，引用包需加上 <code>package:</code> 前缀，Dart 运行时会自动去查询包文件。那这里引用的 <code>flutter/material.dart</code> 在哪呢？笔者的第一反应是在 Flutter SDK 工程中，果不其然在此：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">joou 2018-07-19 Thu 11:36:~/workspace/flutter/packages/flutter/lib(beta 50d8h)</span><br><span class="line"><span class="meta">$</span> ls</span><br><span class="line">analysis_options_user.yaml foundation.dart            painting.dart              scheduler.dart             src</span><br><span class="line">animation.dart             gestures.dart              physics.dart               semantics.dart             widgets.dart</span><br><span class="line">cupertino.dart             material.dart              rendering.dart             services.dart</span><br></pre></td></tr></table></figure><p>SDK 中已经内置了不少包，让我们看看 <code>material.dart</code> 这个物料包里有些啥：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="string">'src/material/about.dart'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="string">'src/material/animated_icons.dart'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="string">'src/material/app.dart'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="string">'src/material/app_bar.dart'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="string">'src/material/arc.dart'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="string">'src/material/back_button.dart'</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>所以说 <code>flutter/lib</code> 下的包文件类似一个入口，类似 C 语言里的 header file，暴露给外界 <code>flutter/lib/src</code> 中的各种组件，想要深入了解某个包的具体实现去对应目录下即可找到真相。</p><p>当然，除了自己 xjb 探索外，也别忘了阅读<a href="https://docs.flutter.io/flutter/material/material-library.html" target="_blank" rel="noopener">官方文档</a>，因为接下来的代码基本都要靠文档救命。</p><h3 id="App-Entry"><a href="#App-Entry" class="headerlink" title="App Entry"></a>App Entry</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() =&gt; runApp(<span class="keyword">new</span> MyApp());</span><br></pre></td></tr></table></figure><p>Dart 的每一个程序应用最顶层都要有一个 <code>main()</code> 函数作为入口，这和 C 语言是一致的。此外还有 <code>void</code> 类型，代表返回值可以是任意类型。Dart 是 OO 范式的语言，函数、方法都是对象，存在一个对应的类型，因此在定义函数时最好申明其返回值类型。<code>=&gt;</code> 语法是 <code>{ return expr; }</code> 的简写，注意里面不允许出现 statement (Eg. <code>if</code> )。上述代码一样可改写为：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">return</span> runApp(<span class="keyword">new</span> MyApp());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>runApp()</code> 是 Flutter 提供的<a href="https://docs.flutter.io/flutter/widgets/runApp.html" target="_blank" rel="noopener">函数</a>，其作用是将一个 <code>Widget</code> 类的实例（作为其入参）挂载（attach）到屏幕上，逻辑大概如下：</p><ol><li>检查 <code>WidgetsFlutterBinding</code> 是否初始化；</li><li>将控件（widget）实例挂载到 <code>renderViewElement</code> 上，这个元素是渲染层级的根节点实例；</li><li>调用 <code>scheduleWarmUpFrame()</code> 方法，开始渲染。</li></ol><h3 id="Stateless-Widget"><a href="#Stateless-Widget" class="headerlink" title="Stateless Widget"></a>Stateless Widget</h3><p>接下来让我们看看 <code>MyApp</code> 类。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MaterialApp(</span><br><span class="line">      title: <span class="string">'Flutter Counter'</span>,</span><br><span class="line">      theme: <span class="keyword">new</span> ThemeData(</span><br><span class="line">        primarySwatch: Colors.orange,</span><br><span class="line">      ),</span><br><span class="line">      home: <span class="keyword">new</span> MyHomePage(title: <span class="string">'Flutter Trivial Counter 🙃'</span>),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此控件是应用的根节点。首先它作为子类继承了 <code>StatelessWidget</code> ，无状态是指它不需要可变状态，而是通过构建其他的控件来更具体地描述 UI，构建过程以递归方式执行，直到 UI 被完全具象化。可能这么说比较抽象，不过先别急，后面的代码会解释什么叫具象化。在 <code>MyApp</code> 中，重载了 <code>build</code> 方法，实例化了一个 <code>MaterialApp</code> 对象。</p><p>如果你写过 React 框架，那么我想换个方法解释可能更好理解。<code>StatelessWidget</code> 好比 React 中的 <code>PureComponent</code> ，而 <code>Widget</code> 类的 <code>build</code> 方法好比 React 中的 <code>render</code>。<code>build</code> 方法负责描述控件代表的 UI ，入参是构造的上下文，内容则是使用 <code>MaterialApp</code> 对象的实例描述 UI。实例化的过程中进行了一些配置，例如命名为 “Flutter Counter”，使用橙色主题，主页标题栏的文字设为 “Flutter Trivial Counter 🙃”。即便完全不知道 <code>MaterialApp</code> 类的内部实现，也很容易猜到它更具体地定义了一些 UI 内容。</p><p>React 是具备生命周期的，当 <code>componentWillUpdate</code> 钩子触发后将执行 <code>render</code> 方法，重新渲染组件。而 <code>PureComponent</code> 则是通过在渲染前（例如在 <code>shouldComponentUpdate</code> 钩子中）浅对比新旧 props 和 state 判断是否需要重新渲染，从而实现性能优化。同理，控件的 <code>build</code> 方法将会在其 lifetime 的以下时刻被调用：</p><ul><li>调用 <a href="https://docs.flutter.io/flutter/widgets/State/initState.html" target="_blank" rel="noopener">iniState</a> 之后。</li><li>调用 <a href="https://docs.flutter.io/flutter/widgets/State/didUpdateWidget.html" target="_blank" rel="noopener">didUpdateWidget</a> 之后。</li><li>收到 <a href="https://docs.flutter.io/flutter/widgets/State/setState.html" target="_blank" rel="noopener">setState</a> 的请求后。</li><li>在 <a href="https://docs.flutter.io/flutter/widgets/State-class.html" target="_blank" rel="noopener">State</a> 对象的依赖之一改变（例如被之前的 <a href="https://docs.flutter.io/flutter/widgets/State/build.html" target="_blank" rel="noopener">build</a> 方法引用的某个 <a href="https://docs.flutter.io/flutter/widgets/InheritedWidget-class.html" target="_blank" rel="noopener">InheritedWidget</a> 发生了改变）后。</li><li>调用 <a href="https://docs.flutter.io/flutter/widgets/State/deactivate.html" target="_blank" rel="noopener">deactivate</a> 后重新在挂件树的另一个位置注入 <a href="https://docs.flutter.io/flutter/widgets/State-class.html" target="_blank" rel="noopener">State</a> 类。</li></ul><p>而 <code>StatelessWidget</code> 中的 <code>build</code> 方法仅在三种情况中被调用：</p><ul><li>控件第一次被插入挂件树中，也就是初始化时。</li><li>控件的父亲改变了自身配置。</li><li>控件依赖的继承控件类改变。</li></ul><p>这和 React 是何等的相似（此处感慨 3 秒…）！因此减少无状态控件的重新构建也是一门优化技巧，在此不延伸了，有兴趣请看<a href="https://docs.flutter.io/flutter/widgets/StatelessWidget-class.html" target="_blank" rel="noopener">文档</a>。至于 <code>MaterialApp</code> 类的内部配置在此也不深入，有机会再研究、分享一下这些官方组件。让我们看看配置中描述主页的 <code>MyHomePage</code> 挂件吧，这是在应用代码中实现的。</p><h3 id="Stateful-Widget"><a href="#Stateful-Widget" class="headerlink" title="Stateful Widget"></a>Stateful Widget</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  MyHomePage(&#123;Key key, <span class="keyword">this</span>.title&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> title;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _MyHomePageState createState() =&gt; <span class="keyword">new</span> _MyHomePageState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MyHomePage</code> 是一个有状态的挂件，最底部重载了 <code>createState</code> 方法定义其状态，用来描述 UI，这个稍后再细看。通常如果父类（superclass）没有默认的构造函数，dart 则要求子类在代码块的初始位置使用 <code>:</code> 指定父类的构造函数。而 <code>Key key</code> 用来申明可选参数（optional parameter），此处申明了 <code>title</code> 变量（field）。<code>title</code> 变量的值由父类赋予，被其 <code>State</code> 类的 <code>build</code> 方法使用渲染，像这种子类挂件的变量通常定义为 <code>final</code> 类型，意味着变量只能被赋值一次。与 <code>const</code> 不同的是 <code>final</code> 变量在程序运行时才赋值，而非编译时期就定义好的常量。</p><h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><p>让我们最后瞅瞅首页挂件的状态类。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> _counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _incrementCounter() &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      _counter++;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Scaffold(</span><br><span class="line">      appBar: <span class="keyword">new</span> AppBar(</span><br><span class="line">        title: <span class="keyword">new</span> Text(widget.title),</span><br><span class="line">      ),</span><br><span class="line">      body: <span class="keyword">new</span> Center(</span><br><span class="line">        child: <span class="keyword">new</span> Column(</span><br><span class="line">          mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            <span class="keyword">new</span> Text(</span><br><span class="line">              <span class="string">'老铁没毛病，双击:'</span>,</span><br><span class="line">            ),</span><br><span class="line">            <span class="keyword">new</span> Text(</span><br><span class="line">              <span class="string">'<span class="subst">$_counter</span>'</span>,</span><br><span class="line">              style: Theme.of(context).textTheme.display1,</span><br><span class="line">            ),</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      floatingActionButton: <span class="keyword">new</span> FloatingActionButton(</span><br><span class="line">        onPressed: _incrementCounter,</span><br><span class="line">        tooltip: <span class="string">'Increment'</span>,</span><br><span class="line">        child: <span class="keyword">new</span> Icon(Icons.add),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好吧这也是笔者第一次接触泛型，看过<a href="https://www.dartlang.org/guides/language/language-tour#generics" target="_blank" rel="noopener">官方文档</a>的例子后觉得还是比较好理解。<code>MyHomePage</code> 继承了拥有可变状态的 <code>StatefulWidget</code> 类，当其第一次被插入控件树中时，Flutter 框架会调用 <code>createState</code> 函数创建一个全新的 <code>_MyHomePageState</code> 实例与树中的位置相关联。当挂件的父组件重新构建（rebuild）时，父组件会重新创建一个 <code>MyHomePage</code> 实例，但是将复用已有的 <code>_MyHomePageState</code> 对象。</p><p><code>_MyHomePageState</code> 定义了一个数字类型的 <code>_counter</code> ，另外自定义了一个 <code>_incrementCounter</code> 方法每次对 <code>_counter</code> 值加一。加一语句写在 <code>setState</code> 方法中，当被执行完后，会触发 Flutter 框架重新运行下方的 <code>build</code> 方法，以达到最终更新界面的目的。虽然推荐将状态变更的代码写在 <code>setState</code> 的回调函数中，但这么改写也是可以正常工作的…</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _incrementCounter() &#123;</span><br><span class="line">  _counter++;</span><br><span class="line">  setState(() &#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后的最后，在 <code>_MyHomePageState</code> 的 <code>build</code> 方法里，初始化并返回了一个 <code>Scaffold</code> 实例，源自 Material 组件。每当 <code>setState</code> 被触发后，就将执行一次 <code>build</code> 方法。不过 Flutter 框架号称优化过重跑 <code>build</code> 方法的性能，无需担心重新构建的成本。</p><p><code>Scaffold</code> 类配置了三处地方：</p><ul><li>新建一个 <code>appBar</code> 实例。这里通过 <code>widget</code> 属性获取到了 <code>MyHomePage</code> 挂件中的属性，此外还可以通过 <a href="https://docs.flutter.io/flutter/widgets/State-class.html#didUpdateWidget" target="_blank" rel="noopener"><code>didUpdateWidget</code></a> 钩子在 <code>widget</code> 发生改变时进行操作。</li><li><code>body</code> 属性被赋予了 <code>Center</code> 实例，无论是 <code>Center</code> 还是 <code>Column</code> 都是布局（layout）挂件。前者可以定位到父组件的中心位置，而后者将会水平排列其子组件。<code>Column</code> 挂件有多种属性控制样式，这里使用了 <code>mainAxisAlignment</code> 将其子组件垂直居中（别糊涂，列的主轴是垂直方向）。</li><li>屏幕右下角的按钮由 <code>FloatingActionButton</code> 描述，使用了加号图标，绑定之前定义好的 <code>_incrementCounter</code> 函数作为 <code>onPressed</code> 事件的处理者。</li></ul><p>好了说了这么多组件，让我们使用 Flutter tool 的 <code>Toggle Debug Paint</code> 指令直观感受一把。</p><p><img src="https://ua6zcg.bn.files.1drv.com/y4mUF6sd-hueRZgEbFQx1UmVfQaYGtyEK6TXqqpD3Z-VB4Bj49dDyTKooH_yZESWfth4XK8OHc_p-WlaNIEaCBv51mZYrSlNxtjPJShjlLFWf1qLXV3-5OPc88KJQQxt2_WGdzV32Fljycb9HjfMPAaqaMUm6_tyXGZ_NJilhRUVpX92WQ8LRT1j_CQPOHxpUXajsuzAuDrht8FpZt-jc4ItA" alt></p><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2><p>笔者去年写了篇 Weex 从入门到放弃的上手文，说实话这次 Flutter 上手体验要比 Weex 好非常多——详实的文档，齐全的基础脚手架，轻松在手机/模拟器上运行应用。</p><p>对于没有客户端开发经验的笔者来说，能看着文档打通流程（实际编译出一个安装包并在对应平台上安装、执行）是一件非常关键的事情，它意味着小白也能使用这项技术栈独立开发简单的应用，能给学习者十足的信心。过去接触 Weex，只能使用 Playground App 扫码跑 demo，非常的“半成品”，而 Flutter 轻松几个指令，就在你的设备上跑起了你的工程，赞！</p><p>至于 Flutter 相关的信息，如学习 Dart 语言、Flutter 入门教程、代码范例、官方库接口等资料已经颇为丰富，Stack Overflow 上也有一些讨论的话题，对于一个处于 Beta 阶段的框架来很成熟了。</p><p>接下来就期待国内外有更多关于 Flutter 的线上生产实践经验，笔者有空也会接着研究并分享 Flutter 的知识。</p><p>如果你看了这篇文章感到意犹未尽，那么再提供一点延伸阅读：</p><ul><li><a href="https://www.youtube.com/watch?v=UUfXWzp0-DU" target="_blank" rel="noopener">Flutter’s Rendering Pipeline</a></li><li><a href="https://flutter.io/widgets-intro/" target="_blank" rel="noopener">A Tour of the Flutter Widget Framework</a></li></ul><p>相信你能从上述两个方向发现更多一手、可靠、丰富的信息！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;TL-DR&quot;&gt;&lt;a href=&quot;#TL-DR&quot; class=&quot;headerlink&quot; title=&quot;TL;DR&quot;&gt;&lt;/a&gt;TL;DR&lt;/h2&gt;&lt;p&gt;站在负责 UI 层的 Web 前端视角看无线端框架，评判的第一个标准无非是文档够不够全、Demo 能不能很容易在手机上跑起来。近来的热门框架 Flutter 就上手而言给出了漂亮的答案。&lt;br&gt;
    
    </summary>
    
      <category term="Web 前端" scheme="https://blog.joouis.com/categories/Web-%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="mobile" scheme="https://blog.joouis.com/tags/mobile/"/>
    
      <category term="app" scheme="https://blog.joouis.com/tags/app/"/>
    
      <category term="flutter" scheme="https://blog.joouis.com/tags/flutter/"/>
    
      <category term="dart" scheme="https://blog.joouis.com/tags/dart/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 性能优化概观</title>
    <link href="https://blog.joouis.com/2018/07/17/javascript-performance-optimization-tips-an-overview/"/>
    <id>https://blog.joouis.com/2018/07/17/javascript-performance-optimization-tips-an-overview/</id>
    <published>2018-07-17T03:28:57.000Z</published>
    <updated>2018-07-17T03:28:57.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote><p>源文链接：<a href="https://www.sitepoint.com/javascript-performance-optimization-tips-an-overview/" target="_blank" rel="noopener">JavaScript Performance Optimization Tips: An Overview</a></p></blockquote><p>我们将坚持“工具不代表规则（Tools, not rules）”的老话，尽量少提 JS 相关的流行术语。很显然我们不可能在一篇 2000 来字的文章里覆盖 JS 性能的方方面面，因此请在后续阅读本文的参考书目并自行研究。</p><p>不过在深入细节之前，先让我们通过回答以下问题来更广义地理解性能优化：高性能的 JS 要考虑哪些指标？这些指标如何与更高维度的 web 性能指标融为一体？<br><a id="more"></a></p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>首先，让我们避开如下事情：如果你只在台式机上测试，你已将 <a href="http://gs.statcounter.com/platform-market-share/desktop-mobile-tablet" target="_blank" rel="noopener">超过 50%</a> 的用户排除在外了。</p><p><img src="https://uk6xcg.bn.files.1drv.com/y4mNVFLuHYlzHBeyfNYZsHgIHuDsfmF11B33HcdkHvMvvvIN3F5zXQIMsx5f2T6FTwIjNOB924XGxOyLVwfhrceWQTgqSANcEEglZy_zXdhayApGYOSCA68RyeOsEEbxzfRIGozZuO_wrU79c35vJqQz5o454NRbJRpJj0mT3uoxsXAsuaNwKWhSpxXoi3rlfbhxEa4ztlINll-bSMqHfPDnw" alt></p><p>由于新兴市场偏爱使用低于 100 美金的安卓设备上网，该趋势只会持续增长。台式机作为主力上网设备的时代已经结束，未来十亿网民将会首选移动设备访问你的网站。</p><p>Chrome DevTool 工具的设备模拟器并不能有效替代真实设备进行测试。即便限制 CPU 和网络性能有所帮助，但它相比性能较弱的真实设备来说完全是另一个等级。所以请在真实设备上测试！</p><p>即使是使用真实设备测试，你也很可能用的是自己新买的高端旗舰机。然而，这并非你的用户使用的设备。让我们看看配置处在中等水平的移动设备，例如摩托罗拉的 G1，只有不足 1GB 的运行内存、孱弱的 CPU 和 GPU。</p><p>当 <a href="https://docs.google.com/spreadsheets/d/1wHcNNQea28LhwQ_amFamT33d5woVrJfJy53Z1k6V090" target="_blank" rel="noopener">解析一个文件体积为平均数的 JS 包</a>（JS bundle）时，让我们看看它的解析速度排名。</p><p><img src="https://uk6wcg.bn.files.1drv.com/y4m0-ZmIf1Xp68or_HfkesuOljc0Gw252YypTC3P6P6VpgBHI0-gXEYaaEyF8nqlDWnJSBxCTdFSIRjZULLHMFEkR8Zfkne6s8bJnYmdD5a9BPj2YVHDLfTIFYICJvJ2ff6ycJCauE298dxQFhFM3fysXz9rOBSmqxpl4bET8VLjW1R4Xh_JkU2rgZU90d_czDrPEM5eG7_ufUqskK0hI2xPg" alt="Addy Osmani: Time spent in JS Parse &amp; eval for average JS"></p><p>虽然这张图只涵盖了 JS 解析和编译的时间（后续时间将会消耗更多）而非常规的性能数据，但有着强关联的它可以被视作 JS 性能的指标之一。</p><p>Bruce Lawson 曾说 “<a href="https://vimeo.com/194968584" target="_blank" rel="noopener">it’s the World-Wide Web, not the Wealthy Western Web</a>”。因此你需要在比你的 MacBook 或 iPhone 慢 25 倍左右的设备上探讨 web 性能。让我们看看我们的实际目标是什么。</p><h2 id="高性能的-JS-代码是怎样的？"><a href="#高性能的-JS-代码是怎样的？" class="headerlink" title="高性能的 JS 代码是怎样的？"></a>高性能的 JS 代码是怎样的？</h2><p>现在我们了解了我们的目标平台，就可以解答下一个问题：高性能的 JS 代码是什么？</p><p>虽说没有绝对的分类来定义高性能代码，但我们有一个以用户为中心的性能模型可以参考：<a href="https://developers.google.com/web/fundamentals/performance/rail" target="_blank" rel="noopener">RAIL 模型</a>。</p><p><img src="https://uk6vcg.bn.files.1drv.com/y4mmLE_Js1ooQjEX8AGy_4ytOtExYWfJ3SMsL4Q63loBlFj19s2GlTeQBv1fZn-eAP-EBfSbpPCuAjzM29rYAM2iHM-5MrDNa-r8iG_bQhRFSgmLfQuOMbXYeEwf_5PQbzt77QO5qXSVIZ3NZxVoeMDfvHt9zk78ZOuZGGtHZ0TuHo84Gw8qzSZf8_H3-4I-yIzgFPzBMZt6wMUvhuSuyJ2pA" alt="Sam Saccone: Planning for Performance: PRPL"></p><h3 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h3><p>如果你的应用在 100 毫秒内响应用户的操作，给用户的感知就是立即响应。这适用于网页中可敲击的元素，但是滑动或拖拽时则不行。</p><h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><p>在 60Hz 帧率的显示器上，我们期望在动画和滑动时画面恒定在 60 帧每秒，这意味着约 16 毫秒显示一帧。由于 16 毫秒的预算，你实际上只有 8 到 10 毫秒去完成所有工作，剩余时间将被浏览器内部以及其它一些差异消耗掉。（深度阅读：《<a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651228065&amp;idx=2&amp;sn=0db2e69aa9344d4b086e9d98301aebad" target="_blank" rel="noopener">从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理</a>》）</p><h3 id="闲置"><a href="#闲置" class="headerlink" title="闲置"></a>闲置</h3><p>如果你正在运行一个昂贵且持久的任务，请确保将它切分为更小的部分以便主线程有空响应用户的输入。不应该有阻塞用户输入超过 50 毫秒的任务存在。</p><h3 id="负载"><a href="#负载" class="headerlink" title="负载"></a>负载</h3><p>一个页面的加载应低于 1000 毫秒，超过这个时间你的用户将会变得烦躁。而在移动设备上要求页面变得可交互而不仅完成渲染和可滑动时，是一个非常难的目标。实际上，可用于加载的时间往往更少：</p><p><img src="https://ua62cg.bn.files.1drv.com/y4mJXYSoOY-zysDoELXReJbrP9qgAlCz955Rlpuip5GmXG9kWD3BhEIB57MPHkmmbxrvhifOErq5rV54TSjKmsw7UgLrNNIVweRGVcyk4is2K_zZfDXM7HuPreemrsBs1TnplWdvyvi1i3MIndUqprEkSaONy1gWVcJZkXC9ULwXGJ27_3wPKnWFwAUbjxHBl7zgtEVM2p-35t4FbpQP-ZBgw" alt="Fast By Default: Modern Loading Best Practices"></p><p>在实践中，可交互时间以 5 秒为目标，这也是 Chrome 在其 Lighthouse audit 中使用的标志。</p><p>现在我们知道了度量指标，让我们来看<a href="https://storage.googleapis.com/doubleclick-prod/documents/The_Need_for_Mobile_Speed_-_FINAL.pdf" target="_blank" rel="noopener">一些数据统计</a>：</p><ul><li>如果一个移动站点的加载时间超过 3 秒，53% 的访客将会离开</li><li>每两个人中就有一个人期待页面加载时间不超过 2 秒</li><li>大约 77% 的移动站点在 3G 网络下的加载时间超过 10 秒</li><li>移动站点在 3G 网络下的平均加载时间为 19 秒</li></ul><p>此外，<a href="https://medium.com/reloading/javascript-start-up-performance-69200f43b201" target="_blank" rel="noopener">Addy Osmani 还提供了一些信息</a>：</p><ul><li>Apps 变得可交互在 PC 上需要 8 秒（使用网线），而在手机上需要 16 秒（3G 网络的 Moto G4）</li><li>从中位数看，页面依赖的 JS 文件（gzipped 压缩过）大小为 410KB</li></ul><p>你是否感到十分泄气？很好，让我们一起行动，修复网页面临的这些问题。</p><h2 id="上下文即一切"><a href="#上下文即一切" class="headerlink" title="上下文即一切"></a>上下文即一切</h2><p>你可能已经注意到，加载网页的时间是主要瓶颈。确切的说，瓶颈来源于 JavaScript 下载、解析、编译和执行的时间。这个问题没有捷径可走，唯有加载更少的 JS 脚本以及更加聪明地加载它们。</p><p>但是除了启动网站外，你的代码实际上做了哪些工作？这里肯定有些性能可以优化，对吧？</p><p>在你开始优化你的代码前，先想想你要构建的是什么。你在构建一个框架或 VDOM 库吗？你的代码需要每秒执行上千次运算吗？你为了处理用户输入或动画而使用一个时间临界型（time-critical）的库吗？如果没有，你也许应该将时间和精力投入到一些更有用的地方。</p><p>不是说编写高性能的代码不重要，但是从事物的宏观角度来看其影响通常较小，尤其在讨论微优化时。因此，在你踏入 Stack Overflow 通过对比  JSperf.com 上的结果来争论 <code>.map</code> <code>.forEach</code> 和 <code>for</code> 循环方法前，先确保看到了整片森林而非细枝末节。50K 次每秒的操作听起来比 1k 次每秒的操作要好上 50 倍，然而在绝大多数场景下这两者不会有什么区别。</p><h2 id="解析、编译以及执行"><a href="#解析、编译以及执行" class="headerlink" title="解析、编译以及执行"></a>解析、编译以及执行</h2><p>基本上大多数性能不高的 JS 代码问题并未出现在运行时期，而是在代码开始执行前所需的所有步骤。</p><p>我们在这会讨论抽象的层次。电脑中的 CPU 执行的是机器码，而电脑中运行的绝大多数代码是编译过的二进制格式（这里使用“代码”而非“程序”考虑到了近来的 Electron 应用）。也就是说，二进制代码抛开了所有系统层面的抽象，可以在硬件上原生执行，不需要一些预先处理。</p><p>JavaScript 没有被预先编译过。它在浏览器中通过相对较慢的网络被下载为可读的代码，总而言之，浏览器就是 JS 程序的“操作系统”。</p><p>代码首先需要被解析——更确切地说读取并将其变成计算机可寻址的结构以便编译。在设备/浏览器可以执行前，代码还需被编译成字节码，最终是机器码。</p><p>另一件非常重要的事情是 JavaScript 是单线程的，运行在浏览器的主线程上。这意味着一次只有一颗处理器可以运行 JS 代码。如果 Chrome DevTools 的性能时间轴被黄色峰值填充，即 CPU 使用率达到 100%，画面将会出现长帧、掉帧、难用的滑动以及其他所有扎心的体验。</p><p><img src="https://uk6ucg.bn.files.1drv.com/y4mf7OwF4UaBXdoAo5nmOKXVbIO52qOl0GsAP9_bpZNFT0Qm8dEFmJPzIeVLBrmsjgSTK-Mn1V6TQath0tmAFE9cCsSmH0hc_MK5e8I7uar-osIsRW1sKyfFBexLaJg3pSiGKctRsv7a83Bn0N-E6jSb6XDGmsxUx9tf9XmHD7b9nrLEmnmNuR6c8biwbDqpM9O0BW0LCKJ5oii9iLFg0KxgA" alt="Paul Lewis: When everything&#39;s important, nothing is!"></p><p>所以在你的 JS 代码开始运行前，上述所有工作需要完成。在 Chrome V8 引擎执行 JS 代码的总时间中，解析和编译占据了约 50% 的时间。</p><p><img src="https://ua63cg.bn.files.1drv.com/y4mmTS-JT-S3MyBeSJilW_BXMGOnvluzo-h4RC_2PkHPBfg2eU1pv__euNdtWHKIGJz9q67ARN2Hsy4YDUVS4iYbI2L78ZepPII9Q_bR89luYO4ikzWXr-Ae2xZ7hlVhYE5sSp-zHKqMvro8a8f2Sn5CNpPA3A97Q0scvJIvP_yZnY8cBVyBchtAz-yYeUKET79O3Vw5uoN6wV1orMk2_vvgw" alt="Addy Osmani: JavaScript Start-up Performance"></p><p>从这一部分我们学会两件事：</p><ol><li>尽管未必是线性关系，但 JS 的解析时间与包的体积呈正比。加载的 JS 代码体积越小，速度越快。</li><li>每一个你使用的 JS 框架（React, Vue, Angular, Preact …）是另一个层次的抽象（除非是像 <a href="https://github.com/sveltejs/svelte" target="_blank" rel="noopener">Svelte</a> 这样的预编译库）。这些库不仅会增加 JS 包的体积，也会因为代码没有直接面对浏览器而降低效率。</li></ol><p>有一些方法可以缓解这些问题，例如使用 service workers 另起线程在后台完成工作，或使用 asm.js 编写更容易被编译成机器指令的代码，但这完全是另一个话题了。</p><p>你可以做到，是无论如何在一切情况下避免使用 JS 动画库，并熟悉<a href="https://csstriggers.com/" target="_blank" rel="noopener">绘画和布局的触发事件</a>。只有当完全没办法使用常见的 CSS 过渡和动画实现时再使用库吧。</p><p>即使这些库可能使用了 CSS 过渡、复合属性以及 <code>requestAnimationFrame()</code> 方法，它们依然作为 JS 代码在主线程中运行。为了保证动画的顺滑，你需要确保你的所有 JS 代码在每帧 8 毫秒的时间内完成执行。</p><p>另一方面，CSS 动画和过渡占用 GPU 而非主线程，如果高效实现，可以避免产生重新布局。</p><p>考虑到大多数动画是在等待或用户交互时执行，这可以给予应用一定的喘息时间。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Animations_API" target="_blank" rel="noopener">Web Animations API</a> 作为即将到来的特性集合允许用户脱离主线程开发高效 JS 动画，但现在还是坚持 CSS 过渡和 <a href="https://aerotwist.com/blog/flip-your-animations/" target="_blank" rel="noopener">FLIP</a> 之类的技术吧。</p><h2 id="包的大小就是一切"><a href="#包的大小就是一切" class="headerlink" title="包的大小就是一切"></a>包的大小就是一切</h2><p>如今一切都是 JS 包。Bower 和 <code>&lt;/body&gt;</code> 标签前写一堆 <code>&lt;script&gt;</code> 的时代已经远去。</p><p>现在都是使用 <code>npm install</code> 来安装你在 NPM 上发现的新玩意，使用 Webpack 将它们打包为一个 1MB 体积的超大 JS 文件，当浏览器结束依赖包的数据请求后，这么大的文件会让浏览器缓慢运行。</p><p>试着少加载一些 JS 代码吧。你的项目也许不需要<a href="https://surma.github.io/underdash/" target="_blank" rel="noopener">完整的 Lodash 库</a>；你有必要非得使用一个 JS 框架吗？如果是，你考虑过使用体积是 React 1/20 的 <a href="https://github.com/developit/preact" target="_blank" rel="noopener">Preact</a> 或是 <a href="https://viperhtml.js.org/" target="_blank" rel="noopener">HyperHTML</a> 吗？为了实现滑到顶部的动画你有必要使用 <a href="https://greensock.com/tweenmax" target="_blank" rel="noopener">TweenMax</a> 吗？伴随着 npm 的便捷与各框架组件的独立，缺点应运而生：开发者面对一个问题时的第一反应变成了用更多 JS 代码来解决。当你拥有一把锤子时，一切看起来都像钉子。</p><p>当你在删繁就简、加载更少的 JS 代码之后，试着更聪明地加载它：需要时再加载。</p><p>Webpack 3 有一组了不起的功能名为 <a href="https://webpack.js.org/guides/code-splitting/" target="_blank" rel="noopener">code splitting</a> 和 <a href="https://webpack.js.org/guides/code-splitting/#dynamic-imports" target="_blank" rel="noopener">dynamic imports</a>。相较将所有 JS 模块打包成一个庞大的 app.js 包，这组功能可以自动切分代码并使用 <code>import()</code> 语法异步加载它们。</p><p>你不一定需要使用框架、组件和客户端路由以获得其优点。假设你有一段复杂的代码处理 <code>.mega-widget</code> 类的节点，这段代码可能存在于任意页面上，你可以简单得在你的主 JS 文件中编写如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">document</span>.querySelector(<span class="string">'.mega-widget'</span>)) &#123;</span><br><span class="line">  <span class="keyword">import</span>(<span class="string">'./mega-widget'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你的应用在当前页找到了部件，它将会动态加载所需的依赖代码。否则一切正常。</p><p>除此之外，Webpack 工作需要其自身的运行时，它将在其生成的所有 JS 文件中注入运行时代码。如果你使用了 <code>commonChunks</code> 插件，你可以使用如下方法<a href="https://medium.com/connect-the-dots/caching-assets-long-term-with-webpack-5ad24a4c39bd" target="_blank" rel="noopener">将运行时抽取到一个独立的代码块中</a>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">  name: <span class="string">'runtime'</span>,</span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure><p>在这个例子中，会将所有代码块中的运行时剔除出来，写入 <code>runtime.js</code> 中。只需确保在主 JS 包之前先加载它，例如这样：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"runtime.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"main-bundle.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来谈谈 transpiled code 和 polyfills。如果你编写的是现代（ES6+） JS 代码，你很可能正在使用 Babel 将它们转译为 ES5 兼容的代码。转译（Transpiling）不仅因为各种冗余增加文件体积，也因其相比原生 ES6+ 代码更加复杂带来了<a href="https://github.com/babel/babel/pull/6748" target="_blank" rel="noopener">性能退化</a>问题。</p><p>你可能还顺道使用了 <code>babel-polyfill</code> 和 <code>whatwg-fetch</code> 库来补充旧版本浏览器中缺失的一些特性。然后，如果你在代码中使用了 <code>async/await</code> ，你还需要引用 <code>regenerator-runtime</code> 库来转译…</p><p>重点是，为了支持老版本的浏览器，你的 JS 包因此平添了近 100K，不仅体积较大，也会耗费更多的解析和执行成本。</p><p>没理由因为上述问题而降低使用现代浏览器的人的用户体验，这里介绍一个我正在使用、同时 Philip Walton 也在<a href="https://philipwalton.com/articles/deploying-es2015-code-in-production-today/" target="_blank" rel="noopener">这篇文章</a>中介绍的方法：创建两个独立的包并依情况加载。使用 <code>babel-preset-env</code> 可以很容易实现，例如你有一个支持 IE 11 的包和另一个为最新版现代浏览器准备的没有任何 polyfills 的包，一种不优雅但是高效的方式是将以下代码写入内联脚本中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'async () =&gt; &#123;&#125;'</span>)();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="comment">// create script tag pointing to legacy-bundle.js;</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// create script tag pointing to modern-bundle.js;;</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>如果浏览器无法识别 <code>async</code> 函数，我们则判定它是一个旧版浏览器并加载已经 polyilled 的包，反之将加载一个简洁且现代化的变体。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们想要你从本文得到的观点是 JS 是一门运行昂贵、应该被小心使用的语言。</p><p>请确保在真实网络环境下使用低端设备测试你的网站性能。你的网站应该尽可能快被加载且变得可交互。这意味着通过任何有必要的方法减少 JS 的代码体积、加快加载速度。只要有可能时，你的代码应该都是 minified 过的，被切成更小、可控的包，并被异步加载的。在服务器端，确保启用了 HTTP/2 协议以获得更快的并行传输速度，同时使用 gzip/Brotli 压缩更加彻底地减少 JS 包体积。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="https://docs.google.com/spreadsheets/d/1wHcNNQea28LhwQ_amFamT33d5woVrJfJy53Z1k6V090" target="_blank" rel="noopener">Addy Osmani: Time spent in JS Parse &amp; eval for average JS</a></li><li><a href="https://www.youtube.com/watch?v=RWLzUnESylc" target="_blank" rel="noopener">Sam Saccone: Planning for Performance: PRPL</a></li><li><a href="https://www.youtube.com/watch?v=_srJ7eHS3IM" target="_blank" rel="noopener"><em>Fast By Default: Modern Loading Best Practices (Chrome Dev Summit 2017)</em></a></li><li><a href="https://medium.com/reloading/javascript-start-up-performance-69200f43b201" target="_blank" rel="noopener">Addy Osmani: JavaScript Start-up Performance</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;源文链接：&lt;a href=&quot;https://www.sitepoint.com/javascript-performance-optimization-tips-an-overview/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JavaScript Performance Optimization Tips: An Overview&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们将坚持“工具不代表规则（Tools, not rules）”的老话，尽量少提 JS 相关的流行术语。很显然我们不可能在一篇 2000 来字的文章里覆盖 JS 性能的方方面面，因此请在后续阅读本文的参考书目并自行研究。&lt;/p&gt;
&lt;p&gt;不过在深入细节之前，先让我们通过回答以下问题来更广义地理解性能优化：高性能的 JS 要考虑哪些指标？这些指标如何与更高维度的 web 性能指标融为一体？&lt;br&gt;
    
    </summary>
    
      <category term="Web 前端" scheme="https://blog.joouis.com/categories/Web-%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="javascript" scheme="https://blog.joouis.com/tags/javascript/"/>
    
      <category term="optimization" scheme="https://blog.joouis.com/tags/optimization/"/>
    
      <category term="performance" scheme="https://blog.joouis.com/tags/performance/"/>
    
  </entry>
  
  <entry>
    <title>论一个倒计时器的性能优化之路</title>
    <link href="https://blog.joouis.com/2018/05/25/optimization-road-of-count-down-timer/"/>
    <id>https://blog.joouis.com/2018/05/25/optimization-road-of-count-down-timer/</id>
    <published>2018-05-25T13:40:05.000Z</published>
    <updated>2018-05-28T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>回顾这半年，扛需求能力越来越强，业务代码也是越写越多。但稍一认真看看这些当时为了满足快速上线所码的东西，问题其实还是不少。这次就从一个简单的计时器说起。<br><a id="more"></a></p><h2 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h2><h3 id="问题很明显"><a href="#问题很明显" class="headerlink" title="问题很明显"></a>问题很明显</h3><p>倒计时器组件在一个活动列表页面里被使用，列表中每一项都是一个促销活动入口。倒计时器位于每个活动区块的左上方，提醒用户该活动还有多久结束，如下动图所示（测试设备 SONY E5663，后同）。</p><p><img src="https://wa4vlg.bn.files.1drv.com/y4mZVE-fw1i9bD_kBAmIyIwXmUob3Nr05qg1YjPF0X-lSiHJc4LkQFxRvsKRz97Q2Ka66a8BQAv7uXaVGgw-BEsRSXgD3KQy7vdxPBlRtcjplbb8EvTgCphRslC6C7LY-Fi9ipADd3BzZ_oTGQnJlXQowA0Sdniyq5dyYsTMP0Ppu8zje6DNccDiArViYnj7vcL8a5R_Xm43nk4mkExYUuJuQ" alt></p><p>当页面滑动时，可以明显看到计时器停止，这意味着页面并没有刷新。直到松手后一两秒才恢复计时，且不稳定，又卡顿了一到两秒。</p><p>如此明显的问题吓得笔者赶紧去后台查阅了该页面 PV 和 UV 数据，虽说不多，但还是有一批忠实用户每天访问，这可怎么对得起我们的衣食父母…！即便测试用的设备性能羸弱，更换 Chrome 模拟器以及 17 年的安卓旗舰机再次测试并未出现如此卡顿现象，但我们无法挑选客户使用的设备，只能从技术角度解决问题，尽量提升用户体验。BTW，这台 SONY 测试机就是由东南亚的业务方同学提供，应该是当地用户的常用机型之一。</p><h3 id="打脸与自我打脸"><a href="#打脸与自我打脸" class="headerlink" title="打脸与自我打脸"></a>打脸与自我打脸</h3><p>倒计时器组件的更新逻辑抽象如下，简单概括就是使用 <code>setInterval</code> 定时更新 React 组件的状态以实现倒数时间的更新：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Original version */</span></span><br><span class="line">componentWillMount() &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.timer) &#123;</span><br><span class="line">    <span class="keyword">this</span>.timer = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> toUpdate = <span class="keyword">this</span>.state.list.slice();</span><br><span class="line">      <span class="keyword">if</span> (toUpdate.length) &#123;</span><br><span class="line">        update.forEach(<span class="function"><span class="params">i</span> =&gt;</span> &#123;</span><br><span class="line">          i.leftTime = Tools.getLastTime(i.endTime);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123; <span class="attr">list</span>: toUpdate &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不得不说，贴出这么一段槽点满满的代码是极其需要勇气的，这…居然是我写的？</p><p><img src="https://wa4xlg.bn.files.1drv.com/y4mGDo6NnUlyo6Ta4BeRYmuW5hyO2xvGEglK6as5epLMdQsvtnX_1M6GnuNAapBHNHScn4T3QyDyMo3A6OpMKTYSkKjOijyJIDAVktpNRKFnHncIYnW1XOgSzNNvEEjDfwbIxI5jgaWwKdzgbhX51EUU_clFjpZhjmSJVJp_SpH91E5DvG_nSxu3RferNzBBzeccGryqCzSN3dKscCpskG8Vg" alt></p><p>那么开始分（tu）析（cao）吧，让我们自上而下依次盘点：</p><ol><li>这段逻辑代码放在 <code>componentWillMount</code> 生命周期钩子里执行并不合适，其因有二：在 <code>componentWillMount</code> 阶段还未加载真实的 DOM 节点，此时就开始更新数据没有什么意义；React 的 Reconciliation 算法以及目前最新的 Fiber 调度器算法会对渲染的开始或停止过程进行优化，例如合并几次渲染过程为一次，这可能会导致 <code>componentWillMount</code> 被频繁调用。</li><li>每次更新数据后都将触发一次渲染 SOP，这无疑加大了性能开销。当动画刷新遇上大量运算，一首《凉凉》送给低端手机。</li><li>这样计时方式真的准吗？例如 <code>setInterval</code> 的精准性，又例如 <code>setState</code> 方法的使用。</li></ol><p>顺着这个思路，赶紧来改代码吧！</p><h2 id="提升更新效率"><a href="#提升更新效率" class="headerlink" title="提升更新效率"></a>提升更新效率</h2><h3 id="更新速度有多慢？"><a href="#更新速度有多慢？" class="headerlink" title="更新速度有多慢？"></a>更新速度有多慢？</h3><p>首先花几秒钟把这段代码挪到 <code>componentDidMount()</code> 钩子里。</p><p>接下来，既然页面在 MBP 的 Chrome 模拟器上访问没有问题，那么可以做个简单的对比实验，看看手机与笔记本模拟器的性能差距。使用 <code>performance.now</code> 测量更新一次所花费的时间，示例代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* First version, profile the performance */</span></span><br><span class="line">componentDidMount() &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.timer) &#123;</span><br><span class="line">    <span class="keyword">this</span>.timer = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> startT = performance.now();</span><br><span class="line">      <span class="keyword">const</span> toUpdate = <span class="keyword">this</span>.state.list.slice();</span><br><span class="line">      <span class="keyword">if</span> (toUpdate.length) &#123;</span><br><span class="line">        toUpdate.forEach(<span class="function"><span class="params">i</span> =&gt;</span> &#123;</span><br><span class="line">          i.leftTime = Tools.getLastTime(i.endTime);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123; <span class="attr">list</span>: toUpdate &#125;, ()=&gt;&#123;</span><br><span class="line">  <span class="keyword">const</span> endT = performance.now();</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'Actually end:'</span>)</span><br><span class="line">          <span class="built_in">console</span>.log(endT - startT);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">const</span> seemsEndT = performance.now();</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Seems end:'</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(seemsEndT - startT);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从下方两张截图可以看到测试机与模拟器的性能相差十倍左右，且测试机的运算时间波动较大（下方上图为模拟器数据，下图为测试机数据）：</p><p><img src="https://wa4wlg.bn.files.1drv.com/y4m_2AunQuSGHxfUfucsT63rQWJC6lxKFUImyV4Fg1ItlV7KgbP3GKFP_rbZsbsOFoIFnk4UNn9a--ROa-FKuu8IXsa3H65sSUv3vD935DAsjvnRaiB16PTMR-kfqYBbbuCC1VzlRWGkoXWyezIH84a0hdgLO75iOFMi1Ims6NcPqaUVot0br01sfXnpJ1uHP1fiAyBCWr4GNdcNqB_xTGONw" alt="模拟器数据"></p><p><img src="https://wa4ulg.bn.files.1drv.com/y4mTKOcKn5J034yunDQU3rensrbOB8Loba_2riPbNj-0ggpCgeGiAyWQj4zCDgIOIxuzCiYFFQgJyg224ON7LKdjk3F0HnRVpmupohV-6iUjtTnIpbb0lACPf1l1ljvnNUl-cH7qGDB7lfG2hA5xZAYkmsCvdZEogstwLUDKaBzGoCtPYRCidYRUu5effnpEs61raVdT3R_a7XhTbwkY0HxTQ" alt="测试机数据"></p><p>其实上面的埋点代码添加在 <code>setState</code> 的回调函数里，就明显能说明一个问题：<code>setState</code> 方法并不保证同步渲染更新，尽管截图中的时序看上去是同步的。</p><p>重点是，整个更新渲染的周期非常长，即使降低至 30Hz 的流畅画面要求，一帧可用的渲染时间也只有不到 34 毫秒，还不是业务代码独享！ 之所以渲染速度慢，是因为调用一次 <code>setState</code> 方法会依次执行 React 生命周期中的 4 个函数：<code>shouldComponentUpdate</code>、<code>componentWillUpdate</code>、<code>render</code> 和 <code>componentDidUpdate</code> （如下图所示）。</p><p><img src="https://wa4tlg.bn.files.1drv.com/y4mH5wzx6FvvX4Ivw12vqJacZkkN7Lj-Ukqp1Pmgp47MIBZNoIl2NVYcHcICpllBTZ52bc4jHTSO1zj1149_lSExWuB-j-oDQTanr1LsNfIbzWKX3GbI5EgQuDRovuQB9sD1GM67ny_Rk5p1tHRKXgRHr5--qxxZ3UDwXOP0wTFrRgbjFAzoO1lc8YV5WsbykbDQ4HjI8LmqfNJZCJdRkuPYA" alt="Source: https://bit.ly/2Pb6sn5"></p><h3 id="直接撸-DOM，要啥-jQuery"><a href="#直接撸-DOM，要啥-jQuery" class="headerlink" title="直接撸 DOM，要啥 jQuery"></a>直接撸 DOM，要啥 jQuery</h3><p>为了性能，这里采用最为简单粗暴的方法，直接更新 DOM 节点的 HTML 值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Second version, operate DOM directly instead of setState() */</span></span><br><span class="line">componentDidMount() &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.timer) &#123;</span><br><span class="line">    <span class="keyword">this</span>.timer = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> startT = performance.now();</span><br><span class="line">      <span class="keyword">const</span> toUpdate = <span class="keyword">this</span>.state.list.slice();</span><br><span class="line">      <span class="keyword">if</span> (toUpdate.length) &#123;</span><br><span class="line">        <span class="keyword">const</span> nodes = <span class="built_in">document</span>.querySelectorAll(<span class="string">'.count-down-timer'</span>);</span><br><span class="line">        toUpdate.forEach(<span class="function"><span class="params">i</span> =&gt;</span> &#123;</span><br><span class="line">          i.leftTime = Tools.getLastTime(i.endTime);</span><br><span class="line">          nodes[index].innerHTML = item.registerLeftTime;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">const</span> endT = performance.now();</span><br><span class="line">        <span class="built_in">console</span>.log(seemsEndT - startT);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们来看看效果如何：模拟器上的更新时间缩短至 0.3 毫秒，比之前快了十几到二十几倍；测试机的数据也漂亮多了（如下图），再滑几下试试… 美滋滋！</p><p><img src="https://uk63cg.bn.files.1drv.com/y4mqJ8C6KonIi1uAISi4pEmOOwNdU8v65SRIRhNXt1JFz__hBhTyWthddLBjDNsFa_7nON7ee1lemoqa-fVSfzAjfHDLI20DNVswyDt1Tqb-lIDygnV2o4EnKoirhN4zT0-GldtJZSl4wGkQFia1bSdpo4obitIpE68skhikurHQIOXmfcf6_1dlWqN951ETFmxhr9tqb6WzAkHsbJXUSmHMw" alt></p><p><img src="https://uk62cg.bn.files.1drv.com/y4mmLDLLxMSz-HbaSGM708E-mDIWxfBVX8pOgMg2v0g6fwb5btM1rx3FXLt5_h5G0g-eeaaHoeR4pHg0dC0VSgG9ZMEBTpX5qMfQ8MPygAioKa2JKG-r-wUa4GCtq_bVOCvhYudySc3ncVfHyh3OWYpUM3maBiV2c8oaokRyH_ijMV7oIbEtvOJm9izrFJZdR2XSLqrWnyIg-75hMXRCFUjSA" alt></p><h2 id="更好的更新策略"><a href="#更好的更新策略" class="headerlink" title="更好的更新策略"></a>更好的更新策略</h2><p>定时器最重要的功能就是确保时间准确，如果时间都不准了，那也就该洗洗睡了。除去与服务端同步校时之类的方案，还是继续讨论如何在 Web 前端领域力求计时准确。</p><h3 id="并不精准的-setInterval"><a href="#并不精准的-setInterval" class="headerlink" title="并不精准的 setInterval"></a>并不精准的 <code>setInterval</code></h3><p>在修复前文提到的 <code>setState</code> 缺陷之后，最明显的问题莫过于 <code>setInterval</code> 的使用。写一个定时任务，不少小伙伴第一反应想到的也是 <code>setTimeout</code> 和 <code>setInterval</code> 函数，但是它们真的足够精确吗？这就要从 JS 的<strong>任务队列</strong>及<strong>微任务队列</strong>（也有称 <strong>macrotask queue</strong> 和 <strong>microtask queue</strong>）说起了…</p><p>咳咳，我们言简意赅总结下：JS 主线程执行时有一个栈存储运行时的函数相关变量，遇到函数时会先入栈执行完后再出栈（废话）。当遇到 <code>setTimeout</code> <code>setInterval</code>  <code>requestAnimationFrame</code> 以及 I/O 操作时，这些函数会立刻返回一个值（如 <code>setInterval</code> 返回一个 <code>intervalID</code> ）保证主线程继续执行，而异步操作则由浏览器的其它线程维护。当异步操作完成时，浏览器会将其回调函数插入主线程的<strong>任务队列</strong>中，当主线程执行完当前栈的逻辑后，才会依次执行<strong>任务队列</strong>中的任务。</p><p>但是在每个任务之间，还有一个<strong>微任务队列</strong>的存在。在当前任务执行完后，将先执行<strong>微任务队列</strong>中的所有任务，例如 <code>Promise</code> <code>process.nextTick</code> 等操作。也就是说当 <code>setInterval(fn, 1000)</code> 等待 1 秒钟后，<code>fn</code> 函数会被插入<strong>任务队列</strong>中，但并不一定会立刻执行，还需要等待当前任务以及<strong>微任务队列</strong>中的所有任务执行完。长此以往，使用 <code>setInterval</code> 的计时器超时将越来越严重。</p><p>如果有毅力的朋友推荐看看<a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model" target="_blank" rel="noopener">权威的 HTML 标准文档</a>，没耐心的就看看这个动图简单感受一下原理吧。</p><p><img src="https://uk61cg.bn.files.1drv.com/y4mcSzGXI67z9tGYkWxelXSAFLpRIaks9Y2vutDbVXmV4xEUO5VIOCAriv4qFN88wlj7dc82LfaJpTn8iqgS2LmLNfct48dCXPL_iRYVO_iaJSbDFD_OEWgG5Td5-QG5SMW2cqbaVVJftCHkMoxkSYA6tl33pNryxdaEoPvnKt8s5hTwlm39XfMWCyTwlbH8Ss0UKhPF9Pzt5_DrKI8Ya4pIA" alt></p><p>所以回归正题，不用 <code>setInterval</code> 那用啥？</p><h3 id="天王盖地虎，我有-rAF"><a href="#天王盖地虎，我有-rAF" class="headerlink" title="天王盖地虎，我有 rAF"></a>天王盖地虎，我有 <code>rAF</code></h3><p>解铃还须系铃人，既然我们的代码执行时间在主线程中无法得到保证，那么还是要从更高抽象层级的浏览器中寻求办法。好在目前主流浏览器都已提供一个在重绘前执行动画相关函数的接口 <code>requestAnimationFrame</code>，用来更新计时器再合适不过。改造如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Third version, use rAF instead of setInterval */</span></span><br><span class="line">componentDidMount() &#123;</span><br><span class="line">  <span class="keyword">let</span> lastTime = <span class="literal">null</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">__updateCountDownTimer</span>(<span class="params">timestamp</span>) </span>&#123;</span><br><span class="line">    lastTime = lastTime || timestamp;</span><br><span class="line">    <span class="keyword">const</span> tickInterval = timestamp - lastTime;</span><br><span class="line">    <span class="keyword">if</span> (tickInterval &gt;= <span class="number">1000</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> toUpdate = <span class="keyword">this</span>.state.list.slice();</span><br><span class="line">      <span class="keyword">if</span> (toUpdate.length) &#123;</span><br><span class="line">        <span class="keyword">const</span> nodes = <span class="built_in">document</span>.querySelectorAll(<span class="string">'.count-down-timer'</span>);</span><br><span class="line">        toUpdate.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">          item.leftTime = Tools.getLastTime(item.endTime);</span><br><span class="line">          nodes[index].innerHTML = item.leftTime;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      lastTime = timestamp;</span><br><span class="line">    &#125;</span><br><span class="line">    requestAnimationFrame(_updateCountDownTimer.bind(<span class="keyword">this</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.timer) &#123;</span><br><span class="line">    <span class="keyword">this</span>.timer = requestAnimationFrame(__updateCountDownTimer.bind(<span class="keyword">this</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么这样实现足够精准了吗？打印出每次更新的时间戳瞅瞅（上图为模拟器数据，下图为测试机数据）。</p><p><img src="https://uk60cg.bn.files.1drv.com/y4mQ1PgkiRAaXCfZdrIAIF9BBI5tkJKiuOg-cVIpGT2MqDg0_tga1jcdnf7KsqsLZAKTkVaMjrT1_QcNIl5t-iJkZFPajCeBf6F07lvrfhu3D_HQhwkp8-P5CvU1feucSLmeVM_7FVykz5ZoCOpIaeE3dc2srLtyq0liZcsLQfJxf89j1m6WQns6000dhgP1MjzWb6RFrdP2hTVTqc36WLxAw" alt="模拟器数据"></p><p><img src="https://uk6zcg.bn.files.1drv.com/y4mu2QEBM0rzmdCCPp5zDS_jVAHLDQtHzNXzsEkNcmx2ujBQP2KZsIkfDzAAHvqyt5VEvxSgr-I2X-3pH80BShnKyQJ-tXMltsyK07xEqCmmdtg9oqucFwu_9rPfpjRyCpHDwpMijoHuq6QLz7rl3irdEY8zxfmgNcKHnLhlV5G-Gph_YgSRtSYX1YAygmf3rGE_s0BAgg3pnKqdUay5jbraw" alt="测试机数据"></p><p>可以看到模拟器上已经相当精准，每秒的误差在 +0.15 毫秒左右，也就是运行将近 2 小时会有 1 秒的误差，笔者觉得完全可以接受。不过测试机上的误差就有点大了，每秒的误差在 +10 毫秒左右，虽然笔者觉得也可以接受（很少有人会在活动页停留很久），但本着工（tai）匠（gang）精神，想想是否还能优化呢？</p><h3 id="正向反馈拯救采样频率"><a href="#正向反馈拯救采样频率" class="headerlink" title="正向反馈拯救采样频率"></a>正向反馈拯救采样频率</h3><p>好奇心使笔者打印出了测试机调用 <code>rAF</code> 的时间间隔，绝大多数间隔在 16.6 毫秒左右，意味着手机 webview 也是 60Hz 的刷新频率；不过也存在少数间隔时间远超正常刷新时间，达到了 30 ~ 70 毫秒，如果触发滑动操作可能会超过 100 毫秒。不得不说，测试机就要挑这么烂的 Orz…</p><p>仔细想想，测试机上的计时误差本质是采样频率并未一直满足 60Hz，当某一次采样时间超过 16.6 毫秒且刚好需要刷新动画时，就会产生误差。同时每次误差都是超时而非提前，这样就在延时的道路上越走越远了。</p><p>那么反向思考，每当触发更新事件时，超时时段（超过 1 秒的时间）是已知的。如果将其补偿到下一次计时中，应该能减缓误差的扩大速度。代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Fourth version, use rAF instead of setInterval */</span></span><br><span class="line">componentDidMount() &#123;</span><br><span class="line">  <span class="keyword">let</span> lastTime = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">const</span> DELAY_INTERVAL = <span class="number">1000</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">__updateCountDownTimer</span>(<span class="params">timestamp</span>) </span>&#123;</span><br><span class="line">    lastTime = lastTime || timestamp;</span><br><span class="line">    <span class="keyword">const</span> tickInterval = timestamp - lastTime;</span><br><span class="line">    <span class="keyword">if</span> (tickInterval &gt;= DELAY_INTERVAL) &#123;</span><br><span class="line">      <span class="keyword">const</span> toUpdate = <span class="keyword">this</span>.state.list.slice();</span><br><span class="line">      <span class="keyword">if</span> (toUpdate.length) &#123;</span><br><span class="line">        <span class="keyword">const</span> nodes = <span class="built_in">document</span>.querySelectorAll(<span class="string">'.count-down-timer'</span>);</span><br><span class="line">        toUpdate.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">          item.leftTime = Tools.getLastTime(item.endTime);</span><br><span class="line">          nodes[index].innerHTML = item.leftTime;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      lastTime = timestamp + (tickInterval - DELAY_INTERVAL);</span><br><span class="line">    &#125;</span><br><span class="line">    requestAnimationFrame(_updateCountDownTimer.bind(<span class="keyword">this</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.timer) &#123;</span><br><span class="line">    <span class="keyword">this</span>.timer = requestAnimationFrame(__updateCountDownTimer.bind(<span class="keyword">this</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察测试手机打印的时间，发现此法完全是可行的。每当超时间隔超过正常的刷新频率 16.6 毫秒时，相当于赶上了下一次采样窗口的伊始，因此会被校正。相比手机上每隔两三秒校正一次，PC 模拟器的采样时间变化显得尤为明显，在最后与大家分享。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1685.99</span>, <span class="number">2686.13</span>, <span class="number">3686.27</span>, <span class="number">4686.410000000001</span>, <span class="number">5719.888</span>, <span class="number">6686.69</span>, <span class="number">7686.83</span>, <span class="number">8686.970000000001</span>, <span class="number">9687.11</span>, <span class="number">10687.443</span>, <span class="number">11687.583</span>, <span class="number">12687.723</span>, <span class="number">13687.863</span>, <span class="number">14688.003</span>, <span class="number">15688.143</span>, <span class="number">16688.283</span>, <span class="number">17688.423</span>, <span class="number">18688.563</span>, <span class="number">19688.703</span>, <span class="number">20688.842999999997</span>, <span class="number">21689.214</span>, <span class="number">22689.354000000003</span>, <span class="number">23689.494</span>, <span class="number">24689.634000000002</span>, <span class="number">25689.774</span>, <span class="number">26689.914</span>, <span class="number">27690.054</span>, <span class="number">28690.194000000003</span>, <span class="number">29690.334</span>, <span class="number">30690.474</span>, <span class="number">31690.863</span>, <span class="number">32691.003</span>, <span class="number">33691.143</span>, <span class="number">34691.282999999996</span>, <span class="number">35691.423</span>, <span class="number">36691.563</span>, <span class="number">37691.702999999994</span>, <span class="number">38691.843</span>, <span class="number">39691.983</span>, <span class="number">40692.123</span>, <span class="number">41692.473</span>, <span class="number">42692.613000000005</span>, <span class="number">43692.753000000004</span>, <span class="number">44692.893</span>, <span class="number">45693.033</span>, <span class="number">46693.173</span>, <span class="number">47693.313</span>, <span class="number">48693.453</span>, <span class="number">49693.593</span>, <span class="number">50693.733</span>, <span class="number">51694.159</span>, <span class="number">52694.299</span>, <span class="number">53694.439000000006</span>, <span class="number">54694.579</span>, <span class="number">55694.719</span>, <span class="number">56694.859000000004</span>, <span class="number">57694.999</span>, <span class="number">58695.138999999996</span>, <span class="number">59695.279</span>, <span class="number">60695.419</span>, <span class="number">61712.443</span>, <span class="number">62695.914000000004</span>, <span class="number">63696.054</span>, <span class="number">64696.194</span>, <span class="number">65696.33399999999</span>, <span class="number">66696.474</span>, <span class="number">67696.614</span>, <span class="number">68696.754</span>, <span class="number">69696.894</span>, <span class="number">70697.034</span>, <span class="number">71697.423</span>, <span class="number">72697.56300000001</span>, <span class="number">73697.70300000001</span>, <span class="number">74697.84300000001</span>, <span class="number">75697.983</span>, <span class="number">76698.12299999999</span>, <span class="number">77698.26299999999</span>, <span class="number">78698.403</span>, <span class="number">79698.543</span>, <span class="number">80698.683</span>, <span class="number">81699.02399999999</span>, <span class="number">82699.16399999999</span>, <span class="number">83699.304</span>, <span class="number">84699.444</span>, <span class="number">85699.584</span>, <span class="number">86699.724</span>, <span class="number">87699.864</span>, <span class="number">88700.004</span>, <span class="number">89700.144</span>, <span class="number">90700.284</span>, <span class="number">91700.424</span>, <span class="number">92700.781</span>, <span class="number">93700.92099999999</span>, <span class="number">94701.061</span>, <span class="number">95701.201</span>, <span class="number">96701.341</span>, <span class="number">97701.481</span>, <span class="number">98701.621</span>, <span class="number">99701.761</span>, <span class="number">100701.90100000001</span>, <span class="number">101702.041</span>, <span class="number">102702.426</span>, <span class="number">103685.897</span>, <span class="number">104686.037</span>, ...</span><br></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/" target="_blank" rel="noopener">Tasks, microtasks, queues and schedules</a></li><li><a href="https://www.quora.com/How-does-a-single-thread-handle-asynchronous-code-in-JavaScript" target="_blank" rel="noopener">How does a single thread handle asynchronous code in JavaScript?</a></li><li><a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model" target="_blank" rel="noopener">HTML Living Standard — Last Updated 25 May 2018</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame" target="_blank" rel="noopener">window.requestAnimationFrame()</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引子&quot;&gt;&lt;a href=&quot;#引子&quot; class=&quot;headerlink&quot; title=&quot;引子&quot;&gt;&lt;/a&gt;引子&lt;/h2&gt;&lt;p&gt;回顾这半年，扛需求能力越来越强，业务代码也是越写越多。但稍一认真看看这些当时为了满足快速上线所码的东西，问题其实还是不少。这次就从一个简单的计时器说起。&lt;br&gt;
    
    </summary>
    
      <category term="Web 前端" scheme="https://blog.joouis.com/categories/Web-%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="javascript" scheme="https://blog.joouis.com/tags/javascript/"/>
    
      <category term="react" scheme="https://blog.joouis.com/tags/react/"/>
    
      <category term="optimization" scheme="https://blog.joouis.com/tags/optimization/"/>
    
      <category term="counter" scheme="https://blog.joouis.com/tags/counter/"/>
    
  </entry>
  
  <entry>
    <title>那些年我拿到阿里巴巴Offer所参加的面试</title>
    <link href="https://blog.joouis.com/2018/01/13/interviews-for-the-offer-from-alibaba/"/>
    <id>https://blog.joouis.com/2018/01/13/interviews-for-the-offer-from-alibaba/</id>
    <published>2018-01-12T18:29:49.000Z</published>
    <updated>2018-01-14T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>2017 年尾第一次经历了转岗，离开了 YunOS/AliOS 事业部，虽然新部门还是在阿里，但这种感觉其实就是换了份工作。想当初加入阿里踌躇满志，期待在 OS 领域大干一场，然而时隔一年多，我已转型为风马牛不相及的 Web 前端开发，曾经的 OS 梦随着前事业部的战略失败也逐渐凋零。2018 年的第一篇博客，就来纪念一下这段狗血历程的开端吧。<br><a id="more"></a></p><p>回想研究生时期的我还在嵌入式领域里游荡，尽管会写一点网页和脚本，也懂点机器学习的皮毛，但我一直认为我会去一家电子公司，比如传统的半导体厂商 Intel, NXP，最不济也是 MTK （笑）。老牌名校的明星院系，实习、神人导师的各种摔打，以及自身对嵌入式的热爱，想不出有什么理由会使我去互联网公司。</p><p>然而，命运有时候就是这么神奇。</p><p>2015 年初夏，机缘巧合认识的学弟妹在团队缺人的情况下，拖我去台北参加了阿里百川举办的黑客松比赛，随后结识了若远师兄。在 16 年春天开始找工作时，我咨询了若远：1. 阿里有没有搞系统底层的职位？2. BAT 的官网都只招实习生了，阿里还有校招吗？在得到肯定答复后，自然而然获得了他的内推帮助。</p><p>简历通过评估后，无需笔试，即将开始漫长的面试之旅。我总共经历了 7 场面试，之所以会有这么多场的原因，总结有三：</p><ol><li>16 年互联网寒冬已经到来，BAT 在三月春招时只招实习生，而我在前三轮面的不错的情况下想“强行上位”，需要多多考察（某位面试官原话）；</li><li>其中一场面试面砸了，听到有正式 offer 机会的当下心态失衡；</li><li>当时人在台南，边写论文边面试，时间紧任务重，拒绝了回杭州终面，所以还是需要多多考察，毕竟学校名字听起来太野鸡？</li></ol><p>讲完八卦，是时候上干货了 = =+。以下是 7 次面试的重点记录：</p><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><ul><li>电话</li><li>根据线上简历（主要是简历上的开放式问题）进行提问</li></ul><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><ul><li>电话 + 笔试</li><li>strcpy() 越界</li><li>链表节点的插入</li><li>size of array pointer</li></ul><h3 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h3><ul><li>电话，内容广度爆炸… Orz</li><li>ld.so，VIVT / VIPT / PIPT，cache flush / clean</li><li>加解密算法</li><li>TLB 作用</li><li>宏内核 vs 微内核</li><li>IRQ vs FIQ</li><li>ARMv7-M vs ARMv7-A</li><li>ARMv8-M，Trustzone</li><li>MPU 用途，和 MMU 区别</li><li>动态链接函数库，那些数据共享，哪些数据独有</li><li>Run-time 时期 Bss Section 数据的行为</li></ul><h3 id="四面"><a href="#四面" class="headerlink" title="四面"></a>四面</h3><ul><li>电话 + 笔试，搞砸的那次</li><li>指针的数组，数组的指针，sizeof() ？</li><li>同二面第一题，刨根问底是什么情况</li><li>写出 linux kernel 双向链表的删除操作，但问的时候未说明是双向链表…</li></ul><h3 id="五面"><a href="#五面" class="headerlink" title="五面"></a>五面</h3><ul><li>电话</li><li>首先，解释四面表现为何如此之差（心塞…）</li><li>一个智能灯系统，有 WiFi，如何做到低功耗</li><li>Hypervisor 原理，若上面同时跑两个 RTOS，整个架构是怎么样的</li></ul><h3 id="六面"><a href="#六面" class="headerlink" title="六面"></a>六面</h3><ul><li>电话</li><li>详细自我介绍，项目经验</li><li>mutex vs spin lock</li><li>有序数列查找元素效率最高的算法？时间复杂度？</li><li>RB Tree VS AVL Tree</li><li>过往的笔试题</li><li>TCP 四次挥手过程，端口号什么时候结束使用的</li></ul><h3 id="七面"><a href="#七面" class="headerlink" title="七面"></a>七面</h3><ul><li>电话，HR 终面</li><li>来实习的话可能面临的挑战？</li><li>来实习的工作内容？</li><li>自己最大的优势是什么？</li></ul><p>整个面试的过程还是不错的，面试官都很专业，上来直接询问技术相关的问题，并且会有意识的引导，态度也都比较和善，是我个人认可的面试方式。面试完后，阿里校招系统上的信息更新也非常及时，不得不夸一下这个招聘系统很专业，大大提升了面试者对这家公司的信心与好感度。当时唯一觉得不爽的就是不知道面试电话什么时候会来，除了一位面试官提前电邮与我预约时间外，其他面试都是时间未知，我只好抱着海外漫游的电信手机一直等，度过了难熬的一个多月时光。</p><p>现在站在上帝视角，再看看当初的想法，也是有许多感慨。我以为四面后就彻底结束了，没想到还有第五面；我以为这么多次面试是一个连续的过程，其实在第四面之后我已经被淘汰回了简历池；我以为我拿的是校招 offer，其实最终花费了团队一个社招 offer；我以为我来了做的是面试里聊得 ARM trustzone 等安全领域的活，没想到入职后就拥抱变化做了 Web 前端开发。</p><p>面对难以预知的未来，唯一能做的就是把握现在，不断地努力。如果没有在研究生时期疯狂饿补计算机体系知识，面试时期常常刷面经、leetcode 到三四点，我一定过不了面试。如果没有放平心态学习 Web 以及前端相关的新技术、思考技术需求与方向，我不会在想转岗时，谈一个 offer 拿一个 offer，不愁没下家。如果没有危机感和对技术的执着，我不会从一个石油专业院校走到一家知名的互联网公司，想想从光电跨越到电子再到计算机领域的“艰辛”，其实也没什么，毕竟整个过程是非常充实且富有成就感的。</p><p>最后，面试这一路走来也真的是非常幸运，结识了一些师长和同事并得到他们的帮助。例如带我进入计算机领域的前联发科技技术顾问、后来做我硕论导师的开源大神 Jserv；实习时只要有空便与我分享技术心得、劝我对自身技术发展不要设限的 Richard 大哥；给了我加入阿里机会并让我仰望的峰哥和超级 nice 的 HR 姐姐珈夜；以及内推我进阿里、在转岗时给我许多建议、现在成为一个部门同事的高富帅若远。感恩！</p><p>Learn from yesterday, live for today, hope for tomorrow. Let’s cheer up!</p><img src="https://wa4zlg.bn.files.1drv.com/y4myFzzFENIFeXKKbBNl29MUrhHaqWthLpi4C6LlnQ2B8ph1jjR5P7pMN16Sqe3ygvU60P-A2JAXOs4xEc1uOw15lnLXCmdRJhx16uk1mAvVb2mTAMMxJP6PleiaZwq0mrpTfEkbjQDHRqlE5ejxFBqBe43lGlRrlDnHSDIp7WAi4ka_KCTwDMmJKIszOqiYhugClq5n3hHaCQ9kYKQFZ3ARA">]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2017 年尾第一次经历了转岗，离开了 YunOS/AliOS 事业部，虽然新部门还是在阿里，但这种感觉其实就是换了份工作。想当初加入阿里踌躇满志，期待在 OS 领域大干一场，然而时隔一年多，我已转型为风马牛不相及的 Web 前端开发，曾经的 OS 梦随着前事业部的战略失败也逐渐凋零。2018 年的第一篇博客，就来纪念一下这段狗血历程的开端吧。&lt;br&gt;
    
    </summary>
    
      <category term="技术人生谈" scheme="https://blog.joouis.com/categories/%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F%E8%B0%88/"/>
    
    
      <category term="interview" scheme="https://blog.joouis.com/tags/interview/"/>
    
      <category term="alibaba" scheme="https://blog.joouis.com/tags/alibaba/"/>
    
      <category term="os" scheme="https://blog.joouis.com/tags/os/"/>
    
  </entry>
  
  <entry>
    <title>十分钟带你了解国产自制开源插件 structure-view</title>
    <link href="https://blog.joouis.com/2017/11/21/introduction-to-structure-view/"/>
    <id>https://blog.joouis.com/2017/11/21/introduction-to-structure-view/</id>
    <published>2017-11-21T08:19:22.000Z</published>
    <updated>2017-11-23T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>structure-view （以下简称 SV）是在开发 YunOS Studio（AliOS Studio 前身）时开源出来的一款代码结构提示插件。代码结构提示是一项由来已久的影响开发效率的功能，早在 VIM 时期就有经典的 ctags + Taglist 插件组合来实现这一功能，在桌面时代各大流行的 IDE 也都支持此功能，如 Eclipse 中的 Outline View 或 Webstorm 中的 Structure View。</p><p>YunOS Studio 基于扩展能力优异的 Atom 编辑器开发，由于 Atom 的生态市场缺乏一款好用的代码结构提示插件，因此 SV 应运而生（注：目前主流相关插件的比较可参考附件 PPT 中的 “开发由来与现状” 章节）。<br><a id="more"></a></p><p>自从今年九月初将其开源并发布到 Atom 市场中，2个多月的时间达到了 800 余次的下载量，总计 20+ 的 star 数量，以及数十个 issues 和 PR。在没（精）啥（力）宣（有）传（限）的情况下，有人下载使用、提问题、提需求，甚至主动贡献 PR，都给了笔者极大的鼓舞，因此在此分享一下这个插件的设计，也欢迎 Atom 党服用此插件。</p><img src="https://wk4tlg.bn.files.1drv.com/y4mN2I10UfETZdexdzTftd3jf_T3Ib94IPry-EWT69byliaUtzRSIo5zJ2DW4Uqib05ZmX4mPIq0lfLS_CkKf6-aYB6GFJRE7rmfguVYvz1uaJg2awvZfzPPy-C3hgQ5ORboLxnb5b-xY2ekYKwT1wThsrA3s2VtyTcSQnVJPrPmMRq-uYhG-Gf2EHM2lqnZrmjWUT6qxP5gskoz-5hPJjtmg"><p>链接：</p><ul><li><a href="https://atom.io/packages/structure-view" target="_blank" rel="noopener">Atom 市场</a></li><li><a href="https://github.com/alibaba/structure-view" target="_blank" rel="noopener">Github</a></li></ul><p><em>平（臭）心（不）而（要）论（脸），eating my own dog food 这么久，我觉得挺好用的 =。=</em></p><h2 id="需求与难点"><a href="#需求与难点" class="headerlink" title="需求与难点"></a>需求与难点</h2><h3 id="结合业务背景与现状谈需求"><a href="#结合业务背景与现状谈需求" class="headerlink" title="结合业务背景与现状谈需求"></a>结合业务背景与现状谈需求</h3><p>SV 最初是为 YunOS Studio 设计，其用户——YunOS 开发者主要使用 Web 相关语言开发，因此对 HTML, CSS, Javascript 的支持是第一要务 。</p><p>其次，SV 应该具备目前主流类似插件的功能，总不能被“活化石” ctags + Taglist 给 K.O. 了。因此有些基本功能一定要满足：</p><ul><li>解析出代码的基本类型，如 HTML 的 Element，CSS 的 Selector，JS 的 Function, Class 等</li><li>将上述类型展现在界面上，通常是树状图的形式</li><li>点击树状图上的节点，编辑区域可快速定位到其对应的代码位置</li></ul><p>然后，扩展性是非常重要的一点。资源有限，不可能一口气支持所有语言，先把第一要务干完了，才能展望别的语言。秉着不能挖坑让自己跳的指导思想，一定要在初始阶段设计好扩展性。</p><p>最后，能开源当然是最好的，一个人支持那么多语言是会累死的，能忽悠热心网友来干点活多好呀。这也从侧门对扩展性提出了要求。</p><p>最后的最后，快速落地。在项目调研阶段笔者就发现，Atom 上不仅缺少好用的代码结构提示插件，即使是使用量最多的一个，作者也疑似不维护、消失很久了，项目相关的 issues 中已有一些对此类插件的明确需求。如果能快速落地，也就有机会获得一些外部开发者用户。</p><h3 id="难吗？难"><a href="#难吗？难" class="headerlink" title="难吗？难"></a>难吗？难</h3><blockquote><p>你永远不知道下一份读取的代码是用什么语言写的 Orz</p></blockquote><p>从以下几个维度分析下难在哪：</p><ul><li>广度：用户使用的语言无法预测，至少要覆盖主流语言吧，不然怎么好意思拿得出手</li><li>深度：对我们业务所用的语言，一定要能全面地解析；对于主流语言，至少也得解析出个轮廓</li><li>轻量：Atom 性能本来就不算好（当然人家也不主打性能…），所以插件一定要轻，切莫“喧宾夺主”</li><li>广度和深度本来就很难同时满足，还要保证轻量，tradeoff 的哲学该如何落实</li></ul><h2 id="设计与实现"><a href="#设计与实现" class="headerlink" title="设计与实现"></a>设计与实现</h2><h3 id="目前主流的解决方案"><a href="#目前主流的解决方案" class="headerlink" title="目前主流的解决方案"></a>目前主流的解决方案</h3><p>当初调研时发现， Atom 市场中的竞品多是封装经典的 <a href="http://ctags.sourceforge.net/" target="_blank" rel="noopener">ctags</a> 插件，其工作原理如下：</p><ol><li>提前内置 Windows/macOS /Linux 三个平台的二进制执行文件，以及其需要的配置文件 <code>.ctags</code> </li><li>当插件工作时，命令行调用 ctags 解析，获取 stdout 输出的数据</li><li>将 ctags 输出的数据进行加工，以 web 页面的形式呈现在 Atom 的视图中</li></ol><p>由于  <code>.ctags</code> 是正则匹配脚本，也就是说 ctags 其实是利用正则匹配方法处理代码。这种方法的好处是添加规则方便，规则越全面解析效果理论上越好。但是问题也显而易见，光靠正则匹配很难对 OOP 语言中的继承关系进行解析，更别提 JavaScript 这种靠原型链吃饭的语言了。</p><p>另外还有一种解决方案源自 Facebook 出品的 Nuclide IDE，SV 在设计之初并未参考到，不过后来发现是类似的思路 。Nuclide 中的 Outline 视图提供了代码结构提示和快速导航的功能，针对不同的语言使用不同的解析器，例如使用了自家的 Flow 类型检查工具处理 JavaScript 代码，而使用了 Python 官方的解析器处理 Python 代码。</p><p>这种方法的好处自然是有深度，能把支持的语言解析到位，但坏处也十分明显。首先是依赖性太强，之所以没有很深入地调研 Nuclide，是因为笔者在解析 JavaScript 时提醒安装 Flow，但是 Nuclide 并没有提供自动化安装功能，需要用户到 Flow 的官网学习、完成这件事情，这显然很蠢，也不知道现在改进没…其次就是支持的语言类型有所限制，需要大量的资源支持新的语言开发，明显不适合笔者这种“单兵作战”模式。</p><h3 id="流程设计"><a href="#流程设计" class="headerlink" title="流程设计"></a>流程设计</h3><p>SV 的代码结构解析流程与现有插件大体一致，如下图所示。</p><img src="https://wk4ulg.bn.files.1drv.com/y4mc9Zhw83pbn0yN-CveyHdr9ui5NuMjEmSlmyKMVMupYsffd6LTZRTjbV2Dn13JloGV7wGVHj4tJ0Po66jJp3GzRiUh5OFWWuyKIcbQYlKb0NJRhiSMSqsCibAZ1g2qT00miHPlfkW0Q4QsqaweuVIPwJBSGyS8a6JYF4t0DkxxJ31heIREKZMMz68_5-gYdt5ssjc9YXqscYUvNQMIGhuVg"><p>一次完整的解析显示流程可分解为以下几步：</p><ol><li>获取当前代码文件的绝对路径</li><li>调用文件系统接口读取代码内容</li><li><strong>选择合适的语法分析器</strong>解析代码，获取 tags 数据</li><li>Tag parser 将 tags 处理为前端可用的格式，例如给每个 tag 添加 Point 字段用于 Atom 编辑器的定位</li><li>渲染树状图</li></ol><p>第三步中提到“选择合适的语法分析器”意味着 SV 中不止一个语法分析器，这是 SV 的一大特色，下一小节中会详细说明。</p><h3 id="架构设计与实现"><a href="#架构设计与实现" class="headerlink" title="架构设计与实现"></a>架构设计与实现</h3><p>SV 的设计思想其实与 Nuclide 相似，也集成了多个语法解析器，但主要有两点不同：</p><ul><li>基于给用户更好的使用体验以及满足轻量需求的出发点，SV 的解析引擎以 JavaScript 三方库为主，在安装插件时一并安装，无需用户后续手动操作</li><li>SV 中设计了一个通用的语法解析器，定位为“万金油”角色，以满足支持语言的广度</li></ul><p>具体的架构图如下所示。</p><img src="https://wk4vlg.bn.files.1drv.com/y4mLUlTJAXfBGYQwwryeg8IwBCTnFZRjXG7pqyUlIt_i5R04DhxiqJGEHczlmvIfqYusKqKxV-48n8yLPlL8LexeYRBioLbSvOUViST6YEneIe1wQc_X7zyCSsrXOftKnUIoY5mHDLBK-9s9XrEy26WVjD1bAE52y21oEoRuAQ6IENMTlLt_eA1RNW3FYuvMvMhjGqCdg6zkfydvriQrtsVsw"><h4 id="Tag-Generator"><a href="#Tag-Generator" class="headerlink" title="Tag Generator"></a>Tag Generator</h4><p>在 Tag Generator 层封装了各种语言对应的专业语法解析器，SV 判断出代码文件的语言类型，便会选择对应的语法解析器。如果没有某一个语言对应的解析器，则代表目前 SV 还未深度支持，此时就会使用一个名为 Universal 的解析器进行处理。</p><p>Universal 顾名思义就是通用的解决方案，虽不像专业的语法解析器那样能解析得很全面，但是它可以尽可能多地覆盖各种语言，以确保遇到未深度支持的语言时也能得到代码的初略结构信息。秉持着 DRY (Don’t repeat yourself) 原则，SV 借鉴了现有插件，通过配置、使用 ctags 插件来实现这个“万金油”角色。</p><p>由于语法解析器使用了不同的第三方库，获取的原始 tag 数据形式也是各有不同。因此在封装第三方库的过程中，这些语法解析器会遵循统一的数据格式，整理出 <code>name</code> <code>kind</code> <code>position</code> <code>parent</code> <code>id</code> <code>child</code> 等字段。</p><p>此外，Tag Generator 也统一了语法解析器的 API（目前仅有一个），为扩展性提供了保证。未来支持新的语言时，只需在相应目录添加解析器文件，SV 会自动搜索并调用统一的接口。</p><h4 id="Tag-Parser"><a href="#Tag-Parser" class="headerlink" title="Tag Parser"></a>Tag Parser</h4><p>Tag Parser 的作用很简单，就是为 View Controller 提供整理好的树结构资料，方便后者直接渲染。</p><p>由于 Tag Generator 封装了不同的三方库进行 tags 解析，返回的数据结构主要有两种，一是哈希列表，另一种是 AST。这两种格式各有优点，前者在定位 tag 时方便找到对应的节点，无需遍历整颗树；后者作为一颗树，在渲染树状图时水到渠成。</p><p>因此 SV 同时维护了这两种结构的数据，如果语法解析器提供的是哈希列表，Tag Parser 就通过该列表生成相应的 AST，反之亦然。</p><h4 id="View-Controller"><a href="#View-Controller" class="headerlink" title="View Controller"></a>View Controller</h4><p>这一层使用了开源的 MVVM UI 框架 Vue 实现渲染逻辑和交互逻辑，在此就不赘述。</p><h2 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h2><p>语言类型的支持是一项任重而道远的工作，限于人力资源，只能从业务需求和笔者常用的语言出发进行支持。但是个人力量终归是有限的，因此在设计 SV 之初，笔者就考虑到了开源社区，为 SV 编写了详细的英文文档。SV 的用户多是软件开发者，如果能获得他们的认可，提供简单的扩展方法，想必他们中也是有热心人士愿意贡献 PR 的。事实证明，SV 得到了一些 Atom 用户的关注和认同，也有开发者为了自己习惯的语言补充了 <code>.ctags</code> 配置文件，甚至编写语法解析器。</p><p>目前语法解析器主要使用 JavaScript 编写的第三方解析库，这将会受到一定的限制。例如 C/C++ 语言的 AST 解析器有 C/Python/Ruby 语言版本，但未必有 JavaScript 版本，即使有也可能存在健壮性方面的担忧，提供一个通用的办法解决这个问题也极具意义。</p><p>从产品角度看，SV 目前非常粗糙，需要好好打磨。功能上仅支持基本的解析、展示、定位，与主流 IDE 的类似插件相比有一定的差距，需要多向如 WebStorm 之类的优质 IDE 学习。</p><p>最后，SV 的架构设计考虑到了移植性。近年来 VS Code 的横空出世，以其高性能以及对 TypeScript 的优异支持，吸引了一部分 Atom 用户转投阵营。VS Code 同样允许第三方开发者发布插件，目前其市场中的竞品插件功能性较弱、使用人数较低，有机会做得更好。SV 独立出了 View Controller 层，未来如果被移植到其他热门编辑器如 VS Code 时，重写这一层即可。当然，这需要 VS Code 提供更多关于 UI 方面的接口。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>为 ATOM 设计、（目前）专注 Web 前端开发的代码结构提示工具</li><li>灵活的代码标签生成器架构保证了工具的可扩展性</li><li>吸取市面上主流IDE工具的功能特性，力求好用易用</li><li>独立设计、开发，无 IP 依赖，利于推广和开源</li></ul><p>附件：<a href="https://github.com/Joouis/blog/files/1500624/structure-view-intro-cn-v1.0.pdf" target="_blank" rel="noopener">structure-view-intro-cn-v1.0.pdf</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;structure-view （以下简称 SV）是在开发 YunOS Studio（AliOS Studio 前身）时开源出来的一款代码结构提示插件。代码结构提示是一项由来已久的影响开发效率的功能，早在 VIM 时期就有经典的 ctags + Taglist 插件组合来实现这一功能，在桌面时代各大流行的 IDE 也都支持此功能，如 Eclipse 中的 Outline View 或 Webstorm 中的 Structure View。&lt;/p&gt;
&lt;p&gt;YunOS Studio 基于扩展能力优异的 Atom 编辑器开发，由于 Atom 的生态市场缺乏一款好用的代码结构提示插件，因此 SV 应运而生（注：目前主流相关插件的比较可参考附件 PPT 中的 “开发由来与现状” 章节）。&lt;br&gt;
    
    </summary>
    
      <category term="Web 前端" scheme="https://blog.joouis.com/categories/Web-%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="javascript" scheme="https://blog.joouis.com/tags/javascript/"/>
    
      <category term="structure-view" scheme="https://blog.joouis.com/tags/structure-view/"/>
    
      <category term="outline" scheme="https://blog.joouis.com/tags/outline/"/>
    
      <category term="ctags" scheme="https://blog.joouis.com/tags/ctags/"/>
    
      <category term="open source" scheme="https://blog.joouis.com/tags/open-source/"/>
    
      <category term="outline view" scheme="https://blog.joouis.com/tags/outline-view/"/>
    
      <category term="structure view" scheme="https://blog.joouis.com/tags/structure-view/"/>
    
      <category term="atom" scheme="https://blog.joouis.com/tags/atom/"/>
    
      <category term="ide" scheme="https://blog.joouis.com/tags/ide/"/>
    
  </entry>
  
  <entry>
    <title>响应式网站设计基础</title>
    <link href="https://blog.joouis.com/2017/10/04/rwd-fundamentals-note/"/>
    <id>https://blog.joouis.com/2017/10/04/rwd-fundamentals-note/</id>
    <published>2017-10-03T16:14:15.000Z</published>
    <updated>2017-10-11T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="Why-Responsive"><a href="#Why-Responsive" class="headerlink" title="Why Responsive?"></a>Why Responsive?</h2><h3 id="Setting-up-Chrome’s-Dev-Tools"><a href="#Setting-up-Chrome’s-Dev-Tools" class="headerlink" title="Setting up Chrome’s Dev Tools"></a>Setting up Chrome’s Dev Tools</h3><p>使用 Chrome 浏览器的开发者工具除了可以调试 PC 端的页面外，也可以模拟其他尺寸的设备进行调试。<br><a id="more"></a></p><p>首先打开 DevTools，点击设备反转按钮开启移动端视图：</p><img src="https://wk4xlg.bn.files.1drv.com/y4mTTaAk1G49MbIRQs7fFezNIftcdaPcWXydBVauqYUTuNvgv4E9mgf-gY7FN3aal0r6NgqboyK0-PMCprfwVvRNohXz2xJHymNTJjm2nroOG5uY5g_o-bUKPVB9sCX17tjXxQJrBI3w6KUJ0uBXBdpj-68eCq7XCrkqK2P6PZdzUbUcAhFLkr7wxI5DUNm5XB4RCLS-OWYkwFNu11ujH3fWg"><p>如果想模拟特定的设备，可以点击 <code>设备列表</code> - <code>Edit…</code> ，以打开 Settings 列表；然后新增定制设备，设置 <code>Width</code> , <code>Height</code> , <code>Device pixel ratio</code> , <code>User agent string</code> 属性。</p><img src="https://wk4ylg.bn.files.1drv.com/y4mAlxG-j5zwSeqFM7c6lGpqTrMToa2aNBEJBjhHIFBLMdnFjrUD2_sYwZFmA2gLGcGaz0JA73RyihsthtpclzTw0yxroMsE-u2U8mgx725KhKvw22UvniOZGpUgRuyUO1kDGWFrUkQ2iBGsyZZoK9IpflQlcXRRsOG7GG3h9ql25U0cOcqAsYziLQ2pGCXumdlcin5OnPH8HZvjjCWb_T9-g"><h3 id="Using-dev-tools-on-mobile"><a href="#Using-dev-tools-on-mobile" class="headerlink" title="Using dev tools on mobile"></a>Using dev tools on mobile</h3><ul><li><p>Android 设备</p><ol><li>PC 端和 Android 手机安装对应平台的 Chrome 浏览器</li><li>Android 手机开启隐藏的  <code>开发者选项</code> ，进入选项后勾选 <code>USB调试</code> 功能</li><li>手机连接电脑，打开各自的 Chrome 浏览器</li><li>在电脑的 Chrome 浏览器中登录 <code>chrome://inspect</code> ，可以看到连接的手机设备</li></ol><img src="https://wk4alg.bn.files.1drv.com/y4m2in5fYvNssbvGOrwHGxIWFXyVT18UfgzhYfJy6LLJTcWCwJtsVkpyUWSWgchLhUzGJI8ln2N9eGOaqp1o26QQi9c1NZrOlxL_jTirAJMxp-oN0AkL_mHM0vp3pjqCWLAK9UqQr5fD0RS0T-QJxLmSodDt_RZWDDeRBfBwha6lTIEBlzjnGUzFZgRaGcbGpqkFYex6phyTzKg6jm9AUXL6w"><ol start="5"><li>点击 <code>inspect</code> 功能，打开调试页面后即可像调试本地页面一样调试手机端的页面</li></ol></li><li><p>适用于 iOS 的移动工具</p><ul><li>请参考以下文章：<ul><li><a href="https://github.com/google/ios-webkit-debug-proxy" target="_blank" rel="noopener">iOS WebKit 调试代理</a></li><li><a href="https://www.smashingmagazine.com/2014/09/testing-mobile-emulators-simulators-remote-debugging/2/" target="_blank" rel="noopener">Testing Mobile: Emulators, Simulators And Remote Debugging</a></li></ul></li><li>如果觉得麻烦，也可以在 Chrome DevTools 中运行模拟器</li></ul></li></ul><h2 id="Starting-Small"><a href="#Starting-Small" class="headerlink" title="Starting Small"></a>Starting Small</h2><h3 id="Defining-the-Viewport"><a href="#Defining-the-Viewport" class="headerlink" title="Defining the Viewport"></a>Defining the Viewport</h3><p>Q：当我制作网页时，有时候内容过大溢出界面，又或者内容太小需要放大页面才能看清，这是怎么回事呢？</p><p>A：最大的问题是你的视窗没有设置好。</p><p>视窗（Viewport）是指浏览器显示内容的区域。不过不同设备的像素密度是不同的，例如某一 Chromebook 的屏幕分辨率是 2560 * 1700，但是浏览器全屏显示时，窗口的宽度是 1280 而非 2560。</p><h3 id="Pixels-pixels-and-more-pixels"><a href="#Pixels-pixels-and-more-pixels" class="headerlink" title="Pixels, pixels and more pixels!"></a>Pixels, pixels and more pixels!</h3><p>浏览器并不是根据屏幕硬件的像素宽度而工作的，而是根据 DIPs（Device Independent Pixels） 宽度。当硬件像素为 2560，而 DIPs 为 1280 时，DPR（Device Pixel Ratio）也就是 2 倍。</p><p>如果没有设定 meta viewport，浏览器会怎么样呢？</p><ul><li><p>在渲染网页的时候，如果它原本是显示在一个宽 980 DIPs 的屏幕上，现在显示在一个只有 360 DIPs 的屏幕上时，内容就会以超过 2 倍的比例被压缩。</p></li><li><p>然后浏览器为了内容的美观性，会进行一项名为 font boosting 的工作，试图放大页面中的主要内容，而其他内容则维持大小不变。（如下图所示）</p><img src="https://wk4zlg.bn.files.1drv.com/y4mIt-E_waBwSeVHyDwNMSeBf_hU53EbmO-celBkJl7fGorw5adv-d9cubs4CZSMHHOSvI2ot4-wvGx-_2fuZPN5qBXOmmJ8g9CYFDHlgWMYDCDtlCTt_XbBvqnrJcKldOtjlD_1JLPFJJqGiqF9Bh2RbykVFZ7mUQkCCDenh0XePhg_bG5OC2Vyd7oAx8T33iiasnVPv_iX91Kxhj351lZfw"></li></ul><p>Quiz:</p><img src="https://wk4blg.bn.files.1drv.com/y4m6jJb-Nt8OIFPmCVRNDHnnJK-4f01faf3UkOKufQhfZKij8DQRtuyw8g9bOeKGib4JnDjlffly3xb3HNHyFwXcbiCK5RYBkkHUoUY6tCbViIhPISP6lnEdMM6fXvPp5FXjg8RpkOw4BrDFqzkZOFijGnV5f6pI_YCOEhTpvy3EDK7mLQT2fFC5rjEwHJCV4WVJHlHMrxSRAqAwu5cqN5YRQ"><p> <br></p><img src="https://wk4clg.bn.files.1drv.com/y4my5vat3L5hkaetGF633ztT_hPNq_x-CxF6ccFZsYVlwrEJoH5XDMyZHw3zANYYKkfYCsv7D_WbF3hqvvagEfKGh_eCMfdDPM-kxX_zzddZXsIMQaX5PpfT29jlX5BKCS_tfmWkpJByqaaDpNw7oUlak_cTSVGjEVacVli5k7eHjX-LdlGLkbniz8ALh5s6aJSrlbA5MQJqb_ukENDoqQPfQ"><h3 id="Setting-the-Viewport"><a href="#Setting-the-Viewport" class="headerlink" title="Setting the Viewport"></a>Setting the Viewport</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1"</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>width=device-width</code> ：指导页面针对具体设备进行宽度调整，使得页面可以匹配不同屏幕尺寸</li><li><code>initial-scale=1</code> ：添加初始缩放比例属性并赋值为 1，使得 DIPs 和 CSS 像素的比例是一比一。如果不把初始缩放比例设为 1，有的浏览器会在切换到横屏模式时依旧保持之前的页面宽度，而且它们还会使内容只进行比例缩放，而无法自动调整布局（Reflow）</li></ul><h3 id="Max-width-on-elements"><a href="#Max-width-on-elements" class="headerlink" title="Max-width on elements"></a>Max-width on elements</h3><p>CSS 是允许内容溢出其容器的，预防这一情况出现可以进行如下推荐的设置：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">img</span>, <span class="selector-tag">embed</span>, <span class="selector-tag">object</span>, <span class="selector-tag">video</span> &#123;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Tap-Target-Sizes"><a href="#Tap-Target-Sizes" class="headerlink" title="Tap Target Sizes"></a>Tap Target Sizes</h3><p>使用鼠标可以很轻松地点击到按钮等元素，但是如果使用手指，操作的精准度相比之下就糟糕许多。</p><p>我们的手指宽度大概是 10mm ，约等于 40 CSS 像素，所以按钮的大小至少要设置为 40*40px。推荐设置为 48*48px，这样能确保元素之间有足够的距离，也能照顾到手指更粗的人。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span>, <span class="selector-tag">button</span> &#123;</span><br><span class="line">  <span class="attribute">min-width</span>: <span class="number">48px</span>;</span><br><span class="line">  <span class="attribute">min-height</span>: <span class="number">48px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Start-Small"><a href="#Start-Small" class="headerlink" title="Start Small"></a>Start Small</h3><p>设计响应式网页的概念与过程和非响应式是一样的，除了前者需要多画几种宽度的设计稿以适应不同屏幕尺寸。</p><p>这里推荐从最小屏幕尺寸的页面开始设计，通常是手机设备。做完之后再接着做更大一点的，依次类推，直至页面宽度上限。从最小的屏幕做起，开发者就必须优先考虑什么是对用户最重要的（Prioritize content!）、什么操作是用户最常做的、什么内容是用户最希望在屏幕上看到的。如果从最大尺寸往小设计，一些重要的信息很可能会被删除。<strong>因此，明确内容的优先级，然后从小到大设计，最重要的内容永远都会留在页面上。无论用户使用什么样的设备，也能得到最完整的体验。</strong></p><p>除了设计上从小到大外，代码的编写也推荐如此，这样就能知道页面的风格和布局是否能兼容任何设备。此外，这样做也能帮助开发者从性能角度思考。</p><h2 id="Building-Up"><a href="#Building-Up" class="headerlink" title="Building Up"></a>Building Up</h2><h3 id="Adding-a-Basic-Media-Query"><a href="#Adding-a-Basic-Media-Query" class="headerlink" title="Adding a Basic Media Query"></a>Adding a Basic Media Query</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"style.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">media</span>=<span class="string">"screen and (min-width: 500px)"</span> <span class="attr">href</span>=<span class="string">"over500.css"</span></span></span><br></pre></td></tr></table></figure><p>添加了上面的媒体查询属性后，”over500.css” 样式表将在 DIPs 宽度大于 500px 时应用。</p><p>如果查询 Media Query 的相关文档，References 中可能还会提到其他媒体类型如 <code>handheld</code> <code>projected</code> <code>embossed</code> ，其实这些类型并不起作用，可以先忽略。目前只需要掌握 <code>screen</code> 和 <code>print</code> （打印页面时使用）即可。</p><p>除了在 <code>&lt;link&gt;</code> 标签中使用媒体属性外，以下还列举了两种方式进行媒体查询。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">media</span> screen and (max-width: <span class="number">300px</span>) &#123;</span><br><span class="line">  <span class="comment">/* Set style here */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Complex Media Query */</span></span><br><span class="line">@<span class="keyword">media</span> screen and (min-width: <span class="number">480px</span>) and (max-width: <span class="number">960px</span>) &#123;</span><br><span class="line">  <span class="comment">/* Set style here */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">import</span> url(<span class="string">"over500.css"</span>) only screen and (min-width: <span class="number">500px</span>);</span><br></pre></td></tr></table></figure><p>不过由于性能的因素，应该避免使用 <code>@import</code> 方式！它是一个性能消耗和优先级都非常高的标签（It’s pretty expensive and perf matters），相比 <code>@media</code> 方式需要更多的 HTTP 请求。</p><p>另外不推荐 <code>min-device-width</code> 和 <code>max-device-width</code> 这两个属性，原因自己想吧；）</p><h3 id="Breakpoints-and-Picking-Them"><a href="#Breakpoints-and-Picking-Them" class="headerlink" title="Breakpoints and Picking Them"></a>Breakpoints and Picking Them</h3><p>使用媒体查询的 <code>min-width</code> 和 <code>max-width</code> 可以改变整个页面的布局，而页面布局改变时的那个宽度尺寸叫做间断点。以 <a href="https://medium.com/" target="_blank" rel="noopener">medium.com</a> 来说，有 2 个间断点（ 于 2017.09 观察 medium 首页），观察间断点时建议从小的尺寸开始。</p><p>你永远不知道下一个热门的设备是什么，也不会知道两年后的流行趋势会是怎样，因此根据自己网页的内容寻找合适的间断点才是正道。</p><blockquote><p>我们不应该规定任何间断点，相反，我们应该使用内容作为指引找到它们。—— Scott Yale</p></blockquote><h3 id="Grids"><a href="#Grids" class="headerlink" title="Grids"></a>Grids</h3><p>当我们可以使用媒体查询和间断点控制 CSS 样式后，自然而然会想问，有没有什么常用的模式（Patterns）或基本策略（Strategies）可以参考。</p><p>在常用的一些模式中，最简单的当属动态网格系统（Grid Fluid System），可以参考 <a href="https://www.html5rocks.com/en/tutorials/" target="_blank" rel="noopener">HTML5 Rocks</a> 作为范例。</p><p>在这个系统中有一些动态调整的纵列，当窗口变小时，它们将自动顺延到下一行。目前已经有一些优秀的框架可以使用，例如 Bootstrap、960px grid layout system。</p><h3 id="Flexbox"><a href="#Flexbox" class="headerlink" title="Flexbox"></a>Flexbox</h3><p>Flexbox 是目前最强大的布局工具之一，被广泛推荐，也已经被绝大多数浏览器支持。下面将会介绍一些基本语法，需要注意的是，在未来编写产品代码时，一定要包含所有版本的浏览器引擎前缀（Vendor Prefixed Version），以确保使用旧版浏览器的用户也能获得相同体验。</p><p>Flexbox 之所以功能强大，是因为它能够自动填充空白区域。如果一个元素周围出现了空白，它会自动填补上；而如果空间变得拥挤，元素会自动缩小。</p><p>使用 Flexbox 的第一步是加入 <code>display: flex;</code> 属性，这样容器内垂直排列的元素将会自动显示在一行内（ Flex 的默认堆放方式为横向堆放 <code>row</code> ）。此时拖动浏览器，无论宽度多少，横向堆放的元素们都不会换行。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要改变这种情况，可以为容器添加 <code>flex-wrap: wrap;</code> 属性，这是在告诉浏览器，允许内部的元素换行。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: wrap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Flexbox 还有一个有用的特性是利用 CSS order 属性来改变元素的次序。</p><img src="https://v64tlg.bn.files.1drv.com/y4mv4XLjecjhVGpKRzVs49bjd9OUy9jiEIu0FAKPE0s7Y5EZHBv2RJbpET8EblfdRJX-yHPS8tfjKpJHZg2yXNFaHMVqBUlm1lctd-Z2-V9aqT4ZpQzLp_LVWPm3sSiayYpJmbX2jGnAQUjQ1LjIFVtlsc0GzBQnE7DpKDI7yWkLwdVC4vKEuT-LF__hf0i0KBcKuIHQA2UTKvS3L1yWb-18A"><h2 id="Common-Responsive-Patterns"><a href="#Common-Responsive-Patterns" class="headerlink" title="Common Responsive Patterns"></a>Common Responsive Patterns</h2><p>模式的变化很快，但也有一些通用的模式几乎能在任何设备上有不错的表现。响应式网页布局大致可以分为四种模式：Mostly Fluid、Column Drop、Layout Shifter 和 Off Canvas，有时候一个页面也会使用如 Column Drop 和 Off Canvas 的组合。</p><p>接下来将会讲解每种模式是怎样工作的，以及如何使用 Flexbox 和媒体查询技术来实现它们。注意在以下的示意图中，不同色块代表不同的内容区域。</p><h3 id="Column-Drop"><a href="#Column-Drop" class="headerlink" title="Column Drop"></a>Column Drop</h3><p>此布局共有两个间断点，在不同宽度时的排版如下图所示。</p><img src="https://v64vlg.bn.files.1drv.com/y4mxdqh6iWBDr_eboXIKYOaaEa_d4rkKR0sNQE97hdF-QJDEh9IDvKIm0U7m79nJiie92TnUX7a20WNf5C24sJ5QAdXMWjhxzsRfh93d7t7o0ciA9JZp0hdycVtk0MsRasNyFhr2LCqS05zy-ieUb1f9z3Og8T_0zFOI_emHPSSmliPdLobqe9lggP048O9ZVPAWuhQxEE9c8ctppLvCkivnQ"><p>代码范例非常简单：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box dark-blue"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box light-blue"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box green"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex</span>: wrap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">media</span> screen and (min-width: <span class="number">450px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.dark-blue</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">25%</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.light-blue</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">75%</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">media</span> screen and (min-width: <span class="number">550px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.dark-blue</span>, <span class="selector-class">.green</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">25%</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.light-blue</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Mostly-Fluid"><a href="#Mostly-Fluid" class="headerlink" title="Mostly Fluid"></a>Mostly Fluid</h3><p>此布局与 Column Drop 模型相似，但是更像网格系统，最明显的区别在于当视窗宽度达到最大宽度时，两边会出现外边距而内容不再延展。</p><img src="https://v64ulg.bn.files.1drv.com/y4mPB3jzdwrrUvC0FB3yqZCvEIGUtAgvQvx6XypAfdTdQP0lY015qeTwWkLTf83nds2vk6ebHgqyEojSvB5KBLvZbeCZUxby9vG-cb89BJ-F87R6DQa5AeU923fOAebYDmkjJl4W2wSAWqpLseYmjnfyctYY2vx3GPSCKEF6844dj48xm9bPvSTzSVg03ywjrgmE9yYrgyXI5XG_2xRtyLibw"><p>代码范例如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box dark-blue"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box light-blue"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box green"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box red"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box orange"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: wrap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">media</span> screen and (min-width: <span class="number">450px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.light-blue</span>, <span class="selector-class">.green</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">media</span> screen and (min-width: <span class="number">550px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.dark-blue</span>, <span class="selector-class">.light-blue</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.green</span>, <span class="selector-class">.red</span>, <span class="selector-class">.orange</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">33.333333%</span>;<span class="comment">/* <span class="doctag">TODO:</span> use "flex: 1" instead */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">media</span> screen and (min-width: <span class="number">700px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">700px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: auto;</span><br><span class="line">    <span class="attribute">margin-right</span>: auto;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Layout-Shifter"><a href="#Layout-Shifter" class="headerlink" title="Layout Shifter"></a>Layout Shifter</h3><p>Layout Shifter 布局模型应该是最灵活的响应式模型了，它有很多适用于不同设备的间断点，但最关键的是它的布局变化方式并不是单纯的重排到其它列的下方（参见下图中的红色列）。Flexbox 的亮点在这才真正凸显，因为我们可以利用 CSS 顺序属性来实现这种变化。</p><img src="https://v64wlg.bn.files.1drv.com/y4mqr8SRAqQVlou1gI4oql1M45wwzLtecM8rvtec4RRKIhbFvTiYv2QvHmjZDfDb0ODu9Du6cSQQccNhq3iVBH0cle69ICePNw-sAqr16DTCsDHjwXC7QfHIGfVKiuUyzj65gjm182iaLWgtdyB7QSS6Vv4ooN69y0DjyoCU24-i2Can_JmEB44A_guNSK95TTY_3r4-Yzq1r-ztSGIdBHvgA"><p>这次的代码范例稍微复杂一点：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box dark-blue"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span> <span class="attr">id</span>=<span class="string">"container2"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box light-blue"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box green"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box red"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: wrap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">media</span> screen and (min-width: <span class="number">500px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.dark-blue</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-id">#container2</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">media</span> screen and (min-width: <span class="number">600px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.dark-blue</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">25%</span>;</span><br><span class="line">    <span class="attribute">order</span>: <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-id">#container2</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.red</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">25%</span>;</span><br><span class="line">    <span class="attribute">order</span>: -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Off-Canvas"><a href="#Off-Canvas" class="headerlink" title="Off Canvas"></a>Off Canvas</h3><p>在此模型中，内容并不是垂直堆放的，而是将不常用的内容比如导航栏或者应用菜单放在屏幕外，只有当屏幕足够大的时候才显示出来。在小尺寸屏幕上，溢出画布的内容通常会在用户点击菜单按钮时出现。</p><img src="https://v64zlg.bn.files.1drv.com/y4mPHMLIxPrWCktIwkBiJAUzuajI-PSY9QFVUBBuIQinr4ZDoTBhRalx8YNXMyWTSiwwOwEeXlNXi4pcOBMj1TqGcphSzCUoWh1yUKX_BVcP7DOXeZcAoFYwdzOnAZnEV5AwQqBBYyAkDd3q3VosYy7YIiU36_1DC544X9I-uLlVXCwMREUh11MTZtqo2y1i0e7jba_CDijZPg9xGjGlhn43A"><p>代码范例如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">nav</span> <span class="attr">id</span>=<span class="string">"drawer"</span> <span class="attr">class</span>=<span class="string">"dark-blue"</span>&gt;</span><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">main</span> <span class="attr">class</span>=<span class="string">"light-blue"</span>&gt;</span><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span>, <span class="selector-tag">body</span>, <span class="selector-tag">main</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">nav</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-300px, 0);</span><br><span class="line">  <span class="attribute">transition</span>: transform <span class="number">0.3s</span> ease;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">nav</span><span class="selector-class">.open</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(0, 0);</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">media</span> screen and (min-width: <span class="number">600px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">nav</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(0, 0);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">flex-flow</span>: row nowrap;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">main</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: auto;</span><br><span class="line">    <span class="attribute">flex-grow</span>: <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">menu.addEventListener(<span class="string">'click'</span>, e =&gt; &#123;</span><br><span class="line">  draw.classList.toggle(<span class="string">'open'</span>);</span><br><span class="line">  e.stopPropagation();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>点击<a href="http://udacity.github.io/RWDF-samples/Lesson4/patterns/off-canvas.html" target="_blank" rel="noopener">此处</a>查看 Live demo。</p><p>Quiz: Off Canvas Visualization Quiz</p><img src="https://v64ylg.bn.files.1drv.com/y4mOfH4p-_gXKdrDJ0PbOuL3altg-9PY5rAtTWp26OdcBxNWaOsw6Wv07KxabhjWx9AIgW7jc6Njq8ievp4HERpSqfd8mbTvVQc6cyJCVnDIt4p-gTavaJ-_tL8ZrerEfgpaMfXGZM1CQq8xH9SkicQRS-2TTUOSHEkAK3io9WdM6tcHZusICJwHpKgacCCO0de8E8amUO4Rtca4DUC79n2qg"><h2 id="Optimizations"><a href="#Optimizations" class="headerlink" title="Optimizations"></a>Optimizations</h2><h3 id="Images"><a href="#Images" class="headerlink" title="Images"></a>Images</h3><blockquote><p>A picture is worth 1000 words.</p></blockquote><p>使用同一张图片时，改变其分辨率可能是最常用的方式之一。试想在笔记本电脑上显示一张标准图片，但显示一张两倍大的图片给一个更高 DPI 的显示器，例如一台 Retina iMac。又或者是在不同尺寸的设备上显示图片时，显示不同内容的图片。要实现这些效果，图片元素可以使用媒体查询来选择使用哪张图片。</p><h3 id="Responsive-Tables"><a href="#Responsive-Tables" class="headerlink" title="Responsive Tables"></a>Responsive Tables</h3><p>表格有很多花样，如果其列超过一定的数量，是很有可能溢出视窗的，在小屏幕上会产生水平滚动条。有一些方法可以解决这个问题，以下是三种参考方案。</p><h4 id="Hidden-Columns"><a href="#Hidden-Columns" class="headerlink" title="Hidden Columns"></a>Hidden Columns</h4><p>当视窗尺寸缩小时，Hidden Columns 实际上是根据表格的重要性来进行隐藏的。从小屏幕开始设计时，思考什么信息是最重要的，然后保留下来，隐藏其他不显示的内容。</p><p>Hidden Columns 最大的问题在于隐藏了内容，如果这些被隐藏的内容刚好是用户想知道的就麻烦了。如果可以，请使用缩写而不是完全隐藏内容。</p><img src="https://v64xlg.bn.files.1drv.com/y4m-Ivf4Uo1G75Gb_ekkSZRyD-S6LUKJFW4BR1fkXKoMyokyLD-SjYyzQRnusyiJ4_b_R0PanL1b3xkaBA7zmQGuDW6AyRSxAVq0u5g7K4SNsr8awwo7DBCsJ4qpQLXT1RH4A4jPRCg-PFbOhBtOpHp4_uw9eRMxh2CHG_H-4qf1PCOePBKYi9a2Y3Xuo2l5SvjiyAmD_zt9lUnlR0ZGQEj1A"><h4 id="No-More-Tables"><a href="#No-More-Tables" class="headerlink" title="No More Tables"></a>No More Tables</h4><p>当视窗小于一定值时，表格会瓦解，并重组成长列表。这种方法的好处是所有数据都是可见的，无论视窗尺寸多大。</p><h4 id="Contained-Scrolling"><a href="#Contained-Scrolling" class="headerlink" title="Contained Scrolling"></a>Contained Scrolling</h4><p>为了把表格放在视窗中，最简单的做法就是把它放在一个 <code>div</code> 里，然后设置宽度为 100%，最后设置 <code>overflow-x: auto;</code>。虽然表格还是会占据同样的宽度，但是可以用滚动条在视窗中拖动查看。</p><h3 id="Fonts"><a href="#Fonts" class="headerlink" title="Fonts"></a>Fonts</h3><p>如果一段文字的每一行太短或太长，阅读起来都会让人感到不舒服，因此理想的文字行宽很重要。这是个很有技术含量的问题，目前已经有一些研究成果表明，依据使用的字体、显示的设备不同，每行 45 个字符到 90 个字符都是合理的。不过，<strong>在网页中大概每行 65 个字符是最常见的</strong>。这并不是硬性规定，但是个不错的建议。与此同时，行宽也是选择断点时的重要参考因素之一。</p><p>此外，用户的阅读体验也非常重要。以字体的大小和行高来举例：在不同设备上字体需要足够的大以保证用户看得清楚，通常建议至少设为 16px；而行高至少有 1.2em 才不会使文字看起来太拥挤。</p><h3 id="Minor-Breakpoints"><a href="#Minor-Breakpoints" class="headerlink" title="Minor Breakpoints"></a>Minor Breakpoints</h3><p>除了选择令布局显著改变的主断点（Major Breakpoints）外，增加副断点来实现一些小的改变是很有帮助的。例如，在主断点之外调整元素的外边距，或者给一些内容增大字号使其更容易阅读（布局上也会更加自然一点）。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li>Udacity - <a href="https://classroom.udacity.com/courses/ud893" target="_blank" rel="noopener">Responsive Web Design Fundamentals</a></li><li>PageSpeed Insights - <a href="https://developers.google.com/speed/docs/insights/ConfigureViewport" target="_blank" rel="noopener">Configure the Viewport</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Why-Responsive&quot;&gt;&lt;a href=&quot;#Why-Responsive&quot; class=&quot;headerlink&quot; title=&quot;Why Responsive?&quot;&gt;&lt;/a&gt;Why Responsive?&lt;/h2&gt;&lt;h3 id=&quot;Setting-up-Chrome’s-Dev-Tools&quot;&gt;&lt;a href=&quot;#Setting-up-Chrome’s-Dev-Tools&quot; class=&quot;headerlink&quot; title=&quot;Setting up Chrome’s Dev Tools&quot;&gt;&lt;/a&gt;Setting up Chrome’s Dev Tools&lt;/h3&gt;&lt;p&gt;使用 Chrome 浏览器的开发者工具除了可以调试 PC 端的页面外，也可以模拟其他尺寸的设备进行调试。&lt;br&gt;
    
    </summary>
    
      <category term="Web 前端" scheme="https://blog.joouis.com/categories/Web-%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="note" scheme="https://blog.joouis.com/tags/note/"/>
    
      <category term="web" scheme="https://blog.joouis.com/tags/web/"/>
    
      <category term="tutorial" scheme="https://blog.joouis.com/tags/tutorial/"/>
    
      <category term="rwd" scheme="https://blog.joouis.com/tags/rwd/"/>
    
      <category term="flex" scheme="https://blog.joouis.com/tags/flex/"/>
    
      <category term="css" scheme="https://blog.joouis.com/tags/css/"/>
    
      <category term="responsive" scheme="https://blog.joouis.com/tags/responsive/"/>
    
  </entry>
  
  <entry>
    <title>服务器端渲染姿势探索</title>
    <link href="https://blog.joouis.com/2017/09/14/server-side-rendering-review/"/>
    <id>https://blog.joouis.com/2017/09/14/server-side-rendering-review/</id>
    <published>2017-09-14T12:46:51.000Z</published>
    <updated>2017-11-13T11:43:15.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>服务器端渲染（Server-Side Rendering，以下简称 SSR）并非是一门新技术，早期就有 Java, PHP 等后端语言进行页面渲染，后来 JavaScript 兴起、 Jquery, Backbone, React, Vue 等视图框架流行，前端逐渐夺回了渲染的地盘。随着如 Express, Koa 等 Node Web 应用程序框架的出现，SSR 以同构渲染（isomorphic rendering）的方式再次强势归来。<br><a id="more"></a></p><p><img src="https://cloud.githubusercontent.com/assets/948896/25062958/ca1b6618-2209-11e7-99ae-c2a75ad3dabb.png" alt></p><p>由于 SSR 在初次请求页面时已经包含了页面所需的数据内容（甚至是 CSS 和 JS 脚本），因此带来了两点好处：</p><ul><li>首屏性能：省去异步请求数据的时间</li><li>SEO 优势：防止 SEO 爬虫因缺少异步请求而错失的关键内容</li></ul><p>当然在同构渲染模式下，前后端都由前端工程师进行开发，这无形中也是一个很大的优势。</p><p>下面笔者将结合自己参与过的几个应用，分享在 SSR 方面的一点探索心得。</p><h2 id="从0到1：不求甚解，先摆个姿势再说"><a href="#从0到1：不求甚解，先摆个姿势再说" class="headerlink" title="从0到1：不求甚解，先摆个姿势再说"></a>从0到1：不求甚解，先摆个姿势再说</h2><p>笔者之所以会用到 SSR，现在回想起来也有点偶然：那个时候笔者的前主管经过一番调研，发现淘系的前后端分离框架 Midway 不错，于是基于它开发了一个轻量级的 Web 应用。</p><p>Midway 内置了一款名为 XTemplate 的模板引擎（类似 Nunjucks 的轮子），那时候身为前端小白的笔者看了这玩意，心想不就是一个 HTML 的超集么，虽然是方便那么一丢丢，但是为什么会有这类模板引擎，没想明白。</p><p>在没有吃透这项技术的情况下，笔者和师兄写出了 Xtpl 和 Vue “水乳交融” 的代码，而整个页面渲染逻辑如下：</p><p><img src="https://user-images.githubusercontent.com/8896124/32724607-92c0cddc-c837-11e7-88fe-7ae2a123cc9f.jpg" alt="uml-old"></p><p>由于业务长期对页面性能方面缺乏需求，大家都觉得这套方案没啥问题，即使偶尔在登入、刷新时会出现<strong>一些排列整齐的「{{}}」符号一闪而过</strong>，也只被解释成这就是稍微有点慢。</p><p>意识到这个姿势有问题时笔者已经换了一个团队，完全没有前端工程基础，打造一套服务于当前业务的高效前端开发体系是首要目标。在回顾之前使用的技术栈时，针对 SSR 笔者一下子就想到了两个问题（OS：“你个傻X当初想什么去了…”）：</p><ol><li>既然客户端要异步请求表格数据，为何一开始不直接存在 DOM 中发过去？</li><li>需要 Vue 渲染的内容，能不能用模板引擎（如 XTemplate）渲染？如果能为什么要留到客户端渲染？</li></ol><p>第一个问题讨论的就是 SSR 的主要价值之一，在文章开头已经介绍过；而第二个问题后面还会有详细讨论。总而言之，之前的那种设计思路，完全废掉了这项技术，相比单纯的客户端渲染还浪费了服务器上模板引擎解析的时间，尽管理论上这个性能损耗极小。</p><h3 id="姿势小结"><a href="#姿势小结" class="headerlink" title="姿势小结"></a>姿势小结</h3><p>使用 SSR 的原则应当是尽量把页面所需的数据都渲染或存在页面中，能节省一次或多次 HTTP 请求时间；需要大量数据的图表是个例外，但这种情况更合适的做法应该是首次粗粒度显示、后续再通过异步请求灵活调整。另外能在服务器端渲染的内容尽量使用模板引擎渲染，后续客户端的工作再交由 Vue 等框架来做。</p><p>至于收益嘛，就看异步请求的数量和当下的网速了。</p><h2 id="同构还是不同构，这是个问题！"><a href="#同构还是不同构，这是个问题！" class="headerlink" title="同构还是不同构，这是个问题！"></a>同构还是不同构，这是个问题！</h2><p>书接上文，有一个问题是 Xtpl 能否替代 Vue 渲染一些内容，其实这个问题反过来问才更合适：<strong>React, Vue 官方都已支持 SSR，甚至出现了 Next.js 和 Nuxt.js 这样的定制 Web 框架，是否还需要使用 Xtpl 之类的模板工具？</strong></p><p>既然做技术选型，优缺点的对比必不可少。</p><p>先说 React, Vue 这样的同构渲染，最大的好处就是一套 JS 代码在服务端和客户端是共用的。以 React 为例，使用 <code>renderToString</code> 或 <code>renderToStaticMarkup</code> 将客户端的组件转化为字符串供服务端使用，具体的实现可以参考 <code>引用2</code>。同构的好处反过来也就是使用模板渲染的坏处，在 UI 框架必备的前提下，多学习、使用、调试一门语言，成本肯定会增加。</p><p>但是使用模板的好处也是存在的，首先是性能上的优势。</p><p>笔者使用 Rax 提供的跑分方法对主流渲染框架/引擎进行了性能测试，具体结果如下。测试结果以每秒钟执行测试代码的次数（<em>Ops</em>/<em>sec</em>）显示，这个数值越大渲染性能越好。可以看到 Xtpl 的性能远超 React, Vue 等框架，这是因为 React 等框架在渲染时需要构造 vDOM 然后才能输出 HTML，而 Xtpl 这样的模板引擎只需要在模板上做简单的“翻译”命令即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">React#</span><span class="bash">renderToString x 540 ops/sec ±2.43% (78 runs sampled)</span></span><br><span class="line"><span class="meta">Rax#</span><span class="bash">renderToString x 878 ops/sec ±5.38% (74 runs sampled)</span></span><br><span class="line"><span class="meta">Inferno#</span><span class="bash">renderToString x 1,111 ops/sec ±6.35% (70 runs sampled)</span></span><br><span class="line"><span class="meta">Preact#</span><span class="bash">renderToString x 557 ops/sec ±6.72% (67 runs sampled)</span></span><br><span class="line"><span class="meta">Vue#</span><span class="bash">renderToString x 233 ops/sec ±36.37% (68 runs sampled)</span></span><br><span class="line"><span class="meta">Marko#</span><span class="bash">renderToString x 4,580 ops/sec ±5.25% (73 runs sampled)</span></span><br><span class="line"><span class="meta">Xtpl#</span><span class="bash">renderFile x 4,606 ops/sec ±7.13% (53 runs sampled)</span></span><br><span class="line">Fastest is Marko#renderToString,Xtpl#renderFile</span><br></pre></td></tr></table></figure><p>除此之外，Xtpl 的优势就是在开发 Memory Analysor 等应用时积累的业务代码和经验了，没有学习成本，当业务压力大时，先顶一阵子也没什么问题；）</p><p><em>注：现在无论是 React 还是 Vue 都对 SSR 进行了优化，通过缓存策略极大地改善响应时间并减少服务器的负载，延伸阅读可参考 <code>引用4</code> <code>引用5</code>。下图为 React 针对 SSR 优化的前后性能对比图。</em></p><p><img src="https://raw.githubusercontent.com/walmartlabs/react-ssr-optimization/master/images/react-renderToString-cpu-profile.png" alt="React SSR Opt"></p><h3 id="姿势小结-1"><a href="#姿势小结-1" class="headerlink" title="姿势小结"></a>姿势小结</h3><p>这是在最近开发一款新应用时遇到的问题，考虑到项目中第一次使用 React 和 Webpack 进行开发构建，为了进度的平稳，还是先采用 Xtpl +  React 这样的混合方案，等未来迭代时再逐步替换为同构方式。得益于模块化的开发风格，Xtpl 和 React 各司其职，完全解耦。</p><h2 id="请求不要放在一个篮子里"><a href="#请求不要放在一个篮子里" class="headerlink" title="请求不要放在一个篮子里"></a>请求不要放在一个篮子里</h2><p>某一次笔者特意给自己挖了个坑，想看看什么时候会掉下去，没想到很快就如愿以偿了=。=</p><p>前文总结时已经提到过，既然是请求首屏数据，就只需要先获取第一屏的内容，并且如果遇到大量数据的图表时还应调整粒度进行“压缩”。但是为了体会到那种慢的感觉，笔者特意把页面所有的数据都请求完了才进行渲染，而页面内容包含三图一表…</p><p>起初完全感觉不到这样做的危害，直到数据库库表里的数据达到百万条，一条 SQL 请求语句需要 6-7s 时，页面载入的速度就令人很不爽了。</p><h3 id="姿势小结-2"><a href="#姿势小结-2" class="headerlink" title="姿势小结"></a>姿势小结</h3><p>和 SSR 相关的解决办法其实就是初次渲染时只请求首屏数据，其他数据待客户端加载完毕后再异步请求。</p><p>不过既然都提到了这个例子，也顺带说一下还做了其他哪些事：</p><ul><li>添加 SQL 请求中的条件字段为索引</li><li>根据业务背景增加有意义的条件限制</li><li>服务端 cache 住可以复用的共享数据</li></ul><h2 id="报告！HTML字符串有小动作"><a href="#报告！HTML字符串有小动作" class="headerlink" title="报告！HTML字符串有小动作"></a>报告！HTML字符串有小动作</h2><p>又在某一个项目开发中，笔者将首屏数据存在了 DOM 里，准确地说是将数据存放在了一个节点的属性中，当客户端加载代码后再读取数据进行后续工作。代码示例如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.xtpl --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"module1"</span> <span class="attr">data</span>=<span class="string">"&#123;&#123;data&#125;&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"/public/index.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> Module1 <span class="keyword">from</span> <span class="string">'./module1.jsx'</span>;</span><br><span class="line"><span class="keyword">let</span> src = $(<span class="string">'#module1'</span>).attr(<span class="string">'data'</span>);</span><br><span class="line">Module1.render(<span class="built_in">JSON</span>.parse(src));</span><br></pre></td></tr></table></figure><p>后来在 review 代码时，发现一个显而易见的性能优化点：DOM 的操作很昂贵， 将数据存放在 DOM 中再通过 API 获取属于多此一举。Xtpl 文件作为模板，实质上就是字符串，数据插入到字符串的任意位置都是允许的，只是最终的意义不同。如果将数据写到模板的 <code>&lt;script&gt;</code> 中，客户端加载时数据就直接到内存里了。</p><p>改进后的代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.xtpl --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"module1"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="built_in">window</span>.INITIAL_DATA = &#123;&#123;&#123;data&#125;&#125;&#125;;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> Module1 <span class="keyword">from</span> <span class="string">'./module1.jsx'</span>;</span><br><span class="line">Module.render(<span class="built_in">window</span>.INITIAL_DATA);</span><br><span class="line"><span class="keyword">delete</span> <span class="built_in">window</span>.INITIAL_DATA;</span><br></pre></td></tr></table></figure><p>不过笔者对于性能方面的担忧是多余的（<strong>DOM 操作昂贵没错，但不是贵在这里！可从浏览器的工作原理角度出发思考这一问题</strong>），这两段代码的执行效率几乎没有差别：在数据（字符串形式）量达到 36.7 KB 时，第一份代码对 DOM 的读取操作和 <code>JSON.parse()</code> 方法都是在 5ms 以内完成的。</p><p>反倒是页面体积有了明显的变化：</p><table><thead><tr><th></th><th>数据存在DOM中</th><th>数据存在内存中</th></tr></thead><tbody><tr><td>Page1</td><td>42.1KB</td><td>23.9KB</td></tr><tr><td>Page2</td><td>67KB</td><td>38.6KB</td></tr></tbody></table><p>原因很有趣，当把数据存在 DOM 中时，需要先将 JS Object 转换为 JSON 格式的字符串。随后在 JSON 字符串写入 HTML 的过程中，所有的双引号都被转义字符 <code>$quot;</code> 所替换。而将数据直接写在 <code>&lt;script&gt;</code> 中就不存在这种情况，简单的字符串拼接后，就是一条赋值语句。经模板生成的网页源代码如下所示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Previous --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"module1"</span> <span class="attr">data</span>=<span class="string">"&#123;&amp;quot;key&amp;quot;:value&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Now --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"module1"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="built_in">window</span>.INITIAL_DATA = &#123;<span class="string">"key"</span>:value&#125;;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="姿势小结-3"><a href="#姿势小结-3" class="headerlink" title="姿势小结"></a>姿势小结</h3><p>在 UTF-8 编码下，每当 JSON 字符串中出现一个双引号，前者就要比后者多耗费 5 个字节，当数据量很大时，页面体积就会出现很明显的差异。这在无线端等网络状况不稳定的业务场景中值得关注。</p><h2 id="引用-amp-延伸阅读"><a href="#引用-amp-延伸阅读" class="headerlink" title="引用&amp;延伸阅读"></a>引用&amp;延伸阅读</h2><ol><li><a href="https://github.com/camsong/blog/issues/8" target="_blank" rel="noopener">精读前后端渲染之争</a></li><li><a href="http://blog.techbridge.cc/2016/08/27/react-redux-immutablejs-node-server-isomorphic-tutorial/" target="_blank" rel="noopener">一看就懂的 React Server Rendering（Isomorphic JavaScript）入門教學</a></li><li><a href="http://www.alloyteam.com/2017/01/react-from-scratch-server-render/" target="_blank" rel="noopener">从零开始React服务器渲染</a></li><li><a href="https://github.com/raxjs/server-side-rendering-comparison" target="_blank" rel="noopener">server-side-rendering-comparison</a></li><li><a href="https://github.com/walmartlabs/react-ssr-optimization" target="_blank" rel="noopener">React Server-Side Rendering Optimization Library</a></li><li><a href="https://ssr.vuejs.org/zh/caching.html" target="_blank" rel="noopener">Vue.js 服务器端渲染指南 - 缓存</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;服务器端渲染（Server-Side Rendering，以下简称 SSR）并非是一门新技术，早期就有 Java, PHP 等后端语言进行页面渲染，后来 JavaScript 兴起、 Jquery, Backbone, React, Vue 等视图框架流行，前端逐渐夺回了渲染的地盘。随着如 Express, Koa 等 Node Web 应用程序框架的出现，SSR 以同构渲染（isomorphic rendering）的方式再次强势归来。&lt;br&gt;
    
    </summary>
    
      <category term="Web 前端" scheme="https://blog.joouis.com/categories/Web-%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="SSR" scheme="https://blog.joouis.com/tags/SSR/"/>
    
      <category term="server-side" scheme="https://blog.joouis.com/tags/server-side/"/>
    
      <category term="render" scheme="https://blog.joouis.com/tags/render/"/>
    
      <category term="isomorphic" scheme="https://blog.joouis.com/tags/isomorphic/"/>
    
  </entry>
  
  <entry>
    <title>Weex Android 发车指南（已弃车）</title>
    <link href="https://blog.joouis.com/2017/08/06/weex-android-quick-tutorial/"/>
    <id>https://blog.joouis.com/2017/08/06/weex-android-quick-tutorial/</id>
    <published>2017-08-05T19:42:26.000Z</published>
    <updated>2018-05-06T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>还记得刚入职见到第一个 YunOS App 时，笔者问师兄 <code>Manifest.json</code> 文件是干嘛用的，师兄说如果你有 Android 开发经验的话就会明白了。当下笔者立马找了本电子书放在桌面准备苦读，结果…时至今日未曾宠幸过。对于没有一点 Java 经验的笔者来说，不知道何时才会迈出无线开发第一步，直到最近遇见了 Weex。<br><a id="more"></a></p><p>Weex 是集团去年推出的移动开发框架，Apache 顶级开源项目，已经被手淘、天猫等业务广泛使用，经历了双十一等活动的考验。它与传统的移动开发不同、也是吸引笔者的地方，即使用 Web 前端技术进行开发且能达到 Native 级别的性能体验。</p><p>既然笔者毫无 Java 以及 Android 开发经验，必然会站在 <strong>纯前端人员的视角</strong> 来带领大家上车。此外，Weex 在集团内外的热度真的是非常之高，相关的文档、博文也是数不胜数，因此文中将会使用一些引用来保证心得的简洁同时给大家更多延伸的内容。</p><h2 id="什么是-Weex-？"><a href="#什么是-Weex-？" class="headerlink" title="什么是 Weex ？"></a>什么是 Weex ？</h2><p>理论角度，<a href="http://weex.apache.org/cn/guide/intro/how-it-works.html" target="_blank" rel="noopener">官方文档</a>上已经说得挺清楚的了，一张流程图可以说明一切。</p><img src="https://v64blg.bn.files.1drv.com/y4mgihO5S41NuNsjSkDcgj3dmHqmgoCLojI9FuKZ1AaB76FK7uSYiyR1HhkKeNwtpDk3UZMvW0gsthHEg1eOyhcoOhZNzE3OzIMwciSO-vDQU5M2F15ZhKe7mU54RriMLd_T3SyoepJfMnxQH7fs_cYOP--tjsnJ5MRCqHwjuF8GC34xP6eODvWzGZbXl8qRj9xl4Enm2-xL6w3b6uRRPCAMQ" title="Source: http://weex.apache.org/cn/guide/images/flow.png"><p>不过回到实际开发，Weex 是什么，这点在没有上手前很难从官方文档中得出结论。（网上有不少声音吐槽 Weex 文档写的不好，笔者持保留态度，不过确实从落地的角度来说，缺乏一些必要的细节，这个后面还会再提。此外作者还有一个疑问，官方文档究的目标群体究竟是谁？是传统的移动端开发者？还是 Web 前端背景的开发人员？至少笔者觉得不是后者。）</p><p>以实践的角度，在笔者看来，Weex 有两部分，一是前端技术方面的自动化框架，在PC端帮助开发人员快速进行 vue 文件的开发、打包等，这部分可以在官网<a href="http://weex.apache.org/cn/guide/set-up-env.html" target="_blank" rel="noopener">搭建开发环境</a>的教程中获取；二是使 JS 代码能在移动端成功运行起来的各平台 SDK 套件或源码，在编译各平台安装包时加入，<a href="http://weex.apache.org/cn/guide/integrate-to-your-app.html" target="_blank" rel="noopener">文档</a>中也有提及。</p><p>除了 Weex 本身，其配套的开发工具比较丰富。有脚手架 <a href="http://weex.apache.org/cn/guide/tools/toolkit.html" target="_blank" rel="noopener">weex-toolkit</a> 、移动端的预览工具 <a href="http://weex.apache.org/cn/playground.html" target="_blank" rel="noopener">Weex Playground</a> 、在线代码执行工具 <a href="http://dotwe.org/vue" target="_blank" rel="noopener">Weex Playground</a> 等。</p><p>最后，官方<a href="http://weex.apache.org/cn/references/" target="_blank" rel="noopener">手册</a>介绍了 Weex 支持的 element 组件、内建的模块、各平台的 API 等开发时需要查阅的东东，很全面，在此不赘述。</p><p>至于 Vue 我想 Web 前端开发者或多或少都是熟悉的，在此不多做介绍。</p><h2 id="如何在-Android-上运行一个最简单的例子？"><a href="#如何在-Android-上运行一个最简单的例子？" class="headerlink" title="如何在 Android 上运行一个最简单的例子？"></a>如何在 Android 上运行一个最简单的例子？</h2><p>官方的入门教程包中含一段最简单的 <code>Hello world</code> 例程，既然 Weex 是为移动端设计，那么是个工程师都想赶快在手机上跑起例程来看看效果，而非在线上模拟器中体验。此时就暴露了文档的缺失——读完《<a href="https://weex.incubator.apache.org/cn/guide/integrate-to-your-app.html" target="_blank" rel="noopener">集成 Weex 到已有应用</a>》一文档后，对没经验的人来说，甚至没办法成功编译出 APK 文件，可谓是出师未捷身先死。</p><p>同时，现实总是残酷的。想在 Android 上运行 Weex 应用，还是需要懂得配置 Android 应用、编写一些 Java 代码，这对前端工程师来说，又是一次 <del>雪上加霜</del> 成长的机会=。=</p><p>在这里推荐两篇文章帮助大家快速上车，正是通过它们笔者成功实现了最小例程的编译及运行：</p><p>第一篇是来自 ATA 的《<a href="https://www.atatech.org/articles/57091" target="_blank" rel="noopener">weex新手指南</a>》，其中包含一个 “知乎日报” 应用源码的详细分析，从中可以知道 <strong>为什么要编写那些 Java 代码</strong> 。</p><p>第二篇文章名为《<a href="http://blog.csdn.net/mengzuixilou/article/details/52690960" target="_blank" rel="noopener">Weex Android 初体验</a>》，其更多地覆盖了实践细节上的问题，并且提供了一个类似最小例程的 github repo，可以 <strong>参考其 Java 源码编写自己的代码</strong> 。</p><h2 id="踩坑心得"><a href="#踩坑心得" class="headerlink" title="踩坑心得"></a>踩坑心得</h2><ol><li>Weex 环境中没有 DOM，因此无法使用像 Jquery 之类关于 DOM 操作的类库。同样的道理，Weex 中样式只支持 <code>px</code> 单位，无法使用 <code>em</code> , <code>rem</code> 。</li><li>Weex 中页面宽度是以 750px 作为标准的！更多信息请参考《<a href="http://coderyi.com/posts/weex1/" target="_blank" rel="noopener">Weex学习与实践（一）</a>》，评论区勾股还贴出了社区讨论的链接。</li><li>开发时一定要使用手机版的 Playground 进行预览，而不是观察本地浏览器中的画面！</li></ol><h2 id="更多阅读"><a href="#更多阅读" class="headerlink" title="更多阅读"></a>更多阅读</h2><ul><li>《<a href="https://www.atatech.org/articles/65406" target="_blank" rel="noopener">WEEX系列文章汇总</a>》：Weex 官方的 ATA 文章，入口帖</li><li>《<a href="https://www.atatech.org/articles/58474" target="_blank" rel="noopener">关于Weex，你想了解的一切都在这里</a>》：又一 Weex 官方的 ATA 文章，入口帖</li><li>《<a href="https://yq.aliyun.com/articles/57996" target="_blank" rel="noopener">weex vs react-native</a>》：同为前端无线技术，不对比就难以了解 Weex 的诉求是什么，对吧</li><li>《<a href="https://www.atatech.org/articles/58910" target="_blank" rel="noopener">Weex总结之Android Weex工程搭建趟坑</a>》：通俗易懂的实践文</li><li>《<a href="https://www.atatech.org/articles/57091" target="_blank" rel="noopener">weex新手指南</a>》：针对最简单的 Android Weex 代码做了详细说明，并提供了一个详细案例（知乎日报）的分析和 github 源码</li></ul><h2 id="姿势观摩"><a href="#姿势观摩" class="headerlink" title="姿势观摩"></a>姿势观摩</h2><ul><li><a href="https://github.com/Hanks10100/weex-vue-examples" target="_blank" rel="noopener">Weex Vue Examples</a>：包含很多基本组件使用的范例</li><li><a href="https://github.com/weexteam/weex-hackernews" target="_blank" rel="noopener">weex-hackernews</a>：很牛逼的 weex 版 hackernews app，包含 Android 工程在内所有的代码，亲测编译 APK 到 7.0 系统中运行</li><li><a href="https://github.com/vuejs/vue-hackernews-2.0" target="_blank" rel="noopener">vue-hakcernews-2.0</a>：想了解更多 Vue 开发可以关注此 repo，web 版 hackernews，Vue 作者亲自开发</li></ul><h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><h3 id="没有详细的文档讲解如何产出最终-APK-文件，蛋疼的-CSS-写法，以及种种…"><a href="#没有详细的文档讲解如何产出最终-APK-文件，蛋疼的-CSS-写法，以及种种…" class="headerlink" title="没有详细的文档讲解如何产出最终 APK 文件，蛋疼的 CSS 写法，以及种种…"></a>没有详细的文档讲解如何产出最终 APK 文件，蛋疼的 CSS 写法，以及种种…</h3><h3 id="已弃坑（微笑脸"><a href="#已弃坑（微笑脸" class="headerlink" title="已弃坑（微笑脸"></a>已弃坑（微笑脸</h3>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;还记得刚入职见到第一个 YunOS App 时，笔者问师兄 &lt;code&gt;Manifest.json&lt;/code&gt; 文件是干嘛用的，师兄说如果你有 Android 开发经验的话就会明白了。当下笔者立马找了本电子书放在桌面准备苦读，结果…时至今日未曾宠幸过。对于没有一点 Java 经验的笔者来说，不知道何时才会迈出无线开发第一步，直到最近遇见了 Weex。&lt;br&gt;
    
    </summary>
    
      <category term="Web 前端" scheme="https://blog.joouis.com/categories/Web-%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="javascript" scheme="https://blog.joouis.com/tags/javascript/"/>
    
      <category term="weex" scheme="https://blog.joouis.com/tags/weex/"/>
    
      <category term="android" scheme="https://blog.joouis.com/tags/android/"/>
    
      <category term="web" scheme="https://blog.joouis.com/tags/web/"/>
    
      <category term="vue" scheme="https://blog.joouis.com/tags/vue/"/>
    
      <category term="mobile" scheme="https://blog.joouis.com/tags/mobile/"/>
    
      <category term="tutorial" scheme="https://blog.joouis.com/tags/tutorial/"/>
    
      <category term="app" scheme="https://blog.joouis.com/tags/app/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 笔记</title>
    <link href="https://blog.joouis.com/2017/03/26/mysql-note/"/>
    <id>https://blog.joouis.com/2017/03/26/mysql-note/</id>
    <published>2017-03-26T08:10:11.000Z</published>
    <updated>2017-10-19T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>这是一篇关于 MySQL 的语法笔记，主要供自己和新手们查看。<br><a id="more"></a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>写在最前面…当然是不要重复造轮子！做笔记也是如此！So ~ 先引用一发：</p><ul><li><strong><a href="http://www.cnblogs.com/mr-wid/archive/2013/05/09/3068229.html" target="_blank" rel="noopener">21分钟 MySQL 入门教程</a></strong></li></ul><h2 id="遣词造句"><a href="#遣词造句" class="headerlink" title="遣词造句"></a>遣词造句</h2><p>像翻译英语句子一样来记录语法。</p><h4 id="按用户名查询用户的所有昵称"><a href="#按用户名查询用户的所有昵称" class="headerlink" title="按用户名查询用户的所有昵称"></a>按用户名查询用户的所有昵称</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span>(nick) <span class="keyword">FROM</span> TABLE_SAMPLE <span class="keyword">WHERE</span> <span class="keyword">name</span> <span class="keyword">IN</span></span><br><span class="line">(<span class="keyword">SELECT</span> <span class="keyword">name</span> <span class="keyword">FROM</span> TABLE_SAMPLE <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">name</span>)</span><br></pre></td></tr></table></figure><h4 id="按月以及平台查询用户数"><a href="#按月以及平台查询用户数" class="headerlink" title="按月以及平台查询用户数"></a>按月以及平台查询用户数</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">DATE_FORMAT</span>(<span class="built_in">time</span>, <span class="string">'%Y-%m'</span>) <span class="keyword">months</span>, <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span>(uid)) <span class="keyword">AS</span> user_count</span><br><span class="line"><span class="keyword">FROM</span> TABLE_SAMPLE <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">months</span>, platforms</span><br></pre></td></tr></table></figure><h4 id="查询时间单位的数据总和"><a href="#查询时间单位的数据总和" class="headerlink" title="查询时间单位的数据总和"></a>查询时间单位的数据总和</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 每分钟</span><br><span class="line">SELECT</span><br><span class="line">SUM(data) AS sum</span><br><span class="line">FROM TABLE_SAMPLE GROUP BY YEAR(time), MONTH(time), DAY(time), HOUR(time), MINUTE(time)</span><br><span class="line"></span><br><span class="line"># 每10分钟</span><br><span class="line">SELECT</span><br><span class="line">SUM(data) AS sum</span><br><span class="line">FROM TABLE_SAMPLE GROUP BY YEAR(time), MONTH(time), DAY(time), HOUR(time), FLOOR(MINUTE(time)/10)</span><br><span class="line"></span><br><span class="line"># 每小时</span><br><span class="line">SELECT</span><br><span class="line">SUM(data) AS sum</span><br><span class="line">FROM TABLE_SAMPLE GROUP BY YEAR(time), MONTH(time), DAY(time), HOUR(time)</span><br><span class="line"></span><br><span class="line"># 后面依此类推...</span><br></pre></td></tr></table></figure><h4 id="查询每小时的数据总和"><a href="#查询每小时的数据总和" class="headerlink" title="查询每小时的数据总和"></a>查询每小时的数据总和</h4><h4 id="一次查询里查询多样数据"><a href="#一次查询里查询多样数据" class="headerlink" title="一次查询里查询多样数据"></a>一次查询里查询多样数据</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">(<span class="keyword">SELECT</span> uid <span class="keyword">FROM</span> TABLE_SAMPLE_1 <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'我最帅'</span>) <span class="keyword">AS</span> uid,</span><br><span class="line">(<span class="keyword">SELECT</span> height <span class="keyword">FROM</span> TABLE_SAMPLE_2 <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'我最帅'</span>) <span class="keyword">AS</span> height</span><br></pre></td></tr></table></figure><h4 id="一次更新多条数据"><a href="#一次更新多条数据" class="headerlink" title="一次更新多条数据"></a>一次更新多条数据</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> TABLE_SAMPLE</span><br><span class="line"><span class="keyword">SET</span> credit = credit + <span class="keyword">CASE</span></span><br><span class="line">  <span class="keyword">WHEN</span> <span class="keyword">name</span> = <span class="string">'我最帅'</span> <span class="keyword">THEN</span> <span class="number">1000</span></span><br><span class="line">  <span class="keyword">WHEN</span> <span class="keyword">name</span> = <span class="string">'我不帅'</span> <span class="keyword">THEN</span> <span class="number">0</span> <span class="keyword">END</span>,</span><br><span class="line">  <span class="built_in">time</span> = <span class="keyword">CURRENT_DATE</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">name</span> <span class="keyword">IN</span> (<span class="string">'我最帅'</span>, <span class="string">'我不帅'</span>)</span><br></pre></td></tr></table></figure><h4 id="一次插入多条数据"><a href="#一次插入多条数据" class="headerlink" title="一次插入多条数据"></a>一次插入多条数据</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> TABLE_SAMPLE (<span class="keyword">name</span>, credit)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">'我最帅'</span>, <span class="number">1000</span>), (<span class="string">'我不帅'</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><ul><li>字串存在： <code>LOCATE(你要查的字符串，对应的域) &gt; 0</code></li><li>字串连接：<code>CONCAT(STR1, STR2, ...)</code> ， <code>CONCAT_WS</code> 第一个参数是分隔符</li><li>时间：<code>FROM_UNIXTIME</code> 和 <code>UNIX_TIMESTAMP</code></li><li>查看倒数第 20 到 30 笔数据：<code>ORDER BY id DESC LIMIT 20, 30</code></li><li>日期：<code>CURDATE() = DATE(NOW())</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一篇关于 MySQL 的语法笔记，主要供自己和新手们查看。&lt;br&gt;
    
    </summary>
    
      <category term="笔记小抄" scheme="https://blog.joouis.com/categories/%E7%AC%94%E8%AE%B0%E5%B0%8F%E6%8A%84/"/>
    
    
      <category term="mysql" scheme="https://blog.joouis.com/tags/mysql/"/>
    
      <category term="note" scheme="https://blog.joouis.com/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>小议 Javascript 数组去重</title>
    <link href="https://blog.joouis.com/2017/02/01/remove-duplicates-from-javascript-array/"/>
    <id>https://blog.joouis.com/2017/02/01/remove-duplicates-from-javascript-array/</id>
    <published>2017-01-31T16:43:39.000Z</published>
    <updated>2017-02-27T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>几乎所有 Javascript （以下简称 js）初学者都会遇到的一个问题：如何（优雅地）去除数组中重复的元素。<br>这个问题在 stack overflow 上被赞了近五百次，不过这并不重要。重要的是，有热心网友给出了全面、专业的回答，让博主看了大呼过瘾。<br>在此对原文进行翻译，与大家一起分享。<br><a id="more"></a></p><p>注：下文中的“物件”对应英文”object”。</p><h1 id="“Smart”-but-naive-way"><a href="#“Smart”-but-naive-way" class="headerlink" title="“Smart” but naïve way"></a>“Smart” but naïve way</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uniqueArray = a.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item, pos</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.indexOf(item) == pos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>最基本的版本：我们迭代整个数组，检查其中每一个元素在数组中第一次出现的位置与该元素实际的位置是否相等，如果不等则为重复元素。<br>使用 <code>filter</code> 的回调函数中的第三个参数 <code>self</code> ，可以避免数组变量的闭包问题（数组中的元素还是数组）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uniqueArray = a.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item, pos, self</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> self.indexOf(item) == pos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>尽管这种算法简洁明了，但是对于大型数组来说尤其缺乏效率（时间复杂度为 n^2）。</p><h1 id="Hashtables-to-the-rescue"><a href="#Hashtables-to-the-rescue" class="headerlink" title="Hashtables to the rescue"></a>Hashtables to the rescue</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniq</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> seen = &#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> a.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seen.hasOwnProperty(item) ? <span class="literal">false</span> : (seen[item] = <span class="literal">true</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常使用的方法是将每个元素存入一张哈希表中，然后直接检查它是否存在。这保证了线性的时间复杂度，但存在至少两个缺点：</p><ul><li>由于在 JavaScript 中，哈希键 (key) 只能为字符串，这将导致上述代码无法区分数字和字符串数字。例如，<code>uniq([1,&quot;1&quot;])</code> 将只会返回 <code>[1]</code> 。</li><li>同理，例如 <code>uniq([{foo:1},{foo:2}])</code> 这样具有相同键的物件也会被认为是一样的，仅得到 <code>[{foo:1}]</code> 。</li></ul><p>也就是说，如果你的数组中仅包含 js 的原始类型 (primitives) 且你无需在意它们的具体种类（例如它们全都是数字），这个算法是最佳的。</p><h1 id="The-best-from-two-worlds"><a href="#The-best-from-two-worlds" class="headerlink" title="The best from two worlds"></a>The best from two worlds</h1><p>结合上述两种方法，有一个通用的解决方案：原始类型使用哈希表查找，而物件使用线性查找…</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniq</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> prims = &#123;<span class="string">"boolean"</span>:&#123;&#125;, <span class="string">"number"</span>:&#123;&#125;, <span class="string">"string"</span>:&#123;&#125;&#125;, objs = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> type = <span class="keyword">typeof</span> item;</span><br><span class="line">        <span class="keyword">if</span>(type <span class="keyword">in</span> prims)</span><br><span class="line">            <span class="keyword">return</span> prims[type].hasOwnProperty(item) ? <span class="literal">false</span> : (prims[type][item] = <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> objs.indexOf(item) &gt;= <span class="number">0</span> ? <span class="literal">false</span> : objs.push(item);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="sort-uniq"><a href="#sort-uniq" class="headerlink" title="sort | uniq"></a>sort | uniq</h1><p>还有一个选择是先对数组排序，然后去除与前一元素相等的元素：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniq</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.sort().filter(<span class="function"><span class="keyword">function</span>(<span class="params">item, pos, ary</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !pos || item != ary[pos - <span class="number">1</span>];</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理，由于 <code>sort</code> 方法无法直接对物件进行排序，因此这种方法对物件无效。另外存在一个副作用——原始数组已被改变。假如输入数组已经是有序的，则可以使用这种方法（同时去掉上述代码中的 <code>sort()</code> 方法）。</p><h1 id="Unique-by…"><a href="#Unique-by…" class="headerlink" title="Unique by…"></a>Unique by…</h1><p>有时候我们希望能基于一些条件而不仅仅是根据数值相等进行唯一化，例如过滤出有共性但是实际是不同的物件（后面会举例说明）。传递回调函数可以优美地解决这一需求。由于 <code>key</code> 预期会返回一个原始类型，因此哈希表在这里可以正常工作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniqBy</span>(<span class="params">a, key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> seen = &#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> a.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> k = key(item);</span><br><span class="line">        <span class="keyword">return</span> seen.hasOwnProperty(k) ? <span class="literal">false</span> : (seen[k] = <span class="literal">true</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>JSON.stringify</code> 就是一个特别有用的 <code>key</code> 回调函数，可以移除“看起来”一样但实际不同的物件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line">b = uniqBy(a, <span class="built_in">JSON</span>.stringify)</span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// [[1,2,3], [4,5,6]]</span></span><br></pre></td></tr></table></figure><p>如果 <code>key</code> 返回的不是原始类型，则需要依赖线性搜索：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniqBy</span>(<span class="params">a, key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> index = [];</span><br><span class="line">    <span class="keyword">return</span> a.filter(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> k = key(item);</span><br><span class="line">        <span class="keyword">return</span> index.indexOf(k) &gt;= <span class="number">0</span> ? <span class="literal">false</span> : index.push(k);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或是使用 ES6 中的 <code>Set</code> 物件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniqBy</span>(<span class="params">a, key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> seen = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    <span class="keyword">return</span> a.filter(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> k = key(item);</span><br><span class="line">        <span class="keyword">return</span> seen.has(k) ? <span class="literal">false</span> : seen.add(k);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(相比 <code>seen.has(k) ? false : seen.add(k)</code> ，有些人更喜欢 <code>!seen.has(k) &amp;&amp; seen.add(k)</code> )</p><h1 id="Libraries"><a href="#Libraries" class="headerlink" title="Libraries"></a>Libraries</h1><p><a href="http://underscorejs.org/#uniq" target="_blank" rel="noopener">Underscore</a> 和 <a href="https://lodash.com/docs#uniq" target="_blank" rel="noopener">Lo-Dash</a> 都提供了 <code>uniq</code> 方法，他们的算法与上述第一段代码类似，总结就是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = [];</span><br><span class="line">a.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(result.indexOf(item) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">         result.push(item);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>其时间复杂度是二次方，但是有些额外的好处，例如封装了原生的 <code>indexOf</code> 方法、可以通过键进行唯一化（官方说法叫 <code>iteratee</code>）、对于有序数组有优势。</p><p>如果使用 jQuery 并且喜欢以美刀符号开头，则大概长这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$.uniqArray = <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $.grep(a, <span class="function"><span class="keyword">function</span>(<span class="params">item, pos</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> $.inArray(item, a) === pos;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，也是第一段代码的变体而已。</p><h1 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h1><p>JavaScript 中函数呼叫的成本昂贵，因此上述方法即使简洁明了，但是并不高效。如果以效能为最高宗旨，将 <code>filter</code> 全部替换成回圈以避免多余的函数呼叫：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniq_fast</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> seen = &#123;&#125;;</span><br><span class="line">    <span class="keyword">var</span> out = [];</span><br><span class="line">    <span class="keyword">var</span> len = a.length;</span><br><span class="line">    <span class="keyword">var</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">         <span class="keyword">var</span> item = a[i];</span><br><span class="line">         <span class="keyword">if</span>(seen[item] !== <span class="number">1</span>) &#123;</span><br><span class="line">               seen[item] = <span class="number">1</span>;</span><br><span class="line">               out[j++] = item;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段丑陋的代码和第三段代码做了相同的事情，但是执行速度上快了一个数量级。</p><p>（测试代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniq</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> seen = &#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> a.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seen.hasOwnProperty(item) ? <span class="literal">false</span> : (seen[item] = <span class="literal">true</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniq_fast</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> seen = &#123;&#125;;</span><br><span class="line">    <span class="keyword">var</span> out = [];</span><br><span class="line">    <span class="keyword">var</span> len = a.length;</span><br><span class="line">    <span class="keyword">var</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">         <span class="keyword">var</span> item = a[i];</span><br><span class="line">         <span class="keyword">if</span>(seen[item] !== <span class="number">1</span>) &#123;</span><br><span class="line">               seen[item] = <span class="number">1</span>;</span><br><span class="line">               out[j++] = item;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> r = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>],</span><br><span class="line">    a = [],</span><br><span class="line">    LEN = <span class="number">1000</span>,</span><br><span class="line">    LOOPS = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(LEN--)</span><br><span class="line">    a = a.concat(r);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; LOOPS; i++)</span><br><span class="line">    uniq(a);</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">'&lt;br&gt;uniq, ms/loop: '</span> + (<span class="keyword">new</span> <span class="built_in">Date</span>() - d)/LOOPS)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; LOOPS; i++)</span><br><span class="line">    uniq_fast(a);</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">'&lt;br&gt;uniq_fast, ms/loop: '</span> + (<span class="keyword">new</span> <span class="built_in">Date</span>() - d)/LOOPS)</span><br></pre></td></tr></table></figure></p><p>）</p><h1 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h1><p>ES6 提供了 <code>Set</code> 物件，让事情变得简单许多：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniq</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> uniq = <span class="function"><span class="params">a</span> =&gt;</span> [...new <span class="built_in">Set</span>(a)];</span><br></pre></td></tr></table></figure><p>需要注意的是，与 Python 不同，ES6 的 <code>set</code> 以插入顺序进行迭代，因此代码保证了原始数组的顺序。</p><p>无论如何，如果你需要一个唯一化的数组，为何不从正确地使用 <code>set</code> 开始呢？</p><h1 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h1><p>文章发在公司内网的技术论坛后，有一些很有价值的反馈。</p><p>有同学按照上述方法进行了测试，发现 demo 的第一种和第二种并不存在“数量级”的差异，另外 Set 的效率也并不高，比前两者都慢。</p><p>我随即也进行了测试，发现确实如此。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MacBook Air (13-inch, Early 2015) 8G Ram</span><br><span class="line">Chrome (版本 56.0.2924.87)</span><br><span class="line"></span><br><span class="line">uniq, ms/loop: 0.362</span><br><span class="line">uniq_fast, ms/loop: 0.171</span><br><span class="line">uniq_set, ms/loop: 1.728</span><br></pre></td></tr></table></figure><p>其次一位资深同学提出以下观点，很有启发：</p><blockquote><p>数组去重的关键点是：如何判断“重复”，是否完备可靠。</p><ol><li>数组类型的 <code>indexOf()</code> 方法不能处理 <code>NaN</code> 的情况</li><li><code>Set</code> 类型的key不支持Object类型，而且会区别对待 <code>1</code> 和 <code>&#39;1&#39;</code></li><li>关于性能测试。建议到jsperf上去写个case跑一跑，比如：<a href="https://jsperf.com/js-unique-array" target="_blank" rel="noopener">https://jsperf.com/js-unique-array</a> ；而且要在多个浏览器下测试。因为不同内核对es语法的实现不一样，表现出来的性能也不一样</li></ol><p>这篇文章也讨论了数组去重问题：<a href="https://www.toobug.net/article/array_unique_in_javascript.html" target="_blank" rel="noopener">https://www.toobug.net/article/array_unique_in_javascript.html</a></p></blockquote><hr><p>源文链接:<br><a href="http://stackoverflow.com/questions/9229645/remove-duplicates-from-javascript-array" target="_blank" rel="noopener">Remove Duplicates from JavaScript Array</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;几乎所有 Javascript （以下简称 js）初学者都会遇到的一个问题：如何（优雅地）去除数组中重复的元素。&lt;br&gt;这个问题在 stack overflow 上被赞了近五百次，不过这并不重要。重要的是，有热心网友给出了全面、专业的回答，让博主看了大呼过瘾。&lt;br&gt;在此对原文进行翻译，与大家一起分享。&lt;br&gt;
    
    </summary>
    
      <category term="Web 前端" scheme="https://blog.joouis.com/categories/Web-%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="javascript" scheme="https://blog.joouis.com/tags/javascript/"/>
    
      <category term="array" scheme="https://blog.joouis.com/tags/array/"/>
    
      <category term="remove duplicates" scheme="https://blog.joouis.com/tags/remove-duplicates/"/>
    
      <category term="stackoverflow" scheme="https://blog.joouis.com/tags/stackoverflow/"/>
    
  </entry>
  
  <entry>
    <title>从硅谷软件企业学习到的细节</title>
    <link href="https://blog.joouis.com/2016/04/29/the-details-i-learned-from-software-company-in-silicon-valley/"/>
    <id>https://blog.joouis.com/2016/04/29/the-details-i-learned-from-software-company-in-silicon-valley/</id>
    <published>2016-04-28T17:23:00.000Z</published>
    <updated>2016-04-28T17:23:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Ryan 哥是我在 Lilee 实习时的同事，按时间来说他比我还晚进入 Lilee (笑)。虽然相处天数很短，但对他印象深刻：个子不高，酷酷的很有型，CMU 毕业，湾区大公司工作经历。在公司每季(？)的新人介绍茶话会上，发现他也是一个很好聊的人。最后我打包滚蛋时，他也是为数不多写邮件给我践行的人。</p><p>就在这个月中旬， Ryan 哥在自己的脸书上写了这里分享的这篇文章，颇具视野和深度，对于我这样的新人来说很受启发，因此也搬运到我的博客上来。本文的<a href="https://www.facebook.com/ryanyang328/posts/10105200442293837" target="_blank" rel="noopener"><strong>原出处</strong></a>，里面还有一些精彩评论，有兴趣也可以去看看。<br><a id="more"></a></p><h1 id="從矽谷軟體企業學習到的細節"><a href="#從矽谷軟體企業學習到的細節" class="headerlink" title="從矽谷軟體企業學習到的細節"></a>從矽谷軟體企業學習到的細節</h1><p>回來台灣一年多了，在矽谷工作時，我總是想說服大家一起回台灣做點小貢獻。但現在，我的確認為台灣需要有更多人出國看一看拓展新的視野，未來有機會再帶回更多新的思維回到家鄉，和台灣原本就保有的優點融合。 之前很高興有機會到交大還有 Sudo 的活動分享在矽谷工作時感受到的文化和經驗。最近還是有許多朋友有興趣想了解台灣軟體業除了以往在資源上的限制，還有什麼樣不同的文化和制度對目前軟體產業造成衝擊和差異性。所以趁這個機會分享一些目前在台灣軟體產業觀察和聽聞的現況，去探討我們可能可以自省的方面。在我們努力衝刺的過程中，希望可以提及幾項在台灣軟體產業看似還普遍缺乏的思維和觀點：</p><ol><li>人是公司最大的資產：在台灣是企業選擇員工，在矽谷是員工選擇企業。矽谷企業普遍認為，人是公司最大的資產。除了公司選擇比較多以外，企業團隊也總是很感激員工的加入， 並且願意提出更好的 counter-offer 努力把好的人才吸引過來。同時，員工也可以用更健康的心態去 negotiate 自己的 offer 讓彼此都達到滿意的結果。 以人為本，公司對人的尊重，是大家最嚮往的文化。</li><li>人格特質 vs 學歷/技術：學歷的迷思應該慢慢被擺脫。在台灣工作，學經歷在一開始就會非常被注重和強調，導致公司對你有了預期，但這個預期指的是”技術”這方面而已。學經歷不錯的人很容易被公司預期在短期內要有所產出。 如果短期內沒有達成，公司會默默的打分數，一切完全以短期技術可行性，當成參考依據來預期未來你對公司可能的影響。矽谷的企業各式各樣的學經歷的人更多元，但比較不一樣的是，公司不會太明顯對每個人預設立場。這之中最大的不同點是，美國公司對你的預期不會純粹以技術為考量，而是整個人的人格特質和全面性。公司願意花更多資源投資每個員工，以幫助公司了解 team member 的人格和個性，積極度，潛力，爆發力，做事的 tempo 和 learning curve 的時間，儘管小公司也有類似的認知。回到以往很多 CMU 的學弟妹都會問我說，INI 會不會是 ECE &amp; CS 底下合開的學院造成在美國找工作的影響。我告訴他們，工作以後就會了解到那並不是矽谷公司在找尋人才唯一強調的事。不論是 Google, Apple 還是各大公司 / startup，在面試聊天時，除了去了解一個人的個性之外，也需要考白板的 coding 測試你的技術能力。考題的例子包括：資料結構的 binary tree，queue，linked-list，演算法的 sorting，Dijkstra，八皇后題目，OS 和系統相關的 synchroization，networking, process / thread，memory management，brain teaser 相關題目像是給兩個雞蛋用數學來測出雞蛋在哪一層會破掉的問題 (我很喜歡的題目之一)。聽起來好像很制式化的流程，但其實對於矽谷的公司來說，那才是他們注重的基本能力和了解一個人是否能與團隊有良好的溝通能力。不論你是什麼學歷，只要你夠積極去充實這些知識，保有好奇心和培養良好的 teamwork，好的人格特質和個性加上技術才是公司想招募的人。</li><li>Code review / QA / 開發流程時間：這是許多公司心裡記得很重要可是卻最不願意花時間和錢投資的項目，原因免不了是 time to market 跟追趕 project 進度。台灣許多公司想要開發高利潤產品走向國際，策略模式卻還是採取以往 hit and run 模式的代工思維。全世界企業都有時間壓力，除了技術以外，我們更應該開始強調軟體管理的學問。Code review 的重要性建立在一個軟體開發的長遠計畫之上，注重的是開發者的邏輯思維和 coding style 會不會影響目前和未來的產品，還有 code 提供給其他工程師的可讀性。開發時，要想著這個軟體未來可能會變幾千行，幾萬行，甚至是幾十萬行的產品。而每個人的 coding style 有所不同，公司需要訂立 coding guideline 來規劃基本規則以方便大家產出 code。這種觀念的缺乏導致很多 code 沒有被 review，或是變成 reviewer 灌輸 developer 他心裡想要的 coding style。而 QA 的方面，感覺各企業對此重視的程度很多年來還是嚴重不足，自然沒有扎實的測試方法論和流程來把關品質。對於開發者來說，應該普遍建立 QA 實際上是公司第一個客戶的觀念，所以測試流程像是 smoke test，regression test，white box testing 在交予 QA 前應該是已經需要被建立好的。Hit and run 的策略短期內也許可以拿到客戶，但長久下來如果價格和品質無法成正比，這樣的關係無法長久。再者，以往累積的 technical debt 在未來需要花的時間還是得花。如果企業想賣高規格的東西，一定要確保品質再出貨。在美國做一樣的工作，一樣執行 waterfall 或 agile 的流程，時間的安排卻是全然不同。因為 time to market 的原因所以在固定時間需要出貨這點是可以理解的，這個時候 PM 很重要。有經驗的 PM 要滿足客戶需求同時也要能替工程師在一定時間內斟酌合理的開發數量和可行性，將開發者方面的測試考慮進去是必要的技能。</li><li>缺乏純技術者的 career path 和職務的 misplace：以技術面來說，台灣軟體技術人才眾多，演算法人才也不在少數，但是普遍需要廣度的員工包山包海，所以欠缺了 Technical Leader 和系統架構師類型的人物的培養。專才需要長期在廣度和深度的訓練和培養，並有著對任何事物的好奇心來整合元件而建立有門檻的大架構，而培養對於任何事物的好奇心回到了教育的本質。普遍來說，台灣企業往往將年資久的員工或是技術領導者全都佈署在管理人的 career path 上。這樣造成的問題是，技術者只有鑽研技術的熱情，並沒有技能去處理跟人相關的事物，導致職缺的misplace。美國的公司普遍在升遷時會要你選擇未來你期許的 career path 是往管理的路或是技術領導者的職涯前進。適合經營管理的人會經歷 software engineer -&gt; senior engineer -&gt; manager -&gt; senior manager -&gt; director -&gt; VP，而技術領導者會經歷 software engineer -&gt; senior engineer -&gt; tech lead -&gt; senior tech lead -&gt; architect / distinguished engineer. 這不僅清楚的替每個升遷的人規劃了更適合自己的路，也替公司員工找到能夠真正管理人的主管進而幫助公司整體的成長和營運。</li><li>本位主義和信賴問題：在人文方面，部門的本位主義過於強烈，所以職場上卡到了許多人跟人的問題或是各單位之間沒有太多向心力是比較多朋友都會提及的經驗。主管應該多培養底下的人有獨立思考的能力，有些時候花些時間跟員工單獨聊天，可以發現目前很多年青人對公司有很多不同的想法和未來的期許。以一個健康的角度來看，主管應該多鼓勵底下的人發言討論，或是鼓勵員工有一天能夠超越自己，但很重要的前提是要彼此尊重。然而，為什麼主管要鼓勵員工超越自己？其實員工有良好的表現不僅幫助了自己，更重要的是同時也幫助了主管和公司向上成長。現在的時代注重團體戰而非英雄主義，不論是員工或主管都應該要知道在不同位子看事物的角度一定有所不同。如果彼此一直無法了解對方的思考方式和表達方式，每個人就始終無法由內而外說服自己為了同個目標前進。矽谷企業的強盛給我的感覺是建立在共存共榮的 teamwork 文化，職權區分明確，良好的溝通管道，傾向對事不對人的模式而一同完成公司的目標。</li><li>缺乏文件整理和 mentor，造成資訊落差：一樣是卡在時間資源的問題，過去的人需要趕時間出貨所以沒有多餘的時間把以往的經驗，技術資訊，或是曾犯過的錯記錄下來，導致新進員工沒有文件可參考也沒有特定的 mentor 可仿效。新人往往會不好意思請求協助，所以元老級的人物每天理解事物越來越快，但新進員工卻越來越追趕不上前人而造成資訊和技術程度上的落差，會逐漸形成公司的一個隱性問題。所以鼓勵大家，可以多使用協作工具，如果在開發時遇到問題，或者是發現以往的技術開發沒有參考文件，都應該踴躍幫忙公司記錄和整理文件，如同開源軟體的無私貢獻。當越來越多同伴到達同樣的水平，才會有可能替企業創造更多的可能性。</li></ol><p>整體而言，這幾年開始可以感受到台灣軟體業的興起和企業對軟體的重視程度提高許多，這是非常正向的鼓勵。同時也有更多學術單位，政府和企業都願意投入更多的金錢，人力，研發資源在軟體產業中。想要捨棄台灣長久以來的代工思維而轉型成高利潤高門檻的產業結構痛苦是必然的過程。很多對台灣企業看來好像要有多出的時間才能執行的項目，其實對於矽谷的企業來說其實都應該是需要注重的細節和基本功。台灣企業如果想要成功走向國際，也會需要很多領導者願意推翻自己過往的經驗和思維，並且有足夠的心胸去接受新世代的觀念而學習。回台灣後當然也總算可以開始體會為什麼台灣年青人都想往外出走，去到一個更健康的工作環境學習。但希望大家還是不要對台灣失望，繼續花點時間感受問題。除了技術的加強，如果更多人能開始注重以人為本的概念，強調更多軟體管理方面細節的改善，就算台灣短期無法被影響，但未來還是有許多值得被改變的事。大家共勉之。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Ryan 哥是我在 Lilee 实习时的同事，按时间来说他比我还晚进入 Lilee (笑)。虽然相处天数很短，但对他印象深刻：个子不高，酷酷的很有型，CMU 毕业，湾区大公司工作经历。在公司每季(？)的新人介绍茶话会上，发现他也是一个很好聊的人。最后我打包滚蛋时，他也是为数不多写邮件给我践行的人。&lt;/p&gt;
&lt;p&gt;就在这个月中旬， Ryan 哥在自己的脸书上写了这里分享的这篇文章，颇具视野和深度，对于我这样的新人来说很受启发，因此也搬运到我的博客上来。本文的&lt;a href=&quot;https://www.facebook.com/ryanyang328/posts/10105200442293837&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;原出处&lt;/strong&gt;&lt;/a&gt;，里面还有一些精彩评论，有兴趣也可以去看看。&lt;br&gt;
    
    </summary>
    
      <category term="技术人生谈" scheme="https://blog.joouis.com/categories/%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F%E8%B0%88/"/>
    
    
      <category term="silicon valley" scheme="https://blog.joouis.com/tags/silicon-valley/"/>
    
      <category term="software" scheme="https://blog.joouis.com/tags/software/"/>
    
      <category term="inspiration" scheme="https://blog.joouis.com/tags/inspiration/"/>
    
  </entry>
  
  <entry>
    <title>Online notes of John Chou</title>
    <link href="https://blog.joouis.com/2016/04/14/online-notes-of-john-chou/"/>
    <id>https://blog.joouis.com/2016/04/14/online-notes-of-john-chou/</id>
    <published>2016-04-14T11:15:44.000Z</published>
    <updated>2016-06-22T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="公开课学习笔记"><a href="#公开课学习笔记" class="headerlink" title="公开课学习笔记"></a>公开课学习笔记</h1><hr><h2 id="Operating-Systems"><a href="#Operating-Systems" class="headerlink" title="Operating Systems"></a>Operating Systems</h2><ul><li>From: <a href="https://www.coursera.org/course/os" target="_blank" rel="noopener">Coursera</a></li><li>Instructor：Chen Xiangqun (Peking University)</li><li>Lang：Simplified Chinese</li><li>State：12 / 12</li><li><a href="https://hackpad.com/Operating-Systems-QPGckPU3RdZ" target="_blank" rel="noopener">Note</a><a id="more"></a></li></ul><h1 id="Jserv-指导的嵌入式课程"><a href="#Jserv-指导的嵌入式课程" class="headerlink" title="Jserv 指导的嵌入式课程"></a>Jserv 指导的嵌入式课程</h1><hr><h2 id="Embedded-Graphics"><a href="#Embedded-Graphics" class="headerlink" title="Embedded Graphics"></a>Embedded Graphics</h2><ul><li><a href="https://paper.dropbox.com/doc/Embedded-Graphics-Entry-cVe71Nm0Kk8OLJlN6Gst2" target="_blank" rel="noopener">Entry</a></li></ul><h2 id="课程资料"><a href="#课程资料" class="headerlink" title="课程资料"></a>课程资料</h2><ul><li><a href="http://wiki.csie.ncku.edu.tw/" target="_blank" rel="noopener">WIKI</a></li><li><a href="https://charles620016.hackpad.com/2015--9ltlOMDQHF5" target="_blank" rel="noopener">2015 嵌入式系统课程资料整理</a></li><li><a href="https://embedded2015.hackpad.com/-C--ThcIjpAhRuO" target="_blank" rel="noopener">「你所不知道的 C 语言」系列讲座</a></li><li><a href="https://jservsummer2015.hackpad.com/8cFyQFQDI7A" target="_blank" rel="noopener">计算机组织结构</a></li><li><a href="https://stm32f429.hackpad.com/NOTE-WbiooOfkaoR" target="_blank" rel="noopener">环境搭建</a></li></ul><h2 id="2015-Q1-Q2"><a href="#2015-Q1-Q2" class="headerlink" title="2015 Q1-Q2"></a>2015 Q1-Q2</h2><ul><li><a href="https://embedded2015.hackpad.com/PITFzQ3GhbH" target="_blank" rel="noopener">Week 2</a>：环境搭建、ARM Architecture</li><li><a href="https://embedded2015.hackpad.com/Week3--Ss4svVnH2ux" target="_blank" rel="noopener">Week 3</a>：FreeRTOS</li><li><a href="https://embedded2015.hackpad.com/Week4--OpKQXepPhau" target="_blank" rel="noopener">Week 4</a>：Visualization for scheduling</li><li><a href="https://embedded2015.hackpad.com/NoteWeek5-MlgKnMDHw4C#:h=許富皓教授的-Linux-核心教材" target="_blank" rel="noopener">Week 5</a>：许富皓教授的 Linux 核心教材</li><li><a href="https://embedded2015.hackpad.com/Week-7-8--ID8HJ3uW0MO" target="_blank" rel="noopener">Week 7 &amp; Week 8</a>：STM32程序开发：以GNU Toolchain为例、Mini ARM OS</li><li><a href="https://embedded2015.hackpad.com/Week-9-GDB-CGDB-pflT0kcqaIY#:h" target="_blank" rel="noopener">Week 9</a>：GDB &amp; CGDB 使用</li><li>RT-Thread：<ul><li><a href="http://wiki.csie.ncku.edu.tw/embedded/rt-thread" target="_blank" rel="noopener">Wiki</a></li><li><a href="https://rt-thread.hackpad.com/RT-Thread-on-Beaglebone-Black-i93C7gRxZuW" target="_blank" rel="noopener">Hackpad</a></li></ul></li><li><a href="https://embedded2015.hackpad.com/Disassemble-a-simple-C-code-to-analyse-the-stack-behavior-euHF5qBGSaM" target="_blank" rel="noopener">Addition</a>：Disassemble a simple C code to analyse the stack behavior</li></ul><h2 id="2015-Q3-Q4"><a href="#2015-Q3-Q4" class="headerlink" title="2015 Q3-Q4"></a>2015 Q3-Q4</h2><ul><li><a href="https://embedded2015.hackpad.com/Week1--33Vj9rizmv2" target="_blank" rel="noopener">HW_1</a>：GNUPlot、GProf、SIMD</li><li><a href="https://embedded2015.hackpad.com/Week2--4z5TKk8W9ML" target="_blank" rel="noopener">HW_2</a>：Assert、ARM Architecture、Perf、Phonebook 搜寻</li><li><a href="https://embedded2015.hackpad.com/Week3--QTwzZuTz35V" target="_blank" rel="noopener">HW_3</a>：Quiz from Leetcode</li><li><a href="https://embedded2015.hackpad.com/Week5--dxQlPW2CwLi" target="_blank" rel="noopener">HW_4</a>：Calling convention、Compiler 基础</li><li><a href="https://embedded2015.hackpad.com/Week6--YxRcynvEYAK" target="_blank" rel="noopener">HW_5</a>：补全之前的作业</li><li><a href="https://embedded2015.hackpad.com/Week7--6mVDBogdssM" target="_blank" rel="noopener">HW_6</a>：基础理论</li><li><a href="https://embedded2015.hackpad.com/Week8--VGN4PI1cUxh" target="_blank" rel="noopener">HW_7</a>：SIMD(SSE, AVX)、prefetch</li><li><a href="http://wiki.csie.ncku.edu.tw/embedded/2015q3h9" target="_blank" rel="noopener">HW_9</a>：阅读资料、提出问题 (GPIO/ADC/USART/SPI/Flash/I2C/USB)</li><li><a href="http://wiki.csie.ncku.edu.tw/User/Joou" target="_blank" rel="noopener">HW_10</a>：个人简历</li><li><a href="https://hackpad.com/8gIhwyW2swE" target="_blank" rel="noopener">补考</a></li><li>μVisor:<ul><li><a href="http://wiki.csie.ncku.edu.tw/embedded/team2015-10" target="_blank" rel="noopener">WIKI</a></li><li><a href="https://embedded2015.hackpad.com/uVisor-Uv1A8aXk1DM" target="_blank" rel="noopener">Hackpad</a></li></ul></li></ul><h1 id="通用笔记"><a href="#通用笔记" class="headerlink" title="通用笔记"></a>通用笔记</h1><hr><h2 id="面试相关"><a href="#面试相关" class="headerlink" title="面试相关"></a>面试相关</h2><ul><li><a href="https://hackpad.com/vUn4TbzLTCj#:h=操作系统" target="_blank" rel="noopener">面试题目</a></li><li><a href="https://paper.dropbox.com/doc/1Inc6vxQ6pYdIUvWzPOwx" target="_blank" rel="noopener">嵌入式的面試題</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;公开课学习笔记&quot;&gt;&lt;a href=&quot;#公开课学习笔记&quot; class=&quot;headerlink&quot; title=&quot;公开课学习笔记&quot;&gt;&lt;/a&gt;公开课学习笔记&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;Operating-Systems&quot;&gt;&lt;a href=&quot;#Operating-Systems&quot; class=&quot;headerlink&quot; title=&quot;Operating Systems&quot;&gt;&lt;/a&gt;Operating Systems&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;From: &lt;a href=&quot;https://www.coursera.org/course/os&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Coursera&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Instructor：Chen Xiangqun (Peking University)&lt;/li&gt;
&lt;li&gt;Lang：Simplified Chinese&lt;/li&gt;
&lt;li&gt;State：12 / 12&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://hackpad.com/Operating-Systems-QPGckPU3RdZ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Note&lt;/a&gt;
    
    </summary>
    
      <category term="笔记小抄" scheme="https://blog.joouis.com/categories/%E7%AC%94%E8%AE%B0%E5%B0%8F%E6%8A%84/"/>
    
    
      <category term="note" scheme="https://blog.joouis.com/tags/note/"/>
    
      <category term="embedded" scheme="https://blog.joouis.com/tags/embedded/"/>
    
      <category term="CS" scheme="https://blog.joouis.com/tags/CS/"/>
    
      <category term="collaborate" scheme="https://blog.joouis.com/tags/collaborate/"/>
    
  </entry>
  
</feed>
